\nonstopmode
\documentclass{article}
\usepackage[poster,style=bubble]{k}
\title{PHP}
\begin{document}
\begin{kdefinition}
\maketitle
\begin{module}{\moduleName{SHARED}}

\begin{syntaxBlock}{\nonTerminal{\sort{LoopFrame}}}\syntax{{}\terminal{\#loopFrame}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{Bool}}}})}{}
\end{syntaxBlock}
\begin{kblock}[text]
 \subsection{Helper cnstructs} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{*Cond}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{\kattribute{strict}(1)}
\end{syntaxBlock}
\krule[cond-true]{
\kprefix{k}{\reduce{{}\terminal{*Cond}({\constant[\#Bool]{true}},{\variable[K]{ActionTrue}},{\AnyVar[K]})}{\variable[K]{ActionTrue}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"cond-true"}}}
}{}{}{\kattribute{internal}}{}
\krule[cond-false]{
\kprefix{k}{\reduce{{}\terminal{*Cond}({\constant[\#Bool]{false}},{\AnyVar[K]},{\variable[K]{ActionFalse}})}{\variable[K]{ActionFalse}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"cond-false"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{*or}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{\kattribute{strict}(1)}
\end{syntaxBlock}
\krule[spec-or-true]{
\kprefix{k}{\reduce{{}\terminal{*or}({\constant[\#Bool]{true}},{\AnyVar[K]})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"or-true"}}}
}{}{}{\kattribute{internal}}{}
\krule[spec-or-false]{
\kprefix{k}{\reduce{{}\terminal{*or}({\constant[\#Bool]{false}},{\variable[K]{K}})}{\variable[K]{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"or-false"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{ThisTag}}}\syntax{{}\terminal{thisTag}({{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule{
\reduce{isKResult({}\terminal{thisTag}({\AnyVar[K]}))}{\constant[\#Bool]{true}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{ConvertibleToLoc}}}\syntax{{\nonTerminal{\sort{LiteralValue}}}}{}\syntaxCont{{\nonTerminal{\sort{Ref}}}}{}\syntaxCont{{\nonTerminal{\sort{ThisTag}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{ConversionMode}}}\syntax{{}\terminal{l}}{}\syntaxCont{{}\terminal{r}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{OptionConversionMode}}}\syntax{{\nonTerminal{\sort{ConversionMode}}}}{}\syntaxCont{{\nonTerminal{\sort{None}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{Loc}}}\syntax{{}\terminal{convertToLoc}({{\nonTerminal{\sort{ConvertibleToLoc}}}},{{\nonTerminal{\sort{OptionConversionMode}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{convertToLoc}({\variable[LiteralValue]{V}},{\AnyVar[K]})}{{}\terminal{allocValue}({\variable[LiteralValue]{V}})}}{}{}{}{}
\krule{
\reduce{{}\terminal{convertToLoc}({\variable[Ref]{R}},{{}\terminal{l}})}{{}\terminal{Lget}({\variable[Ref]{R}})}}{}{}{}{}
\krule{
\reduce{{}\terminal{convertToLoc}({\variable[Ref]{R}},{{}\terminal{r}})}{{}\terminal{Rget}({\variable[Ref]{R}})}}{}{}{}{}
\krule{
\reduce{{}\terminal{convertToLoc}({{}\terminal{thisTag}({\variable[K]{L}})},{\AnyVar[K]})}{\variable[K]{L}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{BasicRef}}}\syntax{{}\terminal{toBasicRef}({{\nonTerminal{\sort{LRef}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{toBasicRef}({{}\terminal{lref}({\variable[Ref]{R}},{\variable[Key]{X}},{\variable[RefType]{T}})})}{{}\terminal{ref}({{}\terminal{LgetRef}({\variable[Ref]{R}},{\variable[RefType]{T}})},{\variable[Key]{X}})}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{ConvertibleToLanguageValue}}}\syntax{{\nonTerminal{\sort{Loc}}}}{}\syntaxCont{{\nonTerminal{\sort{ConvertibleToLoc}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{LanguageValue}}}\syntax{{}\terminal{convertToLanguageValue}({{\nonTerminal{\sort{ConvertibleToLanguageValue}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{convertToLanguageValue}({\variable[Loc]{L}})}{{}\terminal{\#read}({\variable[Loc]{L}})}}{}{}{}{}
\krule{
\reduce{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLoc]{V}})}{{}\terminal{\#read}({{}\terminal{convertToLoc}({\variable[ConvertibleToLoc]{V}},{{}\terminal{r}})})}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#isEqualScalar}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{\kattribute{seqstrict}}
\end{syntaxBlock}
\krule[isEqual-scalar-RHS2LangValue]{
\kprefix{k}{{}\terminal{\#isEqualScalar}({\AnyVar[K]},{\reduce{\variable[ConvertibleToLanguageValue]{R2}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R2}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-scalar-RHS2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[isEqual-scalar-LS2LangValue]{
\kprefix{k}{{}\terminal{\#isEqualScalar}({\reduce{\variable[ConvertibleToLanguageValue]{R1}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R1}})}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-scalar-LS2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[isEqual-scalar]{
\kprefix{k}{\reduce{{}\terminal{\#isEqualScalar}({\variable[Int]{I1}},{\variable[Int]{I2}})}{{\variable[Int]{I1}}\mathrel{{=}{=}_{\scriptstyle\it Int}}{\variable[Int]{I2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-scalar"}}}
}{}{}{\kattribute{internal}}{}
\end{module}
\begin{module}{\moduleName{K-VISITOR}}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{\mbox{apply }{{\nonTerminal{\sort{KLabel}}}}\mbox{ in }{{\nonTerminal{\sort{KList}}}}\mbox{ if }{{\nonTerminal{\sort{KLabel}}}}}{}\syntaxCont{\mbox{apply }{{\nonTerminal{\sort{KLabel}}}}\mbox{ in }{{\nonTerminal{\sort{KList}}}}\mbox{ if }{{\nonTerminal{\sort{KLabel}}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{{\nonTerminal{\sort{K}}}}\framebox{$\kra$}{{\nonTerminal{\sort{K}}}}}{\kattribute{strict}}\syntaxCont{{{\nonTerminal{\sort{K}}}}\framebox{$,\!\!,$}{{\nonTerminal{\sort{K}}}}}{\kattribute{strict}}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KResult}}}\syntax{\framebox{${{\nonTerminal{\sort{KList}}}}$}}{}
\end{syntaxBlock}
\krule{
\reduce{\mbox{apply }{\variable[KLabel]{A}}\mbox{ in }{\variable[KList]{Kl}}\mbox{ if }{\variable[KLabel]{Pred}}}{{}\terminal{\#if}{{\variable[KLabel]{Pred}(\variable[KList]{Kl})}\mathrel{=_K}{\constant[\#Bool]{true}}}\terminal{\#then}{\variable[KLabel]{A}(\variable[KList]{Kl})}\terminal{\#else}{\mbox{apply }{\variable[KLabel]{A}}\mbox{ in }{\variable[KList]{Kl}}\mbox{ if }{\variable[KLabel]{Pred}}}\terminal{\#fi}}}{}{}{\kattribute{structural}}{}
\krule{
\reduce{\mbox{apply }{\variable[KLabel]{A}}\mbox{ in }{\variable[KLabel]{Label}(\variable[KList]{Kl})}\mbox{ if }{\variable[KLabel]{Pred}}}{\framebox{\variable[KLabel]{Label}}(\mbox{apply }{\variable[KLabel]{A}}\mbox{ in }{\variable[KList]{Kl}}\mbox{ if }{\variable[KLabel]{Pred}})}}{}{}{\kattribute{structural}}{}
\krule{
\reduce{\mbox{apply }{\variable[KLabel]{A}}\mbox{ in }{\dotCt{K}}\mbox{ if }{\variable[KLabel]{Pred}}}{\framebox{${\dotCt{K}}$}}}{}{}{\kattribute{structural}}{}
\krule{
\reduce{\mbox{apply }{\variable[KLabel]{A}}\mbox{ in }{\variable[K]{K1}\kra\variable[K]{K2}}\mbox{ if }{\variable[KLabel]{Pred}}}{{\mbox{apply }{\variable[KLabel]{A}}\mbox{ in }{\variable[K]{K1}}\mbox{ if }{\variable[KLabel]{Pred}}}\framebox{$\kra$}{\mbox{apply }{\variable[KLabel]{A}}\mbox{ in }{\variable[K]{K2}}\mbox{ if }{\variable[KLabel]{Pred}}}}}{{{\variable[K]{K1}}\mathrel{\neq_K}{\dotCt{K}}}\wedge_{\scriptstyle\it Bool}{{\variable[K]{K2}}\mathrel{\neq_K}{\dotCt{K}}}}{}{\kattribute{structural}}{}
\krule{
\reduce{\mbox{apply }{\variable[KLabel]{A}}\mbox{ in }{}\mbox{ if }{\variable[KLabel]{Pred}}}{\framebox{${}$}}}{}{}{\kattribute{structural}}{}
\krule{
\reduce{\mbox{apply }{\variable[KLabel]{A}}\mbox{ in }{\variable[K]{K1}\kcomma\variable[KList]{NeKl}}\mbox{ if }{\variable[KLabel]{Pred}}}{{\mbox{apply }{\variable[KLabel]{A}}\mbox{ in }{\variable[K]{K1}}\mbox{ if }{\variable[KLabel]{Pred}}}\framebox{$,\!\!,$}{\mbox{apply }{\variable[KLabel]{A}}\mbox{ in }{\variable[KList]{NeKl}}\mbox{ if }{\variable[KLabel]{Pred}}}}}{{\variable[KList]{NeKl}}\terminal{=/=KList}{}}{}{\kattribute{structural}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\framebox{{\nonTerminal{\sort{KLabel}}}}}{}
\end{syntaxBlock}
\kcontext{
\framebox{\variable[KLabel]{Label}}(\AnyVar[KList]\kcomma\khole{}\kcomma\AnyVar[KList])}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{\it unbox}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule{
\reduce{{\it unbox}({\left({\framebox{${\variable[K]{K}}$}}\right)})}{\variable[K]{K}}}{}{}{\kattribute{structural}}{}
\krule{
\reduce{\framebox{\variable[KLabel]{Label}}(\framebox{${\variable[KList]{Kl}}$})}{\framebox{${\variable[KLabel]{Label}(\variable[KList]{Kl})}$}}}{}{}{\kattribute{structural}}{}
\krule{
\reduce{{\framebox{${\variable[KList]{Kl}}$}}\framebox{$,\!\!,$}{\framebox{${\variable[KList]{Kl'}}$}}}{\framebox{${\left({\variable[KList]{Kl}\kcomma\variable[KList]{Kl'}}\right)}$}}}{}{}{\kattribute{structural}}{}
\krule{
\reduce{{\framebox{${\variable[K]{K1}}$}}\framebox{$\kra$}{\framebox{${\variable[K]{K2}}$}}}{\framebox{${\left({\variable[K]{K1}\kra\variable[K]{K2}}\right)}$}}}{}{}{\kattribute{structural}}{}
\end{module}
\begin{module}{\moduleName{PROGRAM-TRANSFORMATIONS}}
\begin{kblock}[text]
 \subsection{Static declarations} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#makeStaticDecls}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{Loc}}}})}{}
\end{syntaxBlock}
\krule[make-static-decls]{
\kprefix{k}{\reduce{{}\terminal{\#makeStaticDecls}({\variable[K]{P}},{\variable[Loc]{L}})}{\mbox{apply }{'MakeStaticDecl}\mbox{ in }{\variable[K]{P}}\mbox{ if }{'staticDeclFound}}}
\mathrel{}\kall{function}{\reduce{\AnyVar[K]}{\variable[Loc]{L}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"make-static-decls"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{staticDeclFound}({{\nonTerminal{\sort{K}}}})}{\kattribute{klabel}('staticDeclFound), \kattribute{predicate}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{staticDeclFound}({\variable[K]{S}})}{\constant[\#Bool]{true}}}{{\left({{{}\terminal{getKLabel}{\left({\variable[K]{S}}\right)}}\mathrel{=_{\it KLabel}}{'DeclareStatic}}\right)}\vee_{\scriptstyle\it Bool}{\left({{{}\terminal{getKLabel}{\left({\variable[K]{S}}\right)}}\mathrel{=_{\it KLabel}}{'FunctionDecl}}\right)}}{}{}{}
\krule{
\reduce{{}\terminal{staticDeclFound}({'FunctionCall('FunctionName(\constant[\#String]{"define"})\kcomma'ListWrap(\variable[KList]{Args}))})}{\constant[\#Bool]{true}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{MakeStaticDecl}({{\nonTerminal{\sort{K}}}})}{\kattribute{klabel}('MakeStaticDecl)}
\end{syntaxBlock}
\krule[make-static-decl-1]{
\kprefix{k}{\reduce{{}\terminal{MakeStaticDecl}({'DeclareStatic('ListWrap())})}{\framebox{${\variable[K]{ProcStaticDecls}}$}}}
\mathrel{}\kall{processedStaticDeclarations}{\reduce{\variable[K]{ProcStaticDecls}}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"make-static-decl-1"}}}
}{}{}{\kattribute{internal}}{}
\krule[make-static-decl-2]{
\kprefix{k}{\reduce{{}\terminal{MakeStaticDecl}({\variable[K]{F}})}{\framebox{${\variable[K]{F}}$}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"make-static-decl-2"}}}
}{{{}\terminal{getKLabel}{\left({\variable[K]{F}}\right)}}\mathrel{=_{\it KLabel}}{'FunctionDecl}}{}{\kattribute{internal}}{}
\krule[make-static-decl-3]{
\kprefix{k}{\reduce{{}\terminal{MakeStaticDecl}({'FunctionCall('FunctionName(\constant[\#String]{"define"})\kcomma'ListWrap(\variable[KList]{Args}))})}{'Expr('FunctionCall('FunctionName(\constant[\#String]{"define"})\kcomma'ListWrap(\variable[KList]{Args})))\kra\framebox{${\constant[\#Bool]{true}}$}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"make-static-decl-3"}}}
}{}{}{\kattribute{internal}}{}
\krule[make-static-decl-cons-1]{
\kprefix{k}{\reduce{{}\terminal{MakeStaticDecl}({'DeclareStatic('ListWrap('StaticVariable('Variable('Simple(\variable[String]{X}))\kcomma\variable[K]{V})\kcomma\variable[KList]{G}))})}{'Expr('Assign({}\terminal{ref}({\variable[Loc]{L}},{\variable[String]{X}})\kcomma\variable[K]{V}))\kra{}\terminal{MakeStaticDecl}({'DeclareStatic('ListWrap(\variable[KList]{G}))})}}
\mathrel{}\kall{function}{\variable[Loc]{L}}
\mathrel{}\kall{processedStaticDeclarations}{\reduce{\variable[K]{D}}{\variable[K]{D}\kra{}\terminal{\#makeStaticDecl}({\variable[String]{X}},{\variable[Loc]{L}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"make-static-decl-cons-1"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[make-static-decl-cons-2]{
\kprefix{k}{\reduce{{}\terminal{MakeStaticDecl}({'DeclareStatic('ListWrap('StaticVariable('Variable('Simple(\variable[String]{X})))\kcomma\variable[KList]{G}))})}{{}\terminal{MakeStaticDecl}({'DeclareStatic('ListWrap('StaticVariable('Variable('Simple(\variable[String]{X}))\kcomma{}\terminal{NULL})\kcomma\variable[KList]{G}))})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"make-static-decl-cons-2"}}}
}{}{}{\kattribute{intermediate}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#makeStaticDecl}({{\nonTerminal{\sort{String}}}},{{\nonTerminal{\sort{Loc}}}})}{}
\end{syntaxBlock}
\krule[make-static-decl]{
\kprefix{k}{\reduce{{}\terminal{\#makeStaticDecl}({\variable[String]{X}},{\variable[Loc]{Ls}})}{'Expr('ReferenceAssign({}\terminal{ref}({\variable[Loc]{L}},{\variable[String]{X}})\kcomma{}\terminal{ref}({\variable[Loc]{Ls}},{\variable[String]{X}})))}}
\mathrel{}\kall{currentScope}{\variable[Loc]{L}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"make-static-decl"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Allowing functions to be called before declaratoon} 
		The following operations are meant to be executed at initialization. What happens
		is that a refactoring of the initial code is performed, by moving at the top
		all function and class declarations so that those will be always available in the
		program, also before declaration. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#refactor}({{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[refactor-cons-fun]{
\kprefix{k}{\reduce{{}\terminal{\#refactor}({'ListWrap(\variable[KList]{K}\kcomma\variable[K]{D})})}{{}\terminal{\#refactor}({'ListWrap(\variable[KList]{K})})}}
\mathrel{}\kprefix{declarations}{\reduce{\dotCt{K}}{\variable[K]{D}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"refactor-cons-fun"}}}
}{\left({{{}\terminal{getKLabel}{\left({\variable[K]{D}}\right)}}\mathrel{=_{\it KLabel}}{'FunctionDecl}}\right)}{}{\kattribute{intermediate}}{}
\krule[refactor-cons-no-fun]{
\kprefix{k}{\reduce{{}\terminal{\#refactor}({'ListWrap(\variable[KList]{K}\kcomma\variable[K]{C})})}{{}\terminal{\#refactor}({'ListWrap(\variable[KList]{K})})}}
\mathrel{}\kprefix{commands}{\reduce{\dotCt{K}}{\variable[K]{C}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"refactor-cons-no-fun"}}}
}{\left({{{}\terminal{getKLabel}{\left({\variable[K]{C}}\right)}}\mathrel{\neq_{\it KLabel}}{'FunctionDecl}}\right)}{}{\kattribute{intermediate}}{}
\krule[refactor-nil-fun]{
\kprefix{k}{\reduce{{}\terminal{\#refactor}({\variable[K]{D}})}{{}\terminal{\#run}}}
\mathrel{}\kprefix{declarations}{\reduce{\dotCt{K}}{\variable[K]{D}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"refactor-nil-fun"}}}
}{\left({{{}\terminal{getKLabel}{\left({\variable[K]{D}}\right)}}\mathrel{=_{\it KLabel}}{'FunctionDecl}}\right)}{}{\kattribute{internal}}{}
\krule[refactor-nil-no-fun]{
\kprefix{k}{\reduce{{}\terminal{\#refactor}({\variable[K]{C}})}{{}\terminal{\#run}}}
\mathrel{}\kprefix{commands}{\reduce{\dotCt{K}}{\variable[K]{C}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"refactor-nil-no-fun"}}}
}{\left({{{}\terminal{getKLabel}{\left({\variable[K]{C}}\right)}}\mathrel{\neq_{\it KLabel}}{'FunctionDecl}}\right)}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#run}}{}\syntaxCont{{}\terminal{\#quotedCode}({{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[run]{
\kall{k}{\reduce{\left({{}\terminal{\#run}\kra\variable[K]{K}}\right)}{{}\terminal{\#quotedCode}({\variable[K]{D}\kra\variable[K]{C}})\kra\variable[K]{K}}}
\mathrel{}\kall{declarations}{\reduce{\variable[K]{D}}{\dotCt{K}}}
\mathrel{}\kall{commands}{\reduce{\variable[K]{C}}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"run"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Detect deprecated} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{detectDeprecated}({{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[detect-zebra]{
\kprefix{k}{\reduce{{}\terminal{detectDeprecated}({\variable[K]{P}})}{\mbox{apply }{'MakeDeprecatedWarning}\mbox{ in }{\variable[K]{P}}\mbox{ if }{'deprecatedIdiomFound}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"detect-zebra"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{deprecatedIdiomFound}({{\nonTerminal{\sort{K}}}})}{\kattribute{klabel}('deprecatedIdiomFound), \kattribute{predicate}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{deprecatedIdiomFound}({'ReferenceAssign(\AnyVar[KList]\kcomma'ObjectCreation(\AnyVar[KList]))})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{deprecatedIdiomFound}({\variable[K]{S}})}{\constant[\#Bool]{false}}}{{{}\terminal{getKLabel}{\left({\variable[K]{S}}\right)}}\mathrel{\neq_{\it KLabel}}{'ObjectCreation}}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{MakeDeprecatedWarning}({{\nonTerminal{\sort{K}}}})}{\kattribute{klabel}('MakeDeprecatedWarning)}
\end{syntaxBlock}
\krule[make-deprecated-warning]{
\kprefix{k}{\reduce{{}\terminal{MakeDeprecatedWarning}({\variable[K]{K}})}{{}\terminal{DEPRECATED}({\constant[\#String]{"Assigning the return value of new by reference is deprecated in \%s on line \%d\textbackslash n"}})\kra\framebox{${\variable[K]{K}}$}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"make-deprecated-warning"}}}
}{}{}{\kattribute{internal}}{}
\end{module}
\begin{module}{\moduleName{BUILTIN-FUNCTIONS}}
\begin{kblock}[text]
 \section{Builtin Functions} \end{kblock}
\begin{kblock}[text]
 \subsection{array key exists} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{array\_key\_exists}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[array-key-exists-RHS2LangValue]{
\kprefix{k}{{}\terminal{array\_key\_exists}({\AnyVar[K]},{\reduce{\variable[ConvertibleToLanguageValue]{V}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{V}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-key-exists-RHS2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[array-key-exists-LHS2LangValue]{
\kprefix{k}{{}\terminal{array\_key\_exists}({\reduce{\variable[ConvertibleToLanguageValue]{V}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{V}})}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-key-exists-LHS2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[array-key-exists-obj]{
\kprefix{k}{{}\terminal{array\_key\_exists}({\AnyVar[K]},{\reduce{{}\terminal{OID}({\variable[K]{L}},{\AnyVar[K]},{\AnyVar[K]})}{\variable[K]{L}}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-key-exists-obj"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[array-key-exists]{
\kprefix{k}{\reduce{{}\terminal{array\_key\_exists}({\variable[Key]{X}},{{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})})}{{\variable[List]{Elems}}\terminal{hasProperty}{\variable[Key]{X}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-key-exists"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{count} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{count}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[count-arg2LangValue]{
\kprefix{k}{{}\terminal{count}({\reduce{\variable[ConvertibleToLanguageValue]{V}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{V}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"count-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[count-object]{
\kprefix{k}{{}\terminal{count}({\reduce{{}\terminal{OID}({\variable[K]{L}},{\AnyVar[K]},{\AnyVar[K]})}{\variable[K]{L}}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"count-object"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[count-scalar-value]{
\kprefix{k}{\reduce{{}\terminal{count}({\variable[LanguageValue]{V}})}{\constant[\#Int]{1}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"count-scalar-value"}}}
}{{\left({\neg_{\scriptstyle\it Bool}{\left({{\variable[LanguageValue]{V}}\terminal{isCompoundValue}}\right)}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{\variable[LanguageValue]{V}}\mathrel{\neq_K}{{}\terminal{NULL}}}\right)}}{}{\kattribute{internal}}{}
\krule[count-null]{
\kprefix{k}{\reduce{{}\terminal{count}({{}\terminal{NULL}})}{\constant[\#Int]{0}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"count-null"}}}
}{}{}{\kattribute{internal}}{}
\krule[count-array]{
\kprefix{k}{\reduce{{}\terminal{count}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})})}{{}\terminal{len}({\variable[List]{Elems}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"count-array"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Current} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#current}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[current-arg2Loc]{
\kprefix{k}{{}\terminal{\#current}({\reduce{\variable[ConvertibleToLoc]{R}}{{}\terminal{convertToLoc}({\variable[ConvertibleToLoc]{R}},{{}\terminal{r}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"current-arg2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[current-obj]{
\kprefix{k}{{}\terminal{\#current}({\reduce{\variable[Loc]{L}}{\variable[K]{L1}}})}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L1}},{\AnyVar[K]},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"current-obj"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[current-none]{
\kprefix{k}{\reduce{{}\terminal{\#current}({\variable[Loc]{L}})}{\constant[\#Bool]{false}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({{}\terminal{none}},{\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"current-none"}}}
}{}{}{\kattribute{internal}}{}
\krule[current-some]{
\kprefix{k}{\reduce{{}\terminal{\#current}({\variable[Loc]{L}})}{\variable[K]{L1}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({[{\AnyVar[K]},{\AnyVar[K]},{\variable[K]{L1}}]},{\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"current-some"}}}
}{}{}{\kattribute{internal}}{}
\krule[current-null]{
\kprefix{k}{\reduce{{}\terminal{\#current}({\variable[Loc]{L}})}{{}\terminal{NULL}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"current-null"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{{}\terminal{\#isArrayType}({\variable[Value]{V}})}\vee_{\scriptstyle\it Bool}{{}\terminal{\#isObjectType}({\variable[Value]{V}})}}\right)}}{}{\kattribute{internal}}{}
\krule[obj-access-false]{
\kprefix{k}{\reduce{'ObjectAccess(\AnyVar[KList]\kcomma\constant[\#Bool]{false})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"obj-access-false"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \subsection{Key} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#key}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[key-arg2Loc]{
\kprefix{k}{\reduce{{}\terminal{\#key}({\variable[Ref]{R}})}{{}\terminal{\#key}({{}\terminal{convertToLoc}({\variable[Ref]{R}},{{}\terminal{r}})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"key-arg2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[key-obj]{
\kprefix{k}{{}\terminal{\#key}({\reduce{\variable[Loc]{L}}{\variable[K]{L1}}})}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L1}},{\AnyVar[K]},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"key-obj"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[key.none]{
\kprefix{k}{\reduce{{}\terminal{\#key}({\variable[Loc]{L}})}{\constant[\#Bool]{false}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({{}\terminal{none}},{\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"key.none"}}}
}{}{}{\kattribute{internal}}{}
\krule[key-some]{
\kprefix{k}{\reduce{{}\terminal{\#key}({\variable[Loc]{L}})}{\variable[K]{X}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({[{\variable[K]{X}},{\AnyVar[K]},{\AnyVar[K]}]},{\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"key-some"}}}
}{}{}{\kattribute{internal}}{}
\krule[key-scalar]{
\kprefix{k}{\reduce{{}\terminal{\#key}({\variable[Loc]{L}})}{{}\terminal{NULL}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"key-scalar"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{{}\terminal{\#isArrayType}({\variable[Value]{V}})}\vee_{\scriptstyle\it Bool}{{}\terminal{\#isObjectType}({\variable[Value]{V}})}}\right)}}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Next} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#next}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[next-arg2Loc]{
\kprefix{k}{\reduce{{}\terminal{\#next}({\variable[Ref]{R}})}{{}\terminal{\#next}({{}\terminal{convertToLoc}({\variable[Ref]{R}},{{}\terminal{r}})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"next-arg2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[next-obj]{
\kprefix{k}{\reduce{{}\terminal{\#next}({\variable[Loc]{L}})}{{}\terminal{\#next}({\variable[K]{L1}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L1}},{\AnyVar[K]},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"next-obj"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[next-not-last-item]{
\kprefix{k}{\reduce{{}\terminal{\#next}({\variable[Loc]{L}})}{{}\terminal{\#current}({\variable[Loc]{L}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\reduce{\variable[K]{Crnt}}{\variable[K]{Next}}},{\AnyVar[List]\mathrel{}\variable[K]{Crnt}\mathrel{}\variable[K]{Next}\mathrel{}\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"next-not-last-item"}}}
}{}{}{\kattribute{internal}}{}
\krule[next-last-item]{
\kprefix{k}{\reduce{{}\terminal{\#next}({\variable[Loc]{L}})}{{}\terminal{\#current}({\variable[Loc]{L}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\reduce{\variable[K]{Crnt}}{{}\terminal{none}}},{\AnyVar[List]\mathrel{}\variable[K]{Crnt}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"next-last-item"}}}
}{}{}{\kattribute{internal}}{}
\krule[next-scalar]{
\kprefix{k}{\reduce{{}\terminal{\#next}({\variable[Loc]{L}})}{{}\terminal{NULL}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"next-scalar"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{{}\terminal{\#isArrayType}({\variable[Value]{V}})}\vee_{\scriptstyle\it Bool}{{}\terminal{\#isObjectType}({\variable[Value]{V}})}}\right)}}{}{}{}
\begin{kblock}[text]
 \subsection{Reset} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#reset}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[reset-arg-strict]{
\kprefix{k}{\reduce{{}\terminal{\#reset}({\variable[Ref]{R}})}{{}\terminal{\#reset}({{}\terminal{convertToLoc}({\variable[Ref]{R}},{{}\terminal{r}})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"reset-arg-strict"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[reset-obj]{
\kprefix{k}{{}\terminal{\#reset}({\reduce{\variable[Loc]{L}}{\variable[K]{L1}}})}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L1}},{\AnyVar[K]},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"reset-obj"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[reset-array]{
\kprefix{k}{\reduce{{}\terminal{\#reset}({\variable[Loc]{L}})}{{}\terminal{\#current}({\variable[Loc]{L}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\reduce{\AnyVar[K]}{{}\terminal{head}({\variable[List]{K}})}},{\variable[List]{K}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"reset-array"}}}
}{}{}{\kattribute{internal}}{}
\krule[reset-scalar]{
\kprefix{k}{\reduce{{}\terminal{\#reset}({\variable[Loc]{L}})}{{}\terminal{NULL}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[K]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"reset-scalar"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[K]{V}}\terminal{isCompoundValue}}\right)}}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Each} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#each}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[each-arg2Loc]{
\kprefix{k}{\reduce{{}\terminal{\#each}({\variable[Ref]{R}})}{{}\terminal{\#each}({{}\terminal{convertToLoc}({\variable[Ref]{R}},{{}\terminal{r}})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"each-arg2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[each-obj]{
\kprefix{k}{\reduce{{}\terminal{\#each}({\variable[Loc]{L}})}{{}\terminal{\#each}({\variable[K]{L1}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L1}},{\AnyVar[K]},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"each-obj"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[each-scalar]{
\kprefix{k}{\reduce{{}\terminal{\#each}({\variable[Loc]{L}})}{{}\terminal{NULL}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"each-scalar"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[Value]{V}}\terminal{isCompoundValue}}\right)}}{}{\kattribute{internal}}{}
\krule[each-none]{
\kprefix{k}{\reduce{{}\terminal{\#each}({\variable[Loc]{L}})}{\constant[\#Bool]{false}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({{}\terminal{none}},{\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"each-none"}}}
}{}{}{\kattribute{internal}}{}
\krule[each-last]{
\kprefix{k}{\reduce{{}\terminal{\#each}({\variable[Loc]{L}})}{'Array('ListWrap('Pair('Some('Key(\constant[\#Int]{0}))\kcomma'Value(\variable[K]{K}))\kcomma'Pair('Some('Key(\constant[\#Int]{1}))\kcomma'Value({}\terminal{convertToLanguageValue}({\variable[K]{L1}})))\kcomma'Pair('Some('Key(\constant[\#String]{"key"}))\kcomma'Value(\variable[K]{K}))\kcomma'Pair('Some('Key(\constant[\#String]{"value"}))\kcomma'Value({}\terminal{convertToLanguageValue}({\variable[K]{L1}})))))}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\reduce{[{\variable[K]{K}},{\variable[K]{V}},{\variable[K]{L1}}]}{\variable[K]{Next}}},{\AnyVar[List]\mathrel{}[{\variable[K]{X}},{\variable[K]{V}},{\variable[K]{L1}}]\mathrel{}\variable[K]{Next}\mathrel{}\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"each-last"}}}
}{}{}{\kattribute{internal}}{}
\krule[each-non-last]{
\kprefix{k}{\reduce{{}\terminal{\#each}({\variable[Loc]{L}})}{'Array('ListWrap('Pair('Some('Key(\constant[\#Int]{0}))\kcomma'Value(\variable[K]{K}))\kcomma'Pair('Some('Key(\constant[\#Int]{1}))\kcomma'Value({}\terminal{convertToLanguageValue}({\variable[K]{L1}})))\kcomma'Pair('Some('Key(\constant[\#String]{"key"}))\kcomma'Value(\variable[K]{K}))\kcomma'Pair('Some('Key(\constant[\#String]{"value"}))\kcomma'Value({}\terminal{convertToLanguageValue}({\variable[K]{L1}})))))}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\reduce{[{\variable[K]{K}},{\variable[K]{V}},{\variable[K]{L1}}]}{{}\terminal{none}}},{\AnyVar[List]\mathrel{}[{\variable[K]{X}},{\variable[K]{V}},{\variable[K]{L1}}]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"each-non-last"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Strlen} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#strlen}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[strlen-arg2LangValue]{
\kprefix{k}{{}\terminal{\#strlen}({\reduce{\variable[ConvertibleToLanguageValue]{L}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{L}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"strlen-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[strlen-arg2String]{
\kprefix{k}{{}\terminal{\#strlen}({\reduce{\variable[LanguageValue]{V}}{{}\terminal{*toString}({\variable[LanguageValue]{V}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"strlen-arg2String"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isStringType}({\variable[LanguageValue]{V}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[strlen]{
\kprefix{k}{\reduce{{}\terminal{\#strlen}({\variable[String]{S}})}{{}\terminal{lengthString}({\variable[String]{S}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"strlen"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Var dump} \end{kblock}
\krule[vardump-unroll-cons]{
\kprefix{k}{\reduce{'FunctionCall(\constant[\#String]{"var\_dump"}\kcomma'ListWrap(\variable[K]{Arg}\kcomma\variable[KList]{Args}))}{'Expr('FunctionCall(\constant[\#String]{"var\_dump"}\kcomma'ListWrap(\variable[K]{Arg})))\kra'FunctionCall(\constant[\#String]{"var\_dump"}\kcomma'ListWrap(\variable[KList]{Args}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"vardump-unroll"}}}
}{\left({{\variable[KList]{Args}}\terminal{=/=KList}{}}\right)}{}{\kattribute{structural}}{}
\krule[func-call-vardump]{
\kprefix{k}{\reduce{'FunctionCall(\variable[String]{FName}\kcomma'ListWrap(\variable[K]{Arg}))}{{}\terminal{\#runFunction}({\variable[String]{FName}},{\variable[K]{FunDef}},{\constant[\#Bool]{true}},{'ListWrap(\variable[K]{Arg})},{{}\terminal{none}},{{}\terminal{none}})}}
\mathrel{}\kmiddle{functions}{\variable[String]{FName}\mapsto\variable[K]{FunDef}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"func-call-vardump"}}}
}{\left({{\variable[String]{FName}}\terminal{==String}{\constant[\#String]{"var\_dump"}}}\right)}{}{\kattribute{step}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#var\_dump}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[vardump-arg2Loc]{
\kprefix{k}{{}\terminal{\#var\_dump}({\reduce{\variable[Ref]{R}}{{}\terminal{convertToLoc}({\variable[Ref]{R}},{{}\terminal{r}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"vardump-arg2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[vardump-array]{
\kprefix{k}{\reduce{{}\terminal{\#var\_dump}({\variable[Loc]{L}})}{{}\terminal{\#print}({\constant[\#String]{"array("}})\kra{}\terminal{\#print}({{}\terminal{len}({\variable[List]{Elems}})})\kra{}\terminal{\#print}({\constant[\#String]{") \{\textbackslash n"}})\kra{}\terminal{\#indentInc}\kra{}\terminal{\#dump\_content}({\variable[List]{Elems}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
}{}{}{}{}
\krule[vardump-object]{
\kprefix{k}{\reduce{{}\terminal{\#var\_dump}({\variable[Loc]{L}})}{{}\terminal{\#print}({\constant[\#String]{"object("}})\kra{}\terminal{\#print}({{}\terminal{Id2String}({\variable[K]{ClassName}})})\kra{}\terminal{\#print}({\constant[\#String]{")\#\%d"}})\kra{}\terminal{\#print}({\constant[\#String]{" ("}})\kra{}\terminal{\#print}({{}\terminal{len}({\variable[List]{Elems}})})\kra{}\terminal{\#print}({\constant[\#String]{") \{\textbackslash n"}})\kra{}\terminal{\#indentInc}\kra{}\terminal{\#dump\_content}({\variable[List]{Elems}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L1}},{\variable[K]{ClassName}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[K]{L1}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
}{}{}{}{}
\krule[vardump-string]{
\kprefix{k}{\reduce{{}\terminal{\#var\_dump}({\variable[Loc]{L}})}{{}\terminal{*Cond}({\variable[K]{IsRef}},{{}\terminal{\#print}({\constant[\#String]{"\&"}})},{\dotCt{K}})\kra{}\terminal{\#print}({\constant[\#String]{"string"}})\kra{}\terminal{\#print}({\constant[\#String]{"("}})\kra{}\terminal{\#print}({{}\terminal{\#strlen}({\variable[Loc]{L}})})\kra{}\terminal{\#print}({\constant[\#String]{") \textbackslash ""}})\kra{}\terminal{\#print}({\variable[String]{S}})\kra{}\terminal{\#print}({\constant[\#String]{"\textbackslash "\textbackslash n"}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[String]{S}},{\AnyVar[K]},{\AnyVar[K]},{\variable[K]{IsRef}})}
}{}{}{}{}
\krule[vardump-bool]{
\kprefix{k}{\reduce{{}\terminal{\#var\_dump}({\variable[Loc]{L}})}{{}\terminal{*Cond}({\variable[K]{IsRef}},{{}\terminal{\#print}({\constant[\#String]{"\&"}})},{\dotCt{K}})\kra{}\terminal{\#print}({\constant[\#String]{"bool"}})\kra{}\terminal{\#print}({\constant[\#String]{"("}})\kra{}\terminal{*Cond}({{\variable[Bool]{B}}\terminal{==Bool}{\constant[\#Bool]{true}}},{{}\terminal{\#print}({\constant[\#String]{"true"}})},{{}\terminal{\#print}({\constant[\#String]{"false"}})})\kra{}\terminal{\#print}({\constant[\#String]{")\textbackslash n"}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Bool]{B}},{\AnyVar[K]},{\AnyVar[K]},{\variable[K]{IsRef}})}
}{}{}{}{}
\krule[vardump-null]{
\kprefix{k}{\reduce{{}\terminal{\#var\_dump}({\variable[Loc]{L}})}{{}\terminal{\#print}({\constant[\#String]{"NULL\textbackslash n"}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{NULL}},{\AnyVar[K]},{\AnyVar[K]},{\variable[K]{IsRef}})}
}{}{}{}{}
\krule[vardump-other]{
\kprefix{k}{\reduce{{}\terminal{\#var\_dump}({\variable[Loc]{L}})}{{}\terminal{*Cond}({\variable[Bool]{IsRef}},{{}\terminal{\#print}({\constant[\#String]{"\&"}})},{\dotCt{K}})\kra{}\terminal{\#print}({{}\terminal{\#gettype}({\variable[Loc]{L}})})\kra{}\terminal{\#print}({\constant[\#String]{"("}})\kra{}\terminal{\#print}({\variable[Value]{V}})\kra{}\terminal{\#print}({\constant[\#String]{")\textbackslash n"}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\variable[Bool]{IsRef}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"vardump-other"}}}
}{\left({{\variable[Value]{V}}\terminal{isNumeric}}\right)}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#dump\_content}({{\nonTerminal{\sort{List}}}})}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{{\nonTerminal{\sort{Key}}}}\terminal{isStringKey}}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{\variable[String]{K}}\terminal{isStringKey}}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{\variable[Int]{K}}\terminal{isStringKey}}{\constant[\#Bool]{false}}}{}{}{}{}
\krule[dump-content-1]{
\kprefix{k}{\reduce{{}\terminal{\#dump\_content}({[{\variable[Key]{K}},{{}\terminal{none}},{\variable[Loc]{L}}]\mathrel{}\variable[List]{Elems}})}{{}\terminal{\#var\_dump\_indent}({\variable[Int]{Depth}})\kra{}\terminal{\#print}({\constant[\#String]{"["}})\kra{}\terminal{*Cond}({{\variable[Key]{K}}\terminal{isStringKey}},{{}\terminal{\#print}({\constant[\#String]{"\textbackslash ""}})},{\dotCt{K}})\kra{}\terminal{\#print}({\variable[Key]{K}})\kra{}\terminal{*Cond}({{\variable[Key]{K}}\terminal{isStringKey}},{{}\terminal{\#print}({\constant[\#String]{"\textbackslash ""}})},{\dotCt{K}})\kra{}\terminal{\#print}({\constant[\#String]{"]"}})\kra{}\terminal{\#print}({\constant[\#String]{"=>\textbackslash n"}})\kra{}\terminal{\#var\_dump\_indent}({\variable[Int]{Depth}})\kra{}\terminal{\#var\_dump}({\variable[Loc]{L}})\kra{}\terminal{\#dump\_content}({\variable[List]{Elems}})}}
\mathrel{}\kall{varDumpLevel}{\variable[Int]{Depth}}
}{}{}{}{}
\krule[dump-content-2]{
\kprefix{k}{\reduce{{}\terminal{\#dump\_content}({[{\variable[String]{K}},{{}\terminal{pro}},{\variable[Loc]{L}}]\mathrel{}\variable[List]{Elems}})}{{}\terminal{\#var\_dump\_indent}({\variable[Int]{Depth}})\kra{}\terminal{\#print}({\constant[\#String]{"[\textbackslash ""}})\kra{}\terminal{\#print}({\variable[String]{K}})\kra{}\terminal{\#print}({\constant[\#String]{"\textbackslash ":protected]"}})\kra{}\terminal{\#print}({\constant[\#String]{"=>\textbackslash n"}})\kra{}\terminal{\#var\_dump\_indent}({\variable[Int]{Depth}})\kra{}\terminal{\#var\_dump}({\variable[Loc]{L}})\kra{}\terminal{\#dump\_content}({\variable[List]{Elems}})}}
\mathrel{}\kall{varDumpLevel}{\variable[Int]{Depth}}
}{}{}{}{}
\krule[dump-content-3]{
\kprefix{k}{\reduce{{}\terminal{\#dump\_content}({[{\variable[String]{K}},{{}\terminal{pri}({\variable[Id]{ClassName}})},{\variable[Loc]{L}}]\mathrel{}\variable[List]{Elems}})}{{}\terminal{\#var\_dump\_indent}({\variable[Int]{Depth}})\kra{}\terminal{\#print}({\constant[\#String]{"[\textbackslash ""}})\kra{}\terminal{\#print}({\variable[String]{K}})\kra{}\terminal{\#print}({\constant[\#String]{"\textbackslash ":\textbackslash ""}})\kra{}\terminal{\#print}({{}\terminal{Id2String}({\variable[Id]{ClassName}})})\kra{}\terminal{\#print}({\constant[\#String]{"\textbackslash ":private]"}})\kra{}\terminal{\#print}({\constant[\#String]{"=>\textbackslash n"}})\kra{}\terminal{\#var\_dump\_indent}({\variable[Int]{Depth}})\kra{}\terminal{\#var\_dump}({\variable[Loc]{L}})\kra{}\terminal{\#dump\_content}({\variable[List]{Elems}})}}
\mathrel{}\kall{varDumpLevel}{\variable[Int]{Depth}}
}{}{}{}{}
\krule[dump-content-nil]{
\kprefix{k}{\reduce{{}\terminal{\#dump\_content}({\dotCt{List}})}{{}\terminal{\#indentDec}\kra{}\terminal{\#print}({\constant[\#String]{"\}\textbackslash n"}})}}
}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#indentInc}}{}\syntaxCont{{}\terminal{\#indentDec}}{}
\end{syntaxBlock}
\krule[indent-inc]{
\kprefix{k}{\reduce{{}\terminal{\#indentInc}}{\dotCt{K}}}
\mathrel{}\kall{varDumpLevel}{\reduce{\variable[Int]{Depth}}{{\variable[Int]{Depth}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"indent-inc"}}}
}{}{}{\kattribute{internal}}{}
\krule[indent-dec]{
\kprefix{k}{\reduce{{}\terminal{\#indentDec}}{\dotCt{K}}}
\mathrel{}\kall{varDumpLevel}{\reduce{\variable[Int]{Depth}}{{\variable[Int]{Depth}}\mathrel{-_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"indent-dec"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#var\_dump\_indent}({{\nonTerminal{\sort{Int}}}})}{}
\end{syntaxBlock}
\krule[vardump-indent-none]{
\kprefix{k}{\reduce{{}\terminal{\#var\_dump\_indent}({\constant[\#Int]{0}})}{\dotCt{K}}}
}{}{}{}{}
\krule[vardump-indent-some]{
\kprefix{k}{\reduce{{}\terminal{\#var\_dump\_indent}({\variable[Int]{N}})}{{}\terminal{\#print}({\constant[\#String]{"  "}})\kra{}\terminal{\#var\_dump\_indent}({{\variable[Int]{N}}\mathrel{-_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})}}
}{}{}{}{}
\begin{kblock}[text]
 \subsection{Define} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#define}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[define-LHS2LangValue]{
\kprefix{k}{{}\terminal{\#define}({\reduce{\variable[Ref]{R}}{{}\terminal{convertToLanguageValue}({\variable[Ref]{R}})}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"define-LHS2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[define-RHS2LangValue]{
\kprefix{k}{{}\terminal{\#define}({\AnyVar[K]},{\reduce{\variable[Ref]{R}}{{}\terminal{convertToLanguageValue}({\variable[Ref]{R}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"define-RHS2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[define-fresh]{
\kprefix{k}{\reduce{{}\terminal{\#define}({\variable[String]{ConstName}},{\variable[ScalarValue]{V}})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{constants}{\reduce{\variable[Map]{Constants}}{{\variable[Map]{Constants}}[{\variable[ScalarValue]{V}}\terminal{/}{\variable[String]{ConstName}}]}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"define-fresh"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[String]{ConstName}}\terminal{in}{{}\terminal{keys}{\left({\variable[Map]{Constants}}\right)}}}\right)}}{}{\kattribute{internal}}{}
\krule[define-already]{
\kprefix{k}{\reduce{{}\terminal{\#define}({\variable[String]{ConstName}},{\variable[ScalarValue]{V}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{constants}{\variable[Map]{Constants}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"define-already"}}}
}{\left({{\variable[String]{ConstName}}\terminal{in}{{}\terminal{keys}{\left({\variable[Map]{Constants}}\right)}}}\right)}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{PrintR} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#print\_r}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[printr-arg2Loc]{
\kprefix{k}{{}\terminal{\#print\_r}({\reduce{\variable[Ref]{R}}{{}\terminal{convertToLoc}({\variable[Ref]{R}},{{}\terminal{r}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"printr-arg2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[printr-array]{
\kprefix{k}{\reduce{{}\terminal{\#print\_r}({\variable[Loc]{L}})}{'Echo('ListWrap(\constant[\#String]{"Array\textbackslash n"}))\kra{}\terminal{\#print\_r\_indent}({{\variable[Int]{Depth}}\mathrel{\ast_{\scriptstyle\it Int}}{\constant[\#Int]{2}}})\kra'Echo('ListWrap(\constant[\#String]{"(\textbackslash n"}))\kra{}\terminal{\#indentInc}\kra{}\terminal{\#print\_r\_content}({\variable[List]{Elems}})\kra{}\terminal{\#print\_r\_indent}({{\variable[Int]{Depth}}\mathrel{\ast_{\scriptstyle\it Int}}{\constant[\#Int]{2}}})\kra'Echo('ListWrap(\constant[\#String]{")\textbackslash n"}))}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{varDumpLevel}{\variable[Int]{Depth}}
}{}{}{}{}
\krule[printr-object]{
\kprefix{k}{\reduce{{}\terminal{\#print\_r}({\variable[Loc]{L}})}{'Echo('ListWrap({}\terminal{Id2String}({\variable[K]{ClassName}})))\kra'Echo('ListWrap(\constant[\#String]{" Object\textbackslash n"}))\kra{}\terminal{\#print\_r\_indent}({{\variable[Int]{Depth}}\mathrel{\ast_{\scriptstyle\it Int}}{\constant[\#Int]{2}}})\kra'Echo('ListWrap(\constant[\#String]{"(\textbackslash n"}))\kra{}\terminal{\#indentInc}\kra{}\terminal{\#print\_r\_content}({\variable[List]{Elems}})\kra{}\terminal{\#print\_r\_indent}({{\variable[Int]{Depth}}\mathrel{\ast_{\scriptstyle\it Int}}{\constant[\#Int]{2}}})\kra'Echo('ListWrap(\constant[\#String]{")\textbackslash n"}))}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L1}},{\variable[K]{ClassName}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[K]{L1}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{varDumpLevel}{\variable[Int]{Depth}}
}{}{}{}{}
\krule[printr-string]{
\kprefix{k}{\reduce{{}\terminal{\#print\_r}({\variable[Loc]{L}})}{'Echo('ListWrap(\variable[String]{S}))\kra'Echo('ListWrap(\constant[\#String]{"\textbackslash n"}))}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[String]{S}},{\AnyVar[K]},{\AnyVar[K]},{\variable[Bool]{IsRef}})}
}{}{}{}{}
\krule[printr-other]{
\kprefix{k}{\reduce{{}\terminal{\#print\_r}({\variable[Loc]{L}})}{'Echo('ListWrap(\variable[Value]{V}))\kra'Echo('ListWrap(\constant[\#String]{"\textbackslash n"}))}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\variable[Bool]{IsRef}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"printr-other"}}}
}{{{\left({\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isArrayType}({\variable[Value]{V}})}\right)}}\right)}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isStringType}({\variable[Value]{V}})}\right)}}\right)}}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isObjectType}({\variable[Value]{V}})}\right)}}\right)}}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#print\_r\_content}({{\nonTerminal{\sort{List}}}})}{}
\end{syntaxBlock}
\krule[printr-content-1]{
\kprefix{k}{\reduce{{}\terminal{\#print\_r\_content}({[{\variable[Key]{K}},{{}\terminal{none}},{\variable[Loc]{L}}]\mathrel{}\variable[List]{Elems}})}{{}\terminal{\#var\_dump\_indent}({\left({{\left({{\variable[Int]{Depth}}\mathrel{\ast_{\scriptstyle\it Int}}{\constant[\#Int]{2}}}\right)}\mathrel{-_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)})\kra{}\terminal{\#print}({\constant[\#String]{"["}})\kra{}\terminal{*Cond}({{\variable[Key]{K}}\terminal{isStringKey}},{{}\terminal{\#print}({\constant[\#String]{"\textbackslash ""}})},{\dotCt{K}})\kra{}\terminal{\#print}({\variable[Key]{K}})\kra{}\terminal{*Cond}({{\variable[Key]{K}}\terminal{isStringKey}},{{}\terminal{\#print}({\constant[\#String]{"\textbackslash ""}})},{\dotCt{K}})\kra{}\terminal{\#print}({\constant[\#String]{"]"}})\kra{}\terminal{\#print}({\constant[\#String]{"=> "}})\kra{}\terminal{\#print\_r}({\variable[Loc]{L}})\kra{}\terminal{\#print\_r\_content}({\variable[List]{Elems}})}}
\mathrel{}\kall{varDumpLevel}{\variable[Int]{Depth}}
}{}{}{}{}
\krule[printr-content-2]{
\kprefix{k}{\reduce{{}\terminal{\#print\_r\_content}({[{\variable[String]{K}},{{}\terminal{pro}},{\variable[Loc]{L}}]\mathrel{}\variable[List]{Elems}})}{{}\terminal{\#print\_r\_indent}({\left({{\left({{\variable[Int]{Depth}}\mathrel{\ast_{\scriptstyle\it Int}}{\constant[\#Int]{2}}}\right)}\mathrel{-_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)})\kra{}\terminal{\#print}({\constant[\#String]{"[\textbackslash ""}})\kra{}\terminal{\#print}({\variable[String]{K}})\kra{}\terminal{\#print}({\constant[\#String]{"\textbackslash ":protected]"}})\kra{}\terminal{\#print}({\constant[\#String]{"=> "}})\kra{}\terminal{\#print\_r}({\variable[Loc]{L}})\kra{}\terminal{\#print\_r\_content}({\variable[List]{Elems}})}}
\mathrel{}\kall{varDumpLevel}{\variable[Int]{Depth}}
}{}{}{}{}
\krule[printr-content-3]{
\kprefix{k}{\reduce{{}\terminal{\#print\_r\_content}({[{\variable[String]{K}},{{}\terminal{pri}({\variable[Id]{ClassName}})},{\variable[Loc]{L}}]\mathrel{}\variable[List]{Elems}})}{{}\terminal{\#print\_r\_indent}({\left({{\left({{\variable[Int]{Depth}}\mathrel{\ast_{\scriptstyle\it Int}}{\constant[\#Int]{2}}}\right)}\mathrel{-_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)})\kra{}\terminal{\#print}({\constant[\#String]{"[\textbackslash ""}})\kra{}\terminal{\#print}({\variable[String]{K}})\kra{}\terminal{\#print}({\constant[\#String]{"\textbackslash ":\textbackslash ""}})\kra{}\terminal{\#print}({{}\terminal{Id2String}({\variable[Id]{ClassName}})})\kra{}\terminal{\#print}({\constant[\#String]{"\textbackslash ":private]"}})\kra{}\terminal{\#print}({\constant[\#String]{"=> "}})\kra{}\terminal{\#print\_r}({\variable[Loc]{L}})\kra{}\terminal{\#print\_r\_content}({\variable[List]{Elems}})}}
\mathrel{}\kall{varDumpLevel}{\variable[Int]{Depth}}
}{}{}{}{}
\krule[printr-content-nil]{
\kprefix{k}{\reduce{{}\terminal{\#print\_r\_content}({\dotCt{List}})}{{}\terminal{\#indentDec}}}
}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#print\_r\_indent}({{\nonTerminal{\sort{Int}}}})}{}
\end{syntaxBlock}
\krule[printr-indent-none]{
\kprefix{k}{\reduce{{}\terminal{\#print\_r\_indent}({\constant[\#Int]{0}})}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"printr-indent-none"}}}
}{}{}{\kattribute{internal}}{}
\krule[printr-indent-some]{
\kprefix{k}{\reduce{{}\terminal{\#print\_r\_indent}({\variable[Int]{N}})}{{}\terminal{\#print}({\constant[\#String]{"    "}})\kra{}\terminal{\#print\_r\_indent}({{\variable[Int]{N}}\mathrel{-_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"printr-indent-some"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#print\_r\_array}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{Int}}}})}{}
\end{syntaxBlock}
\begin{kblock}[text]
 \subsection{GetType} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#gettype}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[gettype-arg2LangValue]{
\kprefix{k}{{}\terminal{\#gettype}({\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"gettype-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[gettype-int]{
\kprefix{k}{\reduce{{}\terminal{\#gettype}({\variable[Int]{I}})}{\constant[\#String]{"int"}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"gettype-int"}}}
}{}{}{\kattribute{internal}}{}
\krule[gettype-float]{
\kprefix{k}{\reduce{{}\terminal{\#gettype}({\variable[Float]{F}})}{\constant[\#String]{"double"}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"gettype-float"}}}
}{}{}{\kattribute{internal}}{}
\krule[gettype-string]{
\kprefix{k}{\reduce{{}\terminal{\#gettype}({\variable[String]{S}})}{\constant[\#String]{"string"}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"gettype-string"}}}
}{}{}{\kattribute{internal}}{}
\krule[gettype-bol]{
\kprefix{k}{\reduce{{}\terminal{\#gettype}({\variable[Bool]{B}})}{\constant[\#String]{"boolean"}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"gettype-bol"}}}
}{}{}{\kattribute{internal}}{}
\krule[gettype-array]{
\kprefix{k}{\reduce{{}\terminal{\#gettype}({\variable[Array]{A}})}{\constant[\#String]{"array"}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"gettype-array"}}}
}{}{}{\kattribute{internal}}{}
\krule[gettype-obj]{
\kprefix{k}{\reduce{{}\terminal{\#gettype}({\variable[Object]{O}})}{\constant[\#String]{"object"}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"gettype-obj"}}}
}{}{}{\kattribute{internal}}{}
\krule[gettype-null]{
\kprefix{k}{\reduce{{}\terminal{\#gettype}({{}\terminal{NULL}})}{\constant[\#String]{"NULL"}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"gettype-null"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Defined} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#defined}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[defined-arg2LangValue]{
\kprefix{k}{{}\terminal{\#defined}({\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"defined-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[defined-true]{
\kprefix{k}{\reduce{{}\terminal{\#defined}({\variable[String]{Const}})}{\constant[\#Bool]{true}}}
\mathrel{}\kmiddle{constants}{\variable[String]{Const}\mapsto\AnyVar[K]}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"defined-true"}}}
}{}{}{\kattribute{internal}}{}
\krule[defined-false]{
\kprefix{k}{\reduce{{}\terminal{\#defined}({\variable[String]{Const}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{constants}{\variable[Map]{Consts}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"defined-false"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[String]{Const}}\terminal{in}{{}\terminal{keys}{\left({\variable[Map]{Consts}}\right)}}}\right)}}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{IsFloat} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#is\_float}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[is-float]{
\kprefix{k}{\reduce{{}\terminal{\#is\_float}({\variable[K]{V}})}{{}\terminal{is\_type}({\variable[K]{V}},{\constant[\#String]{"float"}})}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{IsString} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#is\_string}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[is-float]{
\kprefix{k}{\reduce{{}\terminal{\#is\_string}({\variable[K]{V}})}{{}\terminal{is\_type}({\variable[K]{V}},{\constant[\#String]{"string"}})}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{IsArray} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#is\_array}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[is-array]{
\kprefix{k}{\reduce{{}\terminal{\#is\_array}({\variable[K]{V}})}{{}\terminal{is\_type}({\variable[K]{V}},{\constant[\#String]{"array"}})}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{IsScalar} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#is\_scalar}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[is-scalar]{
\kprefix{k}{\reduce{{}\terminal{\#is\_scalar}({\variable[K]{V}})}{{}\terminal{is\_type}({\variable[K]{V}},{\constant[\#String]{"scalar"}})}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{IsNumeric} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#is\_numeric}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[is-numeric]{
\kprefix{k}{\reduce{{}\terminal{\#is\_numeric}({\variable[K]{V}})}{{}\terminal{is\_type}({\variable[K]{V}},{\constant[\#String]{"numeric"}})}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Is type} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{is\_type}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{String}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[is-type-arg2LangValue]{
\kprefix{k}{{}\terminal{is\_type}({\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}},{\AnyVar[K]})}
}{}{}{\kattribute{intermediate}}{}
\krule[is-type-float]{
\kprefix{k}{\reduce{{}\terminal{is\_type}({\variable[LanguageValue]{V}},{\constant[\#String]{"float"}})}{{}\terminal{\#isFloatType}({\variable[LanguageValue]{V}})}}
}{}{}{\kattribute{internal}}{}
\krule[is-type-string]{
\kprefix{k}{\reduce{{}\terminal{is\_type}({\variable[LanguageValue]{V}},{\constant[\#String]{"string"}})}{{}\terminal{\#isStringType}({\variable[LanguageValue]{V}})}}
}{}{}{\kattribute{internal}}{}
\krule[is-type-array]{
\kprefix{k}{\reduce{{}\terminal{is\_type}({\variable[LanguageValue]{V}},{\constant[\#String]{"array"}})}{{}\terminal{\#isArrayType}({\variable[LanguageValue]{V}})}}
}{}{}{\kattribute{internal}}{}
\krule[is-type-scalar]{
\kprefix{k}{\reduce{{}\terminal{is\_type}({\variable[LanguageValue]{V}},{\constant[\#String]{"scalar"}})}{{\variable[LanguageValue]{V}}\terminal{isScalar}}}
}{}{}{\kattribute{internal}}{}
\krule[is-type-numeric-numericString2Number]{
\kprefix{k}{\reduce{{}\terminal{is\_type}({\variable[String]{S}},{\constant[\#String]{"numeric"}})}{{}\terminal{isNumericString}({\variable[String]{S}})}}
}{}{}{\kattribute{internal}}{}
\krule[is-type-numeric]{
\kprefix{k}{\reduce{{}\terminal{is\_type}({\variable[LanguageValue]{V}},{\constant[\#String]{"numeric"}})}{{\variable[LanguageValue]{V}}\terminal{isNumeric}}}
}{\neg_{\scriptstyle\it Bool}{{}\terminal{\#isStringType}({\variable[LanguageValue]{V}})}}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#user\_input}}{}
\end{syntaxBlock}
\krule{
\kprefix{k}{\reduce{{}\terminal{\#user\_input}}{\variable[K]{V}}}
\mathrel{}\kprefix{in}{\reduce{\variable[K]{V}}{\dotCt{List}}}
}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#label}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule{
{}\terminal{\#label}({\reduce{\variable[ConvertibleToLanguageValue]{S}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{S}})}})}{}{}{}{}
\krule{
\kprefix{k}{\reduce{{}\terminal{\#label}({\variable[String]{S}})}{{}\terminal{NULL}}}
\mathrel{}\kall{label}{\reduce{\AnyVar[K]}{\variable[String]{S}}}
}{}{}{}{}
\begin{kblock}[text]
 \subsection{substr} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#substr}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{\kattribute{seqstrict}}
\end{syntaxBlock}
\krule[substr-arg2LangValue-1]{
\kprefix{k}{{}\terminal{\#substr}({\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}},{\AnyVar[K]},{\AnyVar[K]})}
}{}{}{\kattribute{internal}}{}
\krule[substr-arg2LangValue-2]{
\kprefix{k}{{}\terminal{\#substr}({\AnyVar[K]},{\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}},{\AnyVar[K]})}
}{}{}{\kattribute{internal}}{}
\krule[substr-arg2LangValue-3]{
\kprefix{k}{{}\terminal{\#substr}({\AnyVar[K]},{\AnyVar[K]},{\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}})}
}{}{}{\kattribute{internal}}{}
\krule[substr]{
\kprefix{k}{\reduce{{}\terminal{\#substr}({\variable[String]{S}},{\variable[Int]{Start}},{\variable[Int]{Len}})}{{}\terminal{substrString}({\variable[String]{S}},{\variable[Int]{Start}},{\variable[Int]{Len}})}}
}{}{}{\kattribute{internal}}{}
\end{module}
\begin{module}{\moduleName{CORE}}
\begin{kblock}[text]
 \section{Core} \end{kblock}
\begin{kblock}[text]
 \subsection{Documents} 
		PHP scripts are parsed as Document. Documents comes in different flavours, depending
		on if the closing tag if present, if some additional HTML is present etc. \end{kblock}
\begin{kblock}[text]
 In all cases, and at least for now (we may want to be more precise later) we extract the PHP
	script from the Document and schedule it for execution. 
	Before executing the script we perform a pre-processing refactoring operation which consists 
	in moving all function and class declaration to the top of the program (i.e. before any 
	statement). This models the fact that PHP allows function call and class instantiation before 
	function or class declaration. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#runScript}({{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{\#runScript}({\variable[K]{Prog}})}{{}\terminal{\#refactor}({\variable[K]{Prog}})\kra{}\terminal{\#detectDeprecated}\kra{}\terminal{\#initStatic}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#detectDeprecated}}{}
\end{syntaxBlock}
\krule{
\reduce{\left({{}\terminal{\#quotedCode}({\variable[K]{Prog}})\kra{}\terminal{\#detectDeprecated}}\right)}{{}\terminal{detectDeprecated}({\variable[K]{Prog}})}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#initStatic}}{}
\end{syntaxBlock}
\krule{
\kprefix{k}{\reduce{\left({\framebox{${\variable[K]{Prog}}$}\kra{}\terminal{\#initStatic}}\right)}{{}\terminal{\#makeStaticDecls}({\variable[K]{Prog}},{\variable[Loc]{L}})\kra{}\terminal{\#start}}}
\mathrel{}\kall{globalStaticScope}{\variable[Loc]{L}}
\mathrel{}\kall{function}{\reduce{\AnyVar[K]}{\dotCt{K}}}
}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#start}}{}
\end{syntaxBlock}
\krule{
\reduce{\framebox{${\variable[KList]{Prog}}$}\kra{}\terminal{\#start}}{\variable[KList]{Prog}}}{}{}{}{}
\krule[document-1]{
\kprefix{k}{\reduce{'Document(\AnyVar[K]\kcomma\AnyVar[K]\kcomma\variable[K]{Prog})}{{}\terminal{\#runScript}({\variable[K]{Prog}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"document-1"}}}
}{}{}{\kattribute{structural}}{}
\krule[document-2]{
\kprefix{k}{\reduce{'Document(\AnyVar[K]\kcomma\AnyVar[K]\kcomma\variable[K]{Prog}\kcomma\AnyVar[K]\kcomma'ListWrap())}{{}\terminal{\#runScript}({\variable[K]{Prog}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"document-2"}}}
}{}{}{\kattribute{structural}}{}
\krule[document-3]{
\kprefix{k}{\reduce{'Document(\variable[K]{PreHTML}\kcomma\AnyVar[K]\kcomma\variable[K]{Prog}\kcomma\AnyVar[K]\kcomma\variable[K]{PostHTML})}{'Echo(\variable[K]{PreHTML})\kra{}\terminal{\#runScript}({\variable[K]{Prog}})\kra'Echo(\variable[K]{PostHTML})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"document-3"}}}
}{}{}{\kattribute{structural}}{}
\krule[inline-html]{
\kprefix{k}{\reduce{'InlineHTML('CloseTag(\AnyVar[KList])\kcomma\variable[K]{Stuff}\kcomma'FullOpenTag(\AnyVar[KList]))}{'Echo(\variable[K]{Stuff})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"inline-html"}}}
}{}{}{\kattribute{structural}}{}
\krule[template-document-empty]{
\kprefix{k}{\reduce{'TemplateDocument('ListWrap())}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"template-document-empty"}}}
}{}{}{\kattribute{structural}}{}
\krule[template-document-literal]{
\kprefix{k}{\reduce{'TemplateDocument('ListWrap('Literal(\variable[String]{L})\kcomma\variable[KList]{Stuff}))}{'Echo('ListWrap(\variable[String]{L}))\kra'TemplateDocument('ListWrap(\variable[KList]{Stuff}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"template-document-literal"}}}
}{}{}{\kattribute{structural}}{}
\krule[template-document-echo]{
\kprefix{k}{\reduce{'TemplateDocument('ListWrap(\variable[K]{K}\kcomma\variable[KList]{Stuff}))}{\variable[K]{K}\kra'TemplateDocument('ListWrap(\variable[KList]{Stuff}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"template-document-echo"}}}
}{{{}\terminal{getKLabel}{\left({\variable[K]{K}}\right)}}\mathrel{=_{\it KLabel}}{'InlineEcho}}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Literals} 
		Literals returned from the parser are transformed into K friendly structures. \end{kblock}
\krule[literal-int]{
\kprefix{k}{\reduce{'LNumber('Deci(\variable[String]{Str}))}{{}\terminal{String2Int}({\variable[String]{Str}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"literal-int"}}}
}{}{}{\kattribute{structural}}{}
\krule[literal-float]{
\kprefix{k}{\reduce{'DNumber(\variable[String]{Str})}{{}\terminal{String2Float}({\variable[String]{Str}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"literal-float"}}}
}{}{}{\kattribute{structural}}{}
\krule[literal-deci]{
\kprefix{k}{\reduce{'Deci(\variable[Value]{V})}{\variable[Value]{V}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"literal-deci"}}}
}{}{}{\kattribute{structural}}{}
\krule[literal-string]{
\kprefix{k}{\reduce{'Literal(\variable[String]{Str})}{\variable[String]{Str}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"literal-string"}}}
}{}{}{\kattribute{structural}}{}
\krule[literal-true]{
\kprefix{k}{\reduce{'True(\AnyVar[KList])}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"literal-true"}}}
}{}{}{\kattribute{structural}}{}
\krule[literal-false]{
\kprefix{k}{\reduce{'False(\AnyVar[KList])}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"literal-false"}}}
}{}{}{\kattribute{structural}}{}
\krule[literal-null]{
\kprefix{k}{\reduce{'Null(\AnyVar[KList])}{{}\terminal{NULL}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"literal-null"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Blocks} 
		Blocks are evaluated by simply executing the statement (i.e. we simply discard
		parenthesis). \end{kblock}
\krule[block]{
\kprefix{k}{\reduce{'Block(\variable[K]{B})}{\variable[K]{B}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"block"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Sequential composition} 
		Sequential composition is defined in standard K style. \end{kblock}
\krule[seq-cons]{
\kprefix{k}{\reduce{'ListWrap(\variable[K]{S}\kcomma\variable[KList]{Ss})}{\variable[K]{S}\kra'ListWrap(\variable[KList]{Ss})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"seq-cons"}}}
}{}{}{\kattribute{structural}}{}
\krule[seq-empty]{
\kprefix{k}{\reduce{'ListWrap()}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"seq-empty"}}}
}{}{}{\kattribute{structural}}{}
\krule[empty]{
\kprefix{k}{\reduce{'Empty()}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"empty"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Expression as a statement} 
		The expression statement is evaluated by first evaluating the expression (which may 
		have side effects) and then, once the expression has been reduced to a value, 
		dissolving the statement. \end{kblock}
\kcontext{
'Expr(\khole{})}{}{}{}
\krule[expr]{
\kprefix{k}{\reduce{'Expr(\variable[Value]{V})}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"expr"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \subsection{Variable lookup} 
		Variable lookup returns a reference, i.e. a pair consisting of a location (the location 
		of the appropriate symbol table) and the name ov the variable itself. 
		Depending on the type of variable, different symbol tables may be considered: if 
		the variable is a user-defined one, the location of the current environment is returned. 
		If the variable is a superglobal, the location of the superglobal envirnoment is 
		returned.c \end{kblock}
\begin{kblock}[text]
 We then simplify things by transforming the output of the parser into something more 
	simple, i.e. an identifier. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Var}}}\syntax{{}\terminal{var}({{\nonTerminal{\sort{Id}}}})}{}
\end{syntaxBlock}
\krule[var2Id]{
\kprefix{k}{\reduce{'Variable('Simple(\variable[String]{Str}))}{{}\terminal{var}({{}\terminal{String2Id}({\variable[String]{Str}})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"var2Id"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 The following is the rule for variable lookup. Note that is makes use of the auxiliary
	predicates defined below. \end{kblock}
\krule[var]{
\kprefix{k}{\reduce{{}\terminal{var}({\variable[Id]{X}})}{{}\terminal{*Cond}({{}\terminal{\#isSuperGlobal}({\variable[Id]{X}})},{{}\terminal{ref}({\variable[Loc]{Lsg}},{{}\terminal{Id2String}({\variable[Id]{X}})})},{{}\terminal{ref}({\variable[Loc]{Lg}},{{}\terminal{Id2String}({\variable[Id]{X}})})})}}
\mathrel{}\kall{currentScope}{\variable[Loc]{Lg}}
\mathrel{}\kall{superGlobalScope}{\variable[Loc]{Lsg}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isSpecialVar}({\variable[Id]{X}})}\right)}}{}{\kattribute{step}}{}
\begin{kblock}[text]
 The following auxiliary predicate returns true if the variable is a superglobal, 
	false otherwise  \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{\#isSuperGlobal}({{\nonTerminal{\sort{Id}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule[isSuperglobal-true]{
\reduce{{}\terminal{\#isSuperGlobal}({\variable[Id]{X}})}{\constant[\#Bool]{true}}}{{{\left({{{}\terminal{Id2String}({\variable[Id]{X}})}\terminal{==String}{\constant[\#String]{"\_GET"}}}\right)}\vee_{\scriptstyle\it Bool}{\left({{{}\terminal{Id2String}({\variable[Id]{X}})}\terminal{==String}{\constant[\#String]{"\_POST"}}}\right)}}\vee_{\scriptstyle\it Bool}{\left({{{}\terminal{Id2String}({\variable[Id]{X}})}\terminal{==String}{\constant[\#String]{"GLOBALS"}}}\right)}}{}{}{}
\krule[isSuperglobal-false]{
\reduce{{}\terminal{\#isSuperGlobal}({\variable[Id]{X}})}{\constant[\#Bool]{false}}}{{{\left({{{}\terminal{Id2String}({\variable[Id]{X}})}\terminal{=/=String}{\constant[\#String]{"\_GET"}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{{}\terminal{Id2String}({\variable[Id]{X}})}\terminal{=/=String}{\constant[\#String]{"\_POST"}}}\right)}}\wedge_{\scriptstyle\it Bool}{\left({{{}\terminal{Id2String}({\variable[Id]{X}})}\terminal{=/=String}{\constant[\#String]{"GLOBALS"}}}\right)}}{}{}{}
\begin{kblock}[text]
 The following auxiliary predicate returns true if the variable is special (e.g. this), 
	false otherwise  \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{\#isSpecialVar}({{\nonTerminal{\sort{Id}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule[is-special-var-true]{
\reduce{{}\terminal{\#isSpecialVar}({\variable[Id]{X}})}{\constant[\#Bool]{true}}}{\left({{{}\terminal{Id2String}({\variable[Id]{X}})}\terminal{==String}{\constant[\#String]{"this"}}}\right)}{}{}{}
\krule[is-special-var-false]{
\reduce{{}\terminal{\#isSpecialVar}({\variable[Id]{X}})}{\constant[\#Bool]{false}}}{\neg_{\scriptstyle\it Bool}{\left({{{}\terminal{Id2String}({\variable[Id]{X}})}\terminal{==String}{\constant[\#String]{"this"}}}\right)}}{}{}{}
\begin{kblock}[text]
 \subsection{Variable variables} \end{kblock}
\kcontext{
'IndirectReference(\khole{})}{}{}{}
\krule[variable-variable-arg2Value]{
\kprefix{k}{'IndirectReference(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})})}
}{}{}{\kattribute{intermediate}}{}
\krule[variable-variable]{
\kprefix{k}{\reduce{'IndirectReference(\variable[String]{X})}{'Variable('Simple(\variable[String]{X}))}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \subsection{Array access} \end{kblock}
\kcontext{
'Some(\khole{})}{}{}{}
\krule{
\reduce{'Some(\variable[Value]{V})}{\variable[Value]{V}}}{}{}{}{}
\kcontext{
'ArrayAccess(\khole{}\kcomma\AnyVar[KList])}{}{}{\kattribute{structural}}
\kcontext{
'ArrayAccess(\AnyVar[KList]\kcomma\khole{})}{}{}{\kattribute{structural}}
\krule[array-access-LHS2LangValue]{
\kprefix{k}{'ArrayAccess(\AnyVar[KList]\kcomma\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-access-LHS2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[array-access-key-cast-float]{
\kprefix{k}{'ArrayAccess(\AnyVar[KList]\kcomma\reduce{\variable[Float]{F}}{'IntCast(\variable[Float]{F})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-access-key-cast-float"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[array-access-key-cast-bool]{
\kprefix{k}{'ArrayAccess(\AnyVar[KList]\kcomma\reduce{\variable[Bool]{B}}{'IntCast(\variable[Bool]{B})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-access-key-cast-bool"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[array-access-key-cast-string]{
\kprefix{k}{'ArrayAccess(\AnyVar[KList]\kcomma\reduce{\variable[String]{S}}{'IntCast(\variable[String]{S})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-access-key-cast-string"}}}
}{{}\terminal{\#isIntType}({{}\terminal{String2Int}({\variable[String]{S}})})}{}{\kattribute{intermediate}}{}
\krule[array-access-no-key]{
\kprefix{k}{'ArrayAccess(\AnyVar[KList]\kcomma\reduce{'None()}{{}\terminal{NULL}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-access-no-key"}}}
}{}{}{\kattribute{step}}{}
\krule[array-access-simple]{
\kprefix{k}{\reduce{'ArrayAccess(\variable[Loc]{L}\kcomma\variable[Key]{X})}{{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-access-simple"}}}
}{}{}{\kattribute{step}}{}
\krule[array-access-nested]{
\kprefix{k}{\reduce{'ArrayAccess(\variable[Ref]{R}\kcomma\variable[Key]{K})}{{}\terminal{lref}({\variable[Ref]{R}},{\variable[Key]{K}},{{}\terminal{arr}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-access-nested"}}}
}{}{}{\kattribute{step}}{}
\krule[array-access-parsing-error]{
\kprefix{k}{\reduce{'ArrayAccess(\variable[String]{S}\kcomma\AnyVar[KList])\kra\variable[K]{K}}{{}\terminal{\#print}({\constant[\#String]{"PARSING BUG!!!"}})}}
\mathrel{}\kall{errorManagement}{\reduce{\AnyVar[K]}{\constant[\#Int]{4}}}
}{}{}{}{}
\begin{kblock}[text]
 \subsection{Assignment by value} \end{kblock}
\kcontext{
'Assign(\khole{}\kcomma\AnyVar[KList])}{}{}{\kattribute{structural}}
\kcontext{
'Assign(\AnyVar[KResult]\kcomma\khole{})}{}{}{\kattribute{structural}}
\krule[assign-LHS2Loc]{
'Assign(\reduce{\variable[Ref]{R}}{{}\terminal{convertToLoc}({\variable[Ref]{R}},{{}\terminal{l}})}\kcomma\AnyVar[KResult])}{}{}{\kattribute{intermediate}}{}
\krule[assign-RHS2Loc-NonLiteral]{
'Assign(\AnyVar[KResult]\kcomma\reduce{\variable[ConvertibleToLoc]{V}}{{}\terminal{convertToLoc}({\variable[ConvertibleToLoc]{V}},{{}\terminal{r}})})}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{isLiteral}({\variable[ConvertibleToLoc]{V}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[assign-RHS2LangValue]{
\kprefix{k}{\reduce{'Assign(\variable[Loc]{L}\kcomma\variable[Loc]{L1})}{{}\terminal{*Cond}({{}\terminal{\#isArrayType}({\variable[K]{V}})},{'Expr({}\terminal{\#reset}({\variable[Loc]{L1}}))},{\dotCt{K}})\kra'Assign(\variable[Loc]{L}\kcomma{}\terminal{convertToLanguageValue}({\variable[Loc]{L1}}))}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({\variable[K]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
}{}{}{\kattribute{intermediate}}{}
\krule[assign-RHS2LangValue-locNull]{
'Assign(\variable[Loc]{L}\kcomma\reduce{{}\terminal{locNull}}{{}\terminal{NULL}})}{}{}{\kattribute{intermediate}}{}
\krule[assign]{
\reduce{'Assign(\variable[Loc]{L}\kcomma\variable[LanguageValue]{V})}{{}\terminal{copyValueToLoc}({\variable[LanguageValue]{V}},{\variable[Loc]{L}})\kra\variable[LanguageValue]{V}}}{}{}{\kattribute{step}}{}
\krule[assign-error]{
\reduce{'Assign({}\terminal{thisTag}({\variable[K]{L}})\kcomma\AnyVar[KList])}{{}\terminal{ERROR}({\constant[\#String]{"Cannot re-assign \$this in \%s on line \%d"}})}}{}{}{\kattribute{step}, \kattribute{error}}{}
\begin{kblock}[text]
 \subsection{Assignment by reference} \end{kblock}
\kcontext{
'ReferenceAssign(\khole{}\kcomma\AnyVar[KList])}{}{}{\kattribute{structural}}
\kcontext{
'ReferenceAssign(\AnyVar[KResult]\kcomma\khole{})}{}{}{\kattribute{structural}}
\krule[ref-assign-LHS2BasicRef]{
\kprefix{k}{'ReferenceAssign(\reduce{\variable[LRef]{LR}}{{}\terminal{toBasicRef}({\variable[LRef]{LR}})}\kcomma\variable[Value]{V})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"ref-assign-LHS2BasicRef"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[ref-assign-RHS2Loc]{
\kprefix{k}{'ReferenceAssign(\AnyVar[KList]\kcomma\reduce{\variable[ConvertibleToLoc]{V}}{{}\terminal{convertToLoc}({\variable[ConvertibleToLoc]{V}},{{}\terminal{l}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"ref-assign-RHS2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[ref-assign-fresh-obj-prop]{
\kprefix{k}{'ReferenceAssign({}\terminal{ref}({\reduce{\variable[Loc]{L}}{\variable[K]{L2}}},{\variable[Key]{X}})\kcomma\variable[Loc]{L1})}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L2}},{\AnyVar[K]},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L1}\mapsto\AnyVar[K]\mathrel{}\variable[K]{L2}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"ref-assign-fresh-obj-prop"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[List]{Elems}}\terminal{hasProperty}{\variable[Key]{X}}}\right)}}{}{\kattribute{intermediate}}{}
\krule[ref-assign-fresh-array-elem]{
\kprefix{k}{\reduce{'ReferenceAssign({}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})\kcomma\variable[Loc]{L1})}{{}\terminal{ArrayUpdateElem}({\variable[Loc]{L}},{\variable[Key]{X}},{\variable[Loc]{L1}})\kra{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L1}\mapsto\AnyVar[K]}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"ref-assign-fresh-array-elem"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[List]{Elems}}\terminal{hasProperty}{\variable[Key]{X}}}\right)}}{}{\kattribute{step}}{}
\krule[ref-assign-existent-array-elem]{
\kprefix{k}{\reduce{'ReferenceAssign({}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})\kcomma\variable[Loc]{L1})}{'Unset({}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}}))\kra{}\terminal{ArrayUpdateElem}({\variable[Loc]{L}},{\variable[Key]{X}},{\variable[Loc]{L1}})\kra{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\AnyVar[List]\mathrel{}[{\variable[Key]{X}},{\AnyVar[K]},{\variable[K]{L2}}]\mathrel{}\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L1}\mapsto\AnyVar[K]}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"ref-assign-existent-array-elem"}}}
}{{\variable[Loc]{L1}}\mathrel{\neq_K}{\variable[K]{L2}}}{}{\kattribute{step}}{}
\krule[ref-assign-existent-array-elem-same]{
\kprefix{k}{\reduce{'ReferenceAssign({}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})\kcomma\variable[Loc]{L1})}{{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\AnyVar[List]\mathrel{}[{\variable[Key]{X}},{\AnyVar[K]},{\variable[Loc]{L1}}]\mathrel{}\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L1}\mapsto\AnyVar[K]}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"ref-assign-existent-array-elem-same"}}}
}{}{}{\kattribute{step}}{}
\krule[ref-assign-language-value]{
\kprefix{k}{\reduce{'ReferenceAssign({}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})\kcomma\variable[PlainLanguageValue]{V})}{{}\terminal{WARNING}({\constant[\#String]{"Only variables should be assigned by reference in \%s on line \%d\textbackslash n"}})\kra'Assign({}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})\kcomma\variable[PlainLanguageValue]{V})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"ref-assign-language-value"}}}
}{}{}{\kattribute{step}, \kattribute{error}}{}
\begin{kblock}[text]
 \subsection{List Assignment} \end{kblock}
\kcontext{
'ListAssign(\khole{}\kcomma\AnyVar[K])}{}{}{\kattribute{structural}}
\kcontext{
'ListAssign(\AnyVar[KResult]\kcomma\khole{})}{}{}{\kattribute{structural}}
\kcontext{
'List('ListWrap(\AnyVar[KList]\kcomma'Some(\khole{})\kcomma\AnyVar[KList]))}{}{}{\kattribute{structural}}
\krule{
\reduce{isKResult('List('ListWrap(\variable[KList]{X})))}{\constant[\#Bool]{true}}}{isKResult(\variable[KList]{X})}{}{}{}
\krule{
\reduce{isKResult('Some(\variable[K]{X}))}{\constant[\#Bool]{true}}}{isKResult(\variable[K]{X})}{}{}{}
\krule{
\reduce{isKResult('None(\AnyVar[KList]))}{\constant[\#Bool]{true}}}{}{}{}{}
\krule[list-assign-RHS2Loc]{
\kprefix{k}{'ListAssign(\AnyVar[KResult]\kcomma\reduce{\variable[ConvertibleToLoc]{R}}{{}\terminal{convertToLoc}({\variable[ConvertibleToLoc]{R}},{{}\terminal{r}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"list-assign-RHS2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[list-assign]{
\kprefix{k}{\reduce{'ListAssign('List(\variable[K]{Vars})\kcomma\variable[Loc]{L})}{{}\terminal{assignSeqOfIds}({\variable[K]{Vars}},{\variable[Loc]{L}},{\constant[\#Int]{0}})\kra\variable[Loc]{L}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"list-assign"}}}
}{}{}{\kattribute{step}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{assignSeqOfIds}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{Int}}}})}{}
\end{syntaxBlock}
\krule[assign-seq-some-non-list]{
\kprefix{k}{\reduce{{}\terminal{assignSeqOfIds}({'ListWrap('Some(\variable[KResult]{X})\kcomma\variable[KList]{Xs})},{\variable[Loc]{L}},{\variable[Int]{I}})}{{}\terminal{assignSeqOfIds}({'ListWrap(\variable[KList]{Xs})},{\variable[Loc]{L}},{{\variable[Int]{I}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})\kra'Expr('Assign(\variable[KResult]{X}\kcomma'ArrayAccess(\variable[Loc]{L}\kcomma\variable[Int]{I})))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"assign-seq-some-non-list"}}}
}{{{}\terminal{getKLabel}{\left({\variable[KResult]{X}}\right)}}\mathrel{\neq_{\it KLabel}}{'List}}{}{\kattribute{internal}}{}
\krule[assign-seq-some-list]{
\kprefix{k}{\reduce{{}\terminal{assignSeqOfIds}({'ListWrap('Some('List('ListWrap(\variable[KList]{X})))\kcomma\variable[KList]{Xs})},{\variable[Loc]{L}},{\variable[Int]{I}})}{{}\terminal{assignSeqOfIds}({'ListWrap(\variable[KList]{Xs})},{\variable[Loc]{L}},{{\variable[Int]{I}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})\kra'Expr('ListAssign('List('ListWrap(\variable[KList]{X}))\kcomma'ArrayAccess(\variable[Loc]{L}\kcomma\variable[Int]{I})))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"assign-seq-some-list"}}}
}{isKResult(\variable[KList]{X})}{}{\kattribute{internal}}{}
\krule[assign-seq-skip]{
\kprefix{k}{\reduce{{}\terminal{assignSeqOfIds}({'ListWrap('None(\AnyVar[KList])\kcomma\variable[KList]{Xs})},{\variable[Loc]{L}},{\variable[Int]{I}})}{{}\terminal{assignSeqOfIds}({'ListWrap(\variable[KList]{Xs})},{\variable[Loc]{L}},{{\variable[Int]{I}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"assign-seq-skip"}}}
}{}{}{\kattribute{internal}}{}
\krule[assign-seq-nil]{
\kprefix{k}{\reduce{{}\terminal{assignSeqOfIds}({'ListWrap()},{\variable[Loc]{L}},{\AnyVar[K]})}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"assign-seq-nil"}}}
}{}{}{\kattribute{internal}}{}
\krule[assign-seq-not-a-loc]{
\kprefix{k}{\reduce{'ListAssign(\AnyVar[KResult]\kcomma\variable[LanguageValue]{V})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"assign-seq-not-a-loc"}}}
}{}{}{\kattribute{internal}, \kattribute{error}}{}
\begin{kblock}[text]
 \subsection{IsSet} \end{kblock}
\kcontext{
'InternalFunction('Isset('ListWrap(\AnyVar[KList]\kcomma\khole{}\kcomma\AnyVar[KList])))}{}{}{\kattribute{structural}}
\krule[internal-fun-isset-2-spec]{
\kprefix{k}{\reduce{'InternalFunction('Isset('ListWrap(\variable[KResult]{Arg})))}{{}\terminal{\#isset}({\variable[KResult]{Arg}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"internal-fun-isset-2-spec"}}}
}{}{}{\kattribute{structural}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#isset}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[isset-arg2BasicRef]{
\kprefix{k}{{}\terminal{\#isset}({\reduce{\variable[LRef]{LR}}{{}\terminal{toBasicRef}({\variable[LRef]{LR}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isset-arg2BasicRef"}}}
}{}{}{\kattribute{internal}, \kattribute{intermediate}}{}
\krule[isset-true]{
\kprefix{k}{\reduce{{}\terminal{\#isset}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{K}})})}{\constant[\#Bool]{true}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\AnyVar[List]\mathrel{}[{\variable[Key]{K}},{{}\terminal{none}},{\AnyVar[K]}]\mathrel{}\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isset-true"}}}
}{}{}{\kattribute{internal}}{}
\krule[isset-false]{
\kprefix{k}{\reduce{{}\terminal{\#isset}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{K}})})}{\constant[\#Bool]{false}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isset-false"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[List]{Elems}}\terminal{hasProperty}{\variable[Key]{K}}}\right)}}{}{\kattribute{internal}}{}
\krule[isset-null]{
\kprefix{k}{\reduce{{}\terminal{\#isset}({{}\terminal{ref}({{}\terminal{locNull}},{\AnyVar[K]})})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isset-null"}}}
}{}{}{\kattribute{internal}}{}
\krule[isset-scalar]{
\kprefix{k}{\reduce{{}\terminal{\#isset}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{K}})})}{\constant[\#Bool]{false}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isset-scalar"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[Value]{V}}\terminal{isCompoundValue}}\right)}}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Unset} \end{kblock}
\krule[unset-cons]{
\kprefix{k}{\reduce{'Unset('ListWrap(\variable[K]{Item}\kcomma\variable[KList]{T}))}{'Unset(\variable[K]{Item})\kra'Unset('ListWrap(\variable[KList]{T}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"unset-cons"}}}
}{}{}{\kattribute{internal}}{}
\krule[unset-nil]{
\kprefix{k}{\reduce{'Unset('ListWrap())}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"unset-nil"}}}
}{}{}{\kattribute{step}}{}
\kcontext{
'Unset(\khole{})}{{{}\terminal{getKLabel}{\left({\khole{}}\right)}}\mathrel{\neq_{\it KLabel}}{'ListWrap}}{}{\kattribute{structural}}
\krule[unset-arg2BasicRef]{
\kprefix{k}{'Unset(\reduce{\variable[LRef]{LR}}{{}\terminal{toBasicRef}({\variable[LRef]{LR}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"unset-arg2BasicRef"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[unset-obj-prop]{
\kprefix{k}{'Unset({}\terminal{ref}({\reduce{\variable[K]{L}}{\variable[K]{L1}}},{\variable[K]{X}}))}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L1}},{\AnyVar[K]},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"unset-obj-prop"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[unset-null-ref]{
\kprefix{k}{\reduce{'Unset({}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}}))}{\dotCt{K}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"unset-null-ref"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[List]{Elems}}\terminal{hasProperty}{\variable[Key]{X}}}\right)}}{}{\kattribute{step}}{}
\krule[unset-non-current]{
\kprefix{k}{\reduce{'Unset({}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}}))}{{}\terminal{decRefCount}({\variable[K]{L1}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({[{\variable[K]{Y}},{\variable[K]{Vis1}},{\AnyVar[K]}]},{\AnyVar[List]\mathrel{}\reduce{[{\variable[Key]{X}},{\variable[K]{Vis}},{\variable[K]{L1}}]}{\dotCt{List}}\mathrel{}\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[K]{L1}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"unset-non-current"}}}
}{{\left({{\variable[K]{Y}}\mathrel{\neq_K}{\variable[Key]{X}}}\right)}\vee_{\scriptstyle\it Bool}{\left({{\variable[K]{Vis}}\mathrel{\neq_K}{\variable[K]{Vis1}}}\right)}}{}{\kattribute{step}}{}
\krule[unset-current-none]{
\kprefix{k}{\reduce{'Unset({}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}}))}{{}\terminal{decRefCount}({\variable[K]{L1}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({{}\terminal{none}},{\AnyVar[List]\mathrel{}\reduce{[{\variable[Key]{X}},{\variable[K]{Vis}},{\variable[K]{L1}}]}{\dotCt{List}}\mathrel{}\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[K]{L1}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"unset-current-none"}}}
}{}{}{\kattribute{step}}{}
\krule[unset-current-not-last]{
\kprefix{k}{\reduce{'Unset({}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}}))}{{}\terminal{decRefCount}({\variable[K]{L1}})\kra{}\terminal{\#setFlagIfInLoop}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\reduce{[{\variable[Key]{X}},{\variable[K]{Visib}},{\variable[K]{L1}}]}{\variable[K]{Next}}},{\AnyVar[List]\mathrel{}\left({\reduce{[{\variable[Key]{X}},{\variable[K]{Visib}},{\variable[K]{L1}}]}{\dotCt{List}}\mathrel{}\variable[K]{Next}}\right)\mathrel{}\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[K]{L1}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"unset-current-not-last"}}}
}{}{}{\kattribute{step}}{}
\krule[unset-current-last]{
\kprefix{k}{\reduce{'Unset({}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}}))}{{}\terminal{decRefCount}({\variable[K]{L1}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\reduce{[{\variable[Key]{X}},{\variable[K]{Visib}},{\variable[K]{L1}}]}{{}\terminal{none}}},{\variable[List]{E}\mathrel{}\reduce{[{\variable[Key]{X}},{\variable[K]{Visib}},{\variable[K]{L1}}]}{\dotCt{List}}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[K]{L1}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"unset-current-last"}}}
}{}{}{\kattribute{step}}{}
\krule[unset-refNull]{
\kprefix{k}{\reduce{'Unset({}\terminal{ref}({{}\terminal{locNull}},{\variable[K]{X}}))}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"unset-refNull"}}}
}{}{}{\kattribute{step}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#setFlagIfInLoop}}{}\syntaxCont{{}\terminal{\#crntItemUnset}}{}
\end{syntaxBlock}
\krule[set-flag-if-loop-loop]{
\kprefix{k}{\reduce{{}\terminal{\#setFlagIfInLoop}}{\dotCt{K}}}
\mathrel{}\ksuffix{loopStack}{{}\terminal{\#loopFrame}({\variable[K]{K}},{\reduce{\AnyVar[K]}{\constant[\#Bool]{true}}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"set-flag-if-loop-loop"}}}
}{}{}{\kattribute{internal}}{}
\krule[set-flag-if-loop-no-loop]{
\kprefix{k}{\reduce{{}\terminal{\#setFlagIfInLoop}}{\dotCt{K}}}
\mathrel{}\kall{loopStack}{\dotCt{List}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"set-flag-if-loop-no-loop"}}}
}{}{}{\kattribute{internal}}{}
\end{module}
\begin{module}{\moduleName{TYPE-CONVERSIONS}}
\begin{kblock}[text]
 \section{Type Conversions} \end{kblock}
\begin{kblock}[text]
 \subsection{Surface syntax for type conversione} \end{kblock}
\kcontext{
'IntCast(\khole{})}{}{}{}
\krule[int-cast-arg2LangValue]{
\kprefix{k}{'IntCast(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"int-cast-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[int-cast]{
\kprefix{k}{\reduce{'IntCast(\variable[LanguageValue]{V})}{{}\terminal{*toInteger}({\variable[LanguageValue]{V}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"int-cast"}}}
}{}{}{\kattribute{step}}{}
\kcontext{
'StringCast(\khole{})}{}{}{}
\krule[string-cast-arg2LangValue]{
\kprefix{k}{'StringCast(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"string-cast-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[string-cast]{
\kprefix{k}{\reduce{'StringCast(\variable[LanguageValue]{V})}{{}\terminal{*toString}({\variable[LanguageValue]{V}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"string-cast"}}}
}{}{}{\kattribute{step}}{}
\kcontext{
'BoolCast(\khole{})}{}{}{}
\krule[bool-cast-arg2LangValue]{
\kprefix{k}{'BoolCast(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"bool-cast-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[bool-cast]{
\kprefix{k}{\reduce{'BoolCast(\variable[LanguageValue]{V})}{{}\terminal{*toBoolean}({\variable[LanguageValue]{V}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"bool-cast"}}}
}{}{}{\kattribute{step}}{}
\kcontext{
'FloatCast(\khole{})}{}{}{}
\krule[float-cast-arg2LangValue]{
\kprefix{k}{'FloatCast(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"float-cast-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[float-cast]{
\kprefix{k}{\reduce{'FloatCast(\variable[LanguageValue]{V})}{{}\terminal{*toFloat}({\variable[LanguageValue]{V}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"float-cast"}}}
}{}{}{\kattribute{step}}{}
\kcontext{
'ObjectCast(\khole{})}{}{}{}
\krule[object-cast-arg2LangValue]{
\kprefix{k}{'ObjectCast(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"object-cast-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[object-cast]{
\kprefix{k}{\reduce{'ObjectCast(\variable[LanguageValue]{V})}{{}\terminal{*toObject}({\variable[LanguageValue]{V}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"object-cast"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \subsection{Internal type conversion rules} \end{kblock}
\begin{kblock}[text]
 \subsection{To Boolean} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{*toBoolean}({{\nonTerminal{\sort{LanguageValue}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[toBoolean-bool]{
\kprefix{k}{\reduce{{}\terminal{*toBoolean}({\variable[Bool]{B}})}{\variable[Bool]{B}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toBoolean-bool"}}}
}{}{}{\kattribute{internal}}{}
\krule[toBoolean-int-zero]{
\kprefix{k}{\reduce{{}\terminal{*toBoolean}({\constant[\#Int]{0}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toBoolean-int-zero"}}}
}{}{}{\kattribute{internal}}{}
\krule[toBoolean-int]{
\kprefix{k}{\reduce{{}\terminal{*toBoolean}({\variable[Int]{N}})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toBoolean-int"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[Int]{N}}\mathrel{{=}{=}_{\scriptstyle\it Int}}{\constant[\#Int]{0}}}\right)}}{}{\kattribute{internal}}{}
\krule[toBoolean-float-zero]{
\kprefix{k}{\reduce{{}\terminal{*toBoolean}({\variable[Float]{F}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toBoolean-float-zero"}}}
}{\left({{\variable[Float]{F}}\mathrel{==_{\scriptstyle\it Float}}{\constant[\#Float]{0.0}}}\right)}{}{\kattribute{internal}}{}
\krule[toBoolean-float]{
\kprefix{k}{\reduce{{}\terminal{*toBoolean}({\variable[Float]{F}})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toBoolean-float"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[Float]{F}}\mathrel{==_{\scriptstyle\it Float}}{\constant[\#Float]{0.0}}}\right)}}{}{\kattribute{internal}}{}
\krule[toBoolean-empty-string]{
\kprefix{k}{\reduce{{}\terminal{*toBoolean}({\constant[\#String]{""}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toBoolean-empty-string"}}}
}{}{}{\kattribute{internal}}{}
\krule[toBoolean-string-zero]{
\kprefix{k}{\reduce{{}\terminal{*toBoolean}({\constant[\#String]{"0"}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toBoolean-string-zero"}}}
}{}{}{\kattribute{internal}}{}
\krule[toBoolean-string]{
\kprefix{k}{\reduce{{}\terminal{*toBoolean}({\variable[String]{S}})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toBoolean-string"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\left({{\variable[String]{S}}\terminal{==String}{\constant[\#String]{""}}}\right)}\vee_{\scriptstyle\it Bool}{\left({{\variable[String]{S}}\terminal{==String}{\constant[\#String]{"0"}}}\right)}}\right)}}{}{\kattribute{internal}}{}
\krule[toBoolean-empty-array]{
\kprefix{k}{\reduce{{}\terminal{*toBoolean}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toBoolean-empty-array"}}}
}{\left({{\variable[List]{Elems}}\terminal{==List}{\dotCt{List}}}\right)}{}{\kattribute{internal}}{}
\krule[toBoolean-non-empty-array]{
\kprefix{k}{\reduce{{}\terminal{*toBoolean}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toBoolean-non-empty-array"}}}
}{\left({\neg_{\scriptstyle\it Bool}{\left({{\variable[List]{Elems}}\terminal{==List}{\dotCt{List}}}\right)}}\right)}{}{\kattribute{internal}}{}
\krule[toBoolean-null]{
\kprefix{k}{\reduce{{}\terminal{*toBoolean}({{}\terminal{NULL}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toBoolean-null"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{To Float} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{*toFloat}({{\nonTerminal{\sort{LanguageValue}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[toFloat-false]{
\kprefix{k}{\reduce{{}\terminal{*toFloat}({\constant[\#Bool]{false}})}{'DNumber(\constant[\#String]{"0.0"})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toFloat-false"}}}
}{}{}{\kattribute{internal}}{}
\krule[toFloat-true]{
\kprefix{k}{\reduce{{}\terminal{*toFloat}({\constant[\#Bool]{true}})}{'DNumber(\constant[\#String]{"1.0"})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toFloat-true"}}}
}{}{}{\kattribute{internal}}{}
\krule[toFloat-int]{
\kprefix{k}{\reduce{{}\terminal{*toFloat}({\variable[Int]{I}})}{{\\it{}Int2Float}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toFloat-int"}}}
}{}{}{\kattribute{internal}}{}
\krule[toFloat-float]{
\kprefix{k}{\reduce{{}\terminal{*toFloat}({\variable[Float]{F}})}{\variable[Float]{F}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toFloat-float"}}}
}{}{}{\kattribute{internal}}{}
\krule[toFloat-string]{
\kprefix{k}{\reduce{{}\terminal{*toFloat}({\variable[String]{S}})}{{}\terminal{*toFloat}({{}\terminal{\#string2Number}({\variable[String]{S}})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toFloat-string"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{To Integer} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{*toInteger}({{\nonTerminal{\sort{LanguageValue}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[toInteger-false]{
\kprefix{k}{\reduce{{}\terminal{*toInteger}({\constant[\#Bool]{false}})}{\constant[\#Int]{0}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toInteger-false"}}}
}{}{}{\kattribute{internal}}{}
\krule[toInteger-true]{
\kprefix{k}{\reduce{{}\terminal{*toInteger}({\constant[\#Bool]{true}})}{\constant[\#Int]{1}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toInteger-true"}}}
}{}{}{\kattribute{internal}}{}
\krule[toInteger-int]{
\kprefix{k}{\reduce{{}\terminal{*toInteger}({\variable[Int]{I}})}{\variable[Int]{I}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toInteger-int"}}}
}{}{}{\kattribute{internal}}{}
\krule[toInteger-float]{
\kprefix{k}{\reduce{{}\terminal{*toInteger}({\variable[Float]{F}})}{{\\it{}Float2Int}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toInteger-float"}}}
}{}{}{\kattribute{internal}}{}
\krule[toInteger-string]{
\kprefix{k}{\reduce{{}\terminal{*toInteger}({\variable[String]{S}})}{{}\terminal{*toInteger}({{}\terminal{\#string2Number}({\variable[String]{S}})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toInteger-string"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Is numeric string} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{isNumericString}({{\nonTerminal{\sort{String}}}})}{\kattribute{function}}\syntaxCont{{}\terminal{isIntString}({{\nonTerminal{\sort{String}}}})}{\kattribute{function}}\syntaxCont{{}\terminal{isFloatString}({{\nonTerminal{\sort{String}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{isNumericString}({\constant[\#String]{""}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{isNumericString}({\variable[String]{S}})}{\constant[\#Bool]{false}}}{{\left({{{{}\terminal{lengthString}({\variable[String]{S}})}\mathrel{{=}{=}_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\vee_{\scriptstyle\it Bool}{{{}\terminal{lengthString}({\variable[String]{S}})}\mathrel{{=}{=}_{\scriptstyle\it Int}}{\constant[\#Int]{2}}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})})}}\right)}}{}{}{}
\krule{
\reduce{{}\terminal{isNumericString}({\variable[String]{S}})}{\constant[\#Bool]{true}}}{{\left({{{}\terminal{lengthString}({\variable[String]{S}})}\mathrel{{=}{=}_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})})}\right)}}{}{}{}
\krule{
\reduce{{}\terminal{isNumericString}({\variable[String]{S}})}{\constant[\#Bool]{false}}}{\neg_{\scriptstyle\it Bool}{\left({{{\left({{\left({{{}\terminal{lengthString}({\variable[String]{S}})}\mathrel{>_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)}\wedge_{\scriptstyle\it Bool}{{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})})}}\right)}\vee_{\scriptstyle\it Bool}{\left({{\left({{{{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})}\terminal{==String}{\constant[\#String]{"-"}}}\vee_{\scriptstyle\it Bool}{{{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})}\terminal{==String}{\constant[\#String]{"."}}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{1}},{\constant[\#Int]{2}})})}\right)}}\right)}}\vee_{\scriptstyle\it Bool}{\left({{\left({{{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{2}})}\terminal{==String}{\constant[\#String]{"-."}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{2}},{\constant[\#Int]{3}})})}\right)}}\right)}}\right)}}{}{}{}
\krule{
\reduce{{}\terminal{isNumericString}({\variable[String]{S}})}{\constant[\#Bool]{true}}}{{\left({{\left({{{}\terminal{lengthString}({\variable[String]{S}})}\mathrel{>_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)}\wedge_{\scriptstyle\it Bool}{{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})})}}\right)}\vee_{\scriptstyle\it Bool}{\left({{\left({{{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})}\terminal{==String}{\constant[\#String]{"-"}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{1}},{\constant[\#Int]{2}})})}\right)}}\right)}}{}{}{}
\krule{
\reduce{{}\terminal{isNumericString}({\variable[String]{S}})}{\constant[\#Bool]{true}}}{{\left({{\left({{{}\terminal{lengthString}({\variable[String]{S}})}\mathrel{>_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)}\wedge_{\scriptstyle\it Bool}{{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})})}}\right)}\vee_{\scriptstyle\it Bool}{\left({{\left({{{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})}\terminal{==String}{\constant[\#String]{"."}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{1}},{\constant[\#Int]{2}})})}\right)}}\right)}}{}{}{}
\krule{
\reduce{{}\terminal{isNumericString}({\variable[String]{S}})}{\constant[\#Bool]{true}}}{{\left({{\left({{{}\terminal{lengthString}({\variable[String]{S}})}\mathrel{>_{\scriptstyle\it Int}}{\constant[\#Int]{2}}}\right)}\wedge_{\scriptstyle\it Bool}{{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})})}}\right)}\vee_{\scriptstyle\it Bool}{\left({{\left({{{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{2}})}\terminal{==String}{\constant[\#String]{"-."}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{2}},{\constant[\#Int]{3}})})}\right)}}\right)}}{}{}{}
\begin{kblock}[text]
 \subsection{String 2 number} 
		Converts a string to a number.
		TODO: the side conditions are the same as above (isNumericString). 
		      We should factorize those 2 things. And maybe split isNumericString so that
		      'isNumericString => isIntString \/ isFloatString'. After that, we should 
		      do something like: 
		      'string2number(S) => extractIntSubstring(_,_float) when isFloatString(S)
		       string2number(S) => extractIntSubstring(_,_int) when isIntString(S)
		       string2number(S) => 0 when (notBool isNumericString(S)) \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#string2Number}({{\nonTerminal{\sort{String}}}})}{}
\end{syntaxBlock}
\krule[string2Number-empty]{
\kprefix{k}{\reduce{{}\terminal{\#string2Number}({\constant[\#String]{""}})}{\constant[\#Int]{0}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"string2Number-empty"}}}
}{}{}{\kattribute{internal}}{}
\krule[string2Number-char-non-digit]{
\kprefix{k}{\reduce{{}\terminal{\#string2Number}({\variable[String]{S}})}{\constant[\#Int]{0}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"string2Number-char-non-digit"}}}
}{{\left({{{{}\terminal{lengthString}({\variable[String]{S}})}\mathrel{{=}{=}_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\vee_{\scriptstyle\it Bool}{{{}\terminal{lengthString}({\variable[String]{S}})}\mathrel{{=}{=}_{\scriptstyle\it Int}}{\constant[\#Int]{2}}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})})}}\right)}}{}{\kattribute{internal}}{}
\krule[string2Number-char-digit]{
\kprefix{k}{\reduce{{}\terminal{\#string2Number}({\variable[String]{S}})}{{}\terminal{String2Int}({\variable[String]{S}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"string2Number-char-digit"}}}
}{{\left({{{}\terminal{lengthString}({\variable[String]{S}})}\mathrel{{=}{=}_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})})}\right)}}{}{\kattribute{internal}}{}
\krule[string2Number-non-numeric]{
\kprefix{k}{\reduce{{}\terminal{\#string2Number}({\variable[String]{S}})}{\constant[\#Int]{0}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"string2Number-non-numeric"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{{\left({{\left({{{}\terminal{lengthString}({\variable[String]{S}})}\mathrel{>_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)}\wedge_{\scriptstyle\it Bool}{{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})})}}\right)}\vee_{\scriptstyle\it Bool}{\left({{\left({{{{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})}\terminal{==String}{\constant[\#String]{"-"}}}\vee_{\scriptstyle\it Bool}{{{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})}\terminal{==String}{\constant[\#String]{"."}}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{1}},{\constant[\#Int]{2}})})}\right)}}\right)}}\vee_{\scriptstyle\it Bool}{\left({{\left({{{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{2}})}\terminal{==String}{\constant[\#String]{"-."}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{2}},{\constant[\#Int]{3}})})}\right)}}\right)}}\right)}}{}{\kattribute{internal}}{}
\krule[string2Number-int]{
\kprefix{k}{\reduce{{}\terminal{\#string2Number}({\variable[String]{S}})}{{}\terminal{\#extractIntSubstring}({\variable[String]{S}},{{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})},{\constant[\#Int]{1}},{{}\terminal{int}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"string2Number-int"}}}
}{{\left({{\left({{{}\terminal{lengthString}({\variable[String]{S}})}\mathrel{>_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)}\wedge_{\scriptstyle\it Bool}{{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})})}}\right)}\vee_{\scriptstyle\it Bool}{\left({{\left({{{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})}\terminal{==String}{\constant[\#String]{"-"}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{1}},{\constant[\#Int]{2}})})}\right)}}\right)}}{}{\kattribute{internal}}{}
\krule[string2Number-float-dot]{
\kprefix{k}{\reduce{{}\terminal{\#string2Number}({\variable[String]{S}})}{{}\terminal{\#extractIntSubstring}({\variable[String]{S}},{{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})},{\constant[\#Int]{1}},{{}\terminal{float}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"string2Number-float-dot"}}}
}{{\left({{\left({{{}\terminal{lengthString}({\variable[String]{S}})}\mathrel{>_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)}\wedge_{\scriptstyle\it Bool}{{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})})}}\right)}\vee_{\scriptstyle\it Bool}{\left({{\left({{{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})}\terminal{==String}{\constant[\#String]{"."}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{1}},{\constant[\#Int]{2}})})}\right)}}\right)}}{}{\kattribute{internal}}{}
\krule[string2Number-float-minus-dot]{
\kprefix{k}{\reduce{{}\terminal{\#string2Number}({\variable[String]{S}})}{{}\terminal{\#extractIntSubstring}({\variable[String]{S}},{{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{2}})},{\constant[\#Int]{2}},{{}\terminal{float}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"string2Number-float-minus-dot"}}}
}{{\left({{\left({{{}\terminal{lengthString}({\variable[String]{S}})}\mathrel{>_{\scriptstyle\it Int}}{\constant[\#Int]{2}}}\right)}\wedge_{\scriptstyle\it Bool}{{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{1}})})}}\right)}\vee_{\scriptstyle\it Bool}{\left({{\left({{{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{0}},{\constant[\#Int]{2}})}\terminal{==String}{\constant[\#String]{"-."}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{S}},{\constant[\#Int]{2}},{\constant[\#Int]{3}})})}\right)}}\right)}}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#extractIntSubstring}({{\nonTerminal{\sort{String}}}},{{\nonTerminal{\sort{String}}}},{{\nonTerminal{\sort{Int}}}},{{\nonTerminal{\sort{Type}}}})}{}
\end{syntaxBlock}
\krule[extract-int-substring-1]{
\reduce{{}\terminal{\#extractIntSubstring}({\variable[String]{Origin}},{\variable[String]{{\nu}mber}},{\variable[Int]{Index}},{\variable[Type]{T}})}{{}\terminal{\#extractIntSubstring}({\variable[String]{Origin}},{{\variable[String]{{\nu}mber}}+_{\scriptstyle\it String}{{}\terminal{substrString}({\variable[String]{Origin}},{\variable[Int]{Index}},{{\variable[Int]{Index}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})}},{{\variable[Int]{Index}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}},{\variable[Type]{T}})}}{{{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{Origin}},{\variable[Int]{Index}},{{\variable[Int]{Index}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})})}\wedge_{\scriptstyle\it Bool}{\left({{\variable[Int]{Index}}\mathrel{<_{\scriptstyle\it Int}}{{}\terminal{lengthString}({\variable[String]{Origin}})}}\right)}}{}{\kattribute{internal}}{}
\krule[extract-int-substring-2]{
\reduce{{}\terminal{\#extractIntSubstring}({\variable[String]{Origin}},{\variable[String]{{\nu}mber}},{\variable[Int]{Index}},{{}\terminal{int}})}{{}\terminal{\#extractIntSubstring}({\variable[String]{Origin}},{{\variable[String]{{\nu}mber}}+_{\scriptstyle\it String}{{}\terminal{substrString}({\variable[String]{Origin}},{\variable[Int]{Index}},{{\variable[Int]{Index}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})}},{{\variable[Int]{Index}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}},{{}\terminal{float}})}}{{{\left({{{}\terminal{substrString}({\variable[String]{Origin}},{\variable[Int]{Index}},{{\variable[Int]{Index}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})}\terminal{==String}{\constant[\#String]{"."}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{Origin}},{{\variable[Int]{Index}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}},{{\variable[Int]{Index}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{2}}})})}\right)}}\wedge_{\scriptstyle\it Bool}{\left({{\left({{\variable[Int]{Index}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)}\mathrel{<_{\scriptstyle\it Int}}{{}\terminal{lengthString}({\variable[String]{Origin}})}}\right)}}{}{\kattribute{internal}}{}
\krule[extract-int-substring-3]{
\reduce{{}\terminal{\#extractIntSubstring}({\variable[String]{Origin}},{\variable[String]{{\nu}mber}},{\variable[Int]{Index}},{{}\terminal{float}})}{{}\terminal{String2Float}({\variable[String]{{\nu}mber}})}}{\neg_{\scriptstyle\it Bool}{\left({{{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{Origin}},{\variable[Int]{Index}},{{\variable[Int]{Index}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})})}\wedge_{\scriptstyle\it Bool}{\left({{\variable[Int]{Index}}\mathrel{<_{\scriptstyle\it Int}}{{}\terminal{lengthString}({\variable[String]{Origin}})}}\right)}}\right)}}{}{\kattribute{internal}}{}
\krule[extract-int-substring-4]{
\reduce{{}\terminal{\#extractIntSubstring}({\variable[String]{Origin}},{\variable[String]{{\nu}mber}},{\variable[Int]{Index}},{{}\terminal{int}})}{{}\terminal{String2Int}({\variable[String]{{\nu}mber}})}}{\neg_{\scriptstyle\it Bool}{\left({{{{}\terminal{\#isDigit}({{}\terminal{substrString}({\variable[String]{Origin}},{\variable[Int]{Index}},{{\variable[Int]{Index}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})})}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{\left({{{}\terminal{substrString}({\variable[String]{Origin}},{\variable[Int]{Index}},{{\variable[Int]{Index}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})}\terminal{==String}{\constant[\#String]{"."}}}\right)}}\right)}}\wedge_{\scriptstyle\it Bool}{\left({{\variable[Int]{Index}}\mathrel{<_{\scriptstyle\it Int}}{{}\terminal{lengthString}({\variable[String]{Origin}})}}\right)}}\right)}}{}{\kattribute{internal}}{}
\krule[extract-int-substring-5]{
\reduce{{}\terminal{\#extractIntSubstring}({\variable[String]{Origin}},{\variable[String]{{\nu}mber}},{\variable[Int]{Index}},{{}\terminal{int}})}{{}\terminal{String2Int}({\variable[String]{{\nu}mber}})}}{{\variable[Int]{Index}}\mathrel{{=}{=}_{\scriptstyle\it Int}}{{}\terminal{lengthString}({\variable[String]{Origin}})}}{}{\kattribute{internal}}{}
\krule[extract-int-substring-6]{
\reduce{{}\terminal{\#extractIntSubstring}({\variable[String]{Origin}},{\variable[String]{{\nu}mber}},{\variable[Int]{Index}},{{}\terminal{float}})}{{}\terminal{String2Float}({\variable[String]{{\nu}mber}})}}{{\variable[Int]{Index}}\mathrel{{=}{=}_{\scriptstyle\it Int}}{{}\terminal{lengthString}({\variable[String]{Origin}})}}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 to string \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{*toString}({{\nonTerminal{\sort{LanguageValue}}}})}{}
\end{syntaxBlock}
\krule[toString-true]{
\kprefix{k}{\reduce{{}\terminal{*toString}({\constant[\#Bool]{true}})}{\constant[\#String]{"1"}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toString-true"}}}
}{}{}{\kattribute{internal}}{}
\krule[toString-false]{
\kprefix{k}{\reduce{{}\terminal{*toString}({\constant[\#Bool]{false}})}{\constant[\#String]{""}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toString-false"}}}
}{}{}{\kattribute{internal}}{}
\krule[toString-int]{
\kprefix{k}{\reduce{{}\terminal{*toString}({\variable[Int]{I}})}{{}\terminal{Int2String}({\variable[Int]{I}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toString-int"}}}
}{}{}{\kattribute{internal}}{}
\krule[toString-float]{
\kprefix{k}{\reduce{{}\terminal{*toString}({\variable[Float]{F}})}{{}\terminal{Float2String}({\variable[Float]{F}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toString-float"}}}
}{}{}{\kattribute{internal}}{}
\krule[toString-string]{
\kprefix{k}{\reduce{{}\terminal{*toString}({\variable[String]{S}})}{\variable[String]{S}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toString-string"}}}
}{}{}{\kattribute{internal}}{}
\krule[toString-array]{
\kprefix{k}{\reduce{{}\terminal{*toString}({\variable[Array]{Arr}})}{\constant[\#String]{"Array"}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toString-array"}}}
}{}{}{\kattribute{internal}}{}
\krule[toString-null]{
\kprefix{k}{\reduce{{}\terminal{*toString}({{}\terminal{NULL}})}{\constant[\#String]{""}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"toString-null"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 to Object \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{*toObject}({{\nonTerminal{\sort{LanguageValue}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\end{module}
\begin{module}{\moduleName{IO}}
\begin{kblock}[text]
 \section{Input and Output} \end{kblock}
\begin{kblock}[text]
 \subsection{Exit, Die} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Exit}}{}\syntaxCont{{}\terminal{'Die}}{}
\end{syntaxBlock}
\krule[die-desugar]{
\kprefix{k}{\reduce{'Die}{'Exit}(\AnyVar[KList])}
}{}{}{\kattribute{structural}}{}
\kcontext{
'Exit(\khole{})}{}{}{}
\krule[exit-arg2LangValue]{
\kprefix{k}{'Exit(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})})}
}{}{}{\kattribute{intermediate}}{}
\krule[exit]{
\kall{k}{\reduce{'Exit(\variable[LanguageValue]{V})\kra\AnyVar[K]}{\dotCt{K}}}
\mathrel{}\kall{exitStatus}{\reduce{\AnyVar[K]}{\variable[LanguageValue]{V}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \subsection{Auxiliary stuff} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#print}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[internal-print]{
\kprefix{k}{\reduce{{}\terminal{\#print}({\variable[ScalarValue]{V}})}{\dotCt{K}}}
\mathrel{}\ksuffix{out}{\reduce{\dotCt{List}}{\variable[ScalarValue]{V}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"internal-print"}}}
}{}{}{\kattribute{internal}, \kattribute{output}}{}
\begin{kblock}[text]
 \subsection{Echo} \end{kblock}
\kcontext{
'Echo('ListWrap(\AnyVar[KList]\kcomma\khole{}\kcomma\AnyVar[KList]))}{}{}{\kattribute{structural}}
\krule[echo-args2LangValue]{
\kprefix{k}{'Echo('ListWrap(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}\kcomma\AnyVar[KList]))}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"echo-args2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[echo-cons]{
\kprefix{k}{\reduce{'Echo('ListWrap(\variable[LanguageValue]{V}\kcomma\variable[KList]{Args}))}{{}\terminal{\#print}({{}\terminal{*toString}({\variable[LanguageValue]{V}})})\kra'Echo('ListWrap(\variable[KList]{Args}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"echo-cons"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[echo-nil]{
\reduce{'Echo('ListWrap())}{\dotCt{K}}}{}{}{\kattribute{step}}{}
\krule[echo-boh]{
\reduce{'Echo(\variable[K]{Args}\kcomma\constant[\#String]{""})}{'Echo(\variable[K]{Args})}}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Inline Echo} \end{kblock}
\krule[inline-echo]{
\kprefix{k}{\reduce{'InlineEcho('EchoOpenTag()\kcomma\variable[K]{K}\kcomma\AnyVar[KList]\kcomma'CloseTag())}{'Echo('ListWrap(\variable[K]{K}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"inline-echo"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Print} 
		Same as 'Echo, but also returns a nice "1". \end{kblock}
\krule[print]{
\kprefix{k}{\reduce{'Print(\variable[K]{Item})}{'Echo('ListWrap(\variable[K]{Item}))\kra\constant[\#Int]{1}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"print"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Exit} 
		Abruptly terminates the program. If a string is given as argument it prints it. 
		It an integer error code is given, this is sent to the exitStatus cell. 
		TODO: if no arg is provided what should happen in PHP? 
		TODO: this is synonym of "Die". \end{kblock}
\end{module}
\begin{module}{\moduleName{ERRORS}}
\begin{kblock}[text]
 \section{Error management} 
		We define here some basic error management operations.
		For the future we plan to add support for more detailed error messages, i.e. 
		line number, etc. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{WARNING}({{\nonTerminal{\sort{String}}}})}{}
\end{syntaxBlock}
\krule[warning]{
\kprefix{k}{\reduce{{}\terminal{WARNING}({\variable[String]{Msg}})}{{}\terminal{\#print}({\constant[\#String]{"\textbackslash nWarning: "}})\kra{}\terminal{\#print}({\variable[String]{Msg}})}}
\mathrel{}\kall{errorManagement}{\reduce{\AnyVar[K]}{\constant[\#Int]{1}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"warning"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{DEPRECATED}({{\nonTerminal{\sort{String}}}})}{}
\end{syntaxBlock}
\krule[warning]{
\kprefix{k}{\reduce{{}\terminal{DEPRECATED}({\variable[String]{Msg}})}{{}\terminal{\#print}({\constant[\#String]{"\textbackslash nDeprecated: "}})\kra{}\terminal{\#print}({\variable[String]{Msg}})}}
\mathrel{}\kall{errorManagement}{\reduce{\AnyVar[K]}{\constant[\#Int]{1}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"deprecated"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{NOTICE}({{\nonTerminal{\sort{String}}}})}{}
\end{syntaxBlock}
\krule[notice]{
\kprefix{k}{\reduce{{}\terminal{NOTICE}({\variable[String]{Msg}})}{{}\terminal{\#print}({\constant[\#String]{"\textbackslash nNotice: "}})\kra{}\terminal{\#print}({\variable[String]{Msg}})}}
\mathrel{}\kall{errorManagement}{\reduce{\AnyVar[K]}{\constant[\#Int]{1}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"notice"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{ERROR}({{\nonTerminal{\sort{String}}}})}{}
\end{syntaxBlock}
\krule[error]{
\kall{k}{\reduce{{}\terminal{ERROR}({\variable[String]{ErrorMsg}})\kra\variable[K]{K}}{{}\terminal{\#print}({\constant[\#String]{"\textbackslash nFatal error: "}})\kra{}\terminal{\#print}({\variable[String]{ErrorMsg}})}}
\mathrel{}\kall{errorManagement}{\reduce{\AnyVar[K]}{\constant[\#Int]{2}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"error"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{NOT-SUPPORTED}({{\nonTerminal{\sort{String}}}})}{}
\end{syntaxBlock}
\krule[not-supported]{
\kall{k}{\reduce{{}\terminal{NOT-SUPPORTED}({\variable[String]{ErrorMsg}})\kra\variable[K]{K}}{{}\terminal{\#print}({\constant[\#String]{"Unsupported feature: "}})\kra{}\terminal{\#print}({\variable[String]{ErrorMsg}})}}
\mathrel{}\kall{errorManagement}{\reduce{\AnyVar[K]}{\constant[\#Int]{3}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"not-supported"}}}
}{}{}{\kattribute{internal}}{}
\end{module}
\begin{module}{\moduleName{FUNCTIONS}}
\begin{kblock}[text]
 \section{Functions} 
		In this section we give rules for language constructs related to functions: function
		declaration, call and return. Such rules will make use of other internal operations
		which are defined in the next section and used by other language features (e.g. 
		method call). \end{kblock}
\begin{kblock}[text]
 \subsection{Internal Representation} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{FunReturnType}}}\syntax{{}\terminal{@byValue}}{}\syntaxCont{{}\terminal{@byRef}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{FunDef}}}\syntax{{}\terminal{f}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{FunReturnType}}}},{{\nonTerminal{\sort{Loc}}}})}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{StackFrame}}}\syntax{{}\terminal{sf}({{\nonTerminal{\sort{String}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\begin{kblock}[text]
 \subsection{Function Declaration} \end{kblock}
\begin{kblock}[text]
 When a function declaration is found, first an empty location is found and a symbol 
    table is created there (this will contain the function's static variables). 
    Then, the information already present in the AST node is passed to the auxiliary 
    operation MAKEFUNCTION. this operation will process the function body 
    (since static declarations need to be computed at compile time) and store
    the function in memory.  \end{kblock}
\krule[function-decl-ret-value]{
\kprefix{k}{\reduce{'FunctionDecl(\variable[String]{Name}\kcomma'ListWrap(\variable[KList]{Parameters})\kcomma\variable[K]{Body})}{{}\terminal{ArrayCreateEmpty}({\variable[Loc]{L}})\kra{}\terminal{incRefCount}({\variable[Loc]{L}})\kra{}\terminal{\#makeFunction}({\variable[String]{Name}},{'ListWrap(\variable[KList]{Parameters})},{{}\terminal{\#makeStaticDecls}({\variable[K]{Body}},{\variable[Loc]{L}})},{{}\terminal{@byValue}},{\variable[Loc]{L}})}}
\mathrel{}\kall{functions}{\variable[Map]{{\rho}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"function-decl-ret-value"}}}
}{{\neg_{\scriptstyle\it Bool}{\left({{\variable[String]{Name}}\terminal{in}{{}\terminal{keys}{\left({\variable[Map]{{\rho}}}\right)}}}\right)}}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{fresh}({\variable[Loc]{L}})}\right)}}{}{\kattribute{step}}{}
\krule[function-decl-ret-ref]{
\kprefix{k}{\reduce{'FunctionDeclRef(\variable[String]{Name}\kcomma'ListWrap(\variable[KList]{Parameters})\kcomma\variable[K]{Body})}{{}\terminal{ArrayCreateEmpty}({\variable[Loc]{L}})\kra{}\terminal{incRefCount}({\variable[Loc]{L}})\kra{}\terminal{\#makeFunction}({\variable[String]{Name}},{'ListWrap(\variable[KList]{Parameters})},{{}\terminal{\#makeStaticDecls}({\variable[K]{Body}},{\variable[Loc]{L}})},{{}\terminal{@byRef}},{\variable[Loc]{L}})}}
\mathrel{}\kall{functions}{\variable[Map]{{\rho}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"function-decl-ret-ref"}}}
}{{\neg_{\scriptstyle\it Bool}{\left({{\variable[String]{Name}}\terminal{in}{{}\terminal{keys}{\left({\variable[Map]{{\rho}}}\right)}}}\right)}}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{fresh}({\variable[Loc]{L}})}\right)}}{}{\kattribute{step}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#makeFunction}({{\nonTerminal{\sort{String}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{Loc}}}})}{\kattribute{strict}(3)}
\end{syntaxBlock}
\krule[make-function]{
\kprefix{k}{\reduce{{}\terminal{\#makeFunction}({\variable[K]{Name}},{'ListWrap(\variable[KList]{Parameters})},{\framebox{${\variable[K]{Body}}$}},{\variable[K]{ValueOrRef}},{\variable[Loc]{L}})}{\dotCt{K}}}
\mathrel{}\kall{functions}{\reduce{\variable[Map]{{\rho}}}{{\variable[Map]{{\rho}}}[{{}\terminal{f}({'ListWrap(\variable[KList]{Parameters})},{\variable[K]{Body}},{\variable[K]{ValueOrRef}},{\variable[Loc]{L}})}\terminal{/}{\variable[K]{Name}}]}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"make-function"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 And here is some error management... \end{kblock}
\krule[function-decl-type-hint-not-supported-1]{
\kprefix{k}{\reduce{'FunctionDecl(\AnyVar[KList]\kcomma'ListWrap('ParamDefault(\variable[K]{X}\kcomma\variable[K]{Y}\kcomma\variable[K]{Z}))\kcomma\AnyVar[KList])}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"Class type hint"}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"function-decl-type-hint-not-supported-1"}}}
}{}{}{\kattribute{step}, \kattribute{error}}{}
\krule[function-decl-type-hint-not-supported-2]{
\kprefix{k}{\reduce{'FunctionDecl(\AnyVar[KList]\kcomma'ListWrap('Param(\variable[K]{X}\kcomma\variable[K]{Y}))\kcomma\AnyVar[KList])}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"Class type hint"}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"function-decl-type-hint-not-supported-2"}}}
}{}{}{\kattribute{step}, \kattribute{error}}{}
\krule[function-decl-type-hint-not-supported-3]{
\kprefix{k}{\reduce{'ParamDefault(\variable[K]{X}\kcomma\variable[K]{Y}\kcomma\variable[K]{Z})}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"Class type hint"}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"function-decl-type-hint-not-supported-3"}}}
}{}{}{\kattribute{step}, \kattribute{error}}{}
\krule[function-decl-type-hint-not-supported-4]{
\kprefix{k}{\reduce{'Param(\variable[K]{X}\kcomma\variable[K]{Y})}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"Class type hint"}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"function-decl-type-hint-not-supported-4"}}}
}{}{}{\kattribute{step}, \kattribute{error}}{}
\begin{kblock}[text]
 \subsection{Function Call} \end{kblock}
\krule[function-name]{
\kprefix{k}{\reduce{'FunctionName(\variable[String]{FName})}{\variable[String]{FName}}}
}{}{}{\kattribute{step}}{}
\kcontext{
'FunctionCall(\khole{}\kcomma\AnyVar[K])}{}{}{\kattribute{structural}}
\krule[func-call-fname2LangValue]{
\kprefix{k}{'FunctionCall(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}\kcomma\AnyVar[K])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"func-call-fname2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[func-call]{
\kprefix{k}{\reduce{'FunctionCall(\variable[String]{FName}\kcomma'ListWrap(\variable[KList]{Args}))}{{}\terminal{\#runFunction}({\variable[String]{FName}},{\variable[K]{FunDef}},{\constant[\#Bool]{true}},{'ListWrap(\variable[KList]{Args})},{{}\terminal{none}},{{}\terminal{none}})}}
\mathrel{}\kmiddle{functions}{\variable[String]{FName}\mapsto\variable[K]{FunDef}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"func-call"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[String]{FName}}\terminal{==String}{\constant[\#String]{"var\_dump"}}}\right)}}{}{\kattribute{step}}{}
\krule[func-call-func-not-defined]{
\kprefix{k}{\reduce{'FunctionCall(\variable[String]{FName}\kcomma'ListWrap(\variable[KList]{Args}))}{{}\terminal{NOT-SUPPORTED}({{{\constant[\#String]{"'"}}+_{\scriptstyle\it String}{\variable[String]{FName}}}+_{\scriptstyle\it String}{\constant[\#String]{"' not defined!"}}})}}
\mathrel{}\kall{functions}{\variable[Map]{F}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[String]{FName}}\terminal{in}{{}\terminal{keys}{\left({\variable[Map]{F}}\right)}}}\right)}}{}{\kattribute{step}, \kattribute{error}}{}
\begin{kblock}[text]
 \subsection{Return} \end{kblock}
\kcontext{
'Return(\khole{})}{}{}{\kattribute{structural}}
\kcontext{
'Some(\khole{})}{}{}{\kattribute{structural}}
\krule[some]{
\kprefix{k}{\reduce{'Some(\variable[KResult]{V})}{\variable[KResult]{V}}}
}{}{}{\kattribute{structural}}{}
\krule[return-some]{
\kprefix{k}{\reduce{'Return('Some(\variable[KResult]{V}))}{'Return(\variable[KResult]{V})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"return-some"}}}
}{}{}{\kattribute{structural}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Returnable}}}\syntax{{\nonTerminal{\sort{LanguageValue}}}}{}\syntaxCont{{\nonTerminal{\sort{Loc}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{isRetValueLoc}({{\nonTerminal{\sort{Returnable}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{isRetValueLoc}({\variable[Loc]{L}})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{isRetValueLoc}({\variable[LanguageValue]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule[return-arg2Loc]{
\kprefix{k}{'Return(\reduce{\variable[Ref]{R}}{{}\terminal{convertToLoc}({\variable[Ref]{R}},{{}\terminal{r}})})}
\mathrel{}\kprefix{functionStack}{\AnyVar[StackFrame]}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"return-arg2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[return-arg2LangValue-not-compound]{
\kprefix{k}{'Return(\reduce{\variable[Loc]{L}}{{}\terminal{convertToLanguageValue}({\variable[Loc]{L}})})}
\mathrel{}\kprefix{functionStack}{{}\terminal{sf}({\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{{}\terminal{@byValue}},{\AnyVar[K]})}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[K]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"return-arg2LangValue-not-compound"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[K]{V}}\terminal{isCompoundValue}}\right)}}{}{\kattribute{intermediate}}{}
\krule[return]{
\kall{k}{\reduce{'Return(\variable[Returnable]{V})\kra\AnyVar[K]}{{}\terminal{*Cond}({{\left({{\variable[K]{RefMode}}\mathrel{=_K}{{}\terminal{@byRef}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{{}\terminal{isRetValueLoc}({\variable[Returnable]{V}})}}\right)}},{{}\terminal{NOTICE}({\constant[\#String]{"Only variable references should be returned by reference in \%s on line \%d\textbackslash n"}})},{\dotCt{K}})\kra{}\terminal{\#setCrntScope}({\variable[K]{CallerScope}})\kra{}\terminal{\#setCrntClass}({\variable[K]{CallerClass}})\kra{}\terminal{\#setCrntObj}({\variable[K]{CallerObj}})\kra{}\terminal{decRefCount}({\variable[Loc]{LocalScope}})\kra{}\terminal{\#popStackFrame}\kra\variable[Returnable]{V}\kra\variable[K]{K}}}
\mathrel{}\kprefix{functionStack}{{}\terminal{sf}({\AnyVar[String]},{\variable[K]{K}},{\variable[K]{CallerScope}},{\variable[K]{CallerClass}},{\variable[K]{CallerObj}},{\variable[K]{RefMode}},{\variable[K]{D}})}
\mathrel{}\kall{currentScope}{\variable[Loc]{LocalScope}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{LocalScope}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{functionArgumentsDeclaration}{\reduce{\AnyVar[K]}{\variable[K]{D}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"return"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \subsection{The static construct} \end{kblock}
\kcontext{
'DeclareStatic('ListWrap('StaticVariable(\AnyVar[KList]\kcomma\khole{})\kcomma\variable[KList]{Gs}))}{}{}{\kattribute{structural}}
\krule[static-no-init-value]{
\kprefix{k}{\reduce{'DeclareStatic('ListWrap('StaticVariable(\variable[K]{G})\kcomma\variable[KList]{Gs}))}{'DeclareStatic('ListWrap('StaticVariable(\variable[K]{G}\kcomma{}\terminal{NULL})\kcomma\variable[KList]{Gs}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"static-no-init-value"}}}
}{}{}{\kattribute{structural}}{}
\krule[static-cons]{
\kprefix{k}{\reduce{'DeclareStatic('ListWrap('StaticVariable(\variable[K]{G}\kcomma\variable[Value]{V})\kcomma\variable[KList]{Gs}))}{{}\terminal{\#declareStatic}({\variable[K]{G}},{\variable[Value]{V}})\kra'DeclareStatic('ListWrap(\variable[KList]{Gs}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"static-cons"}}}
}{}{}{\kattribute{structural}}{}
\krule[static-nil]{
\kprefix{k}{\reduce{'DeclareStatic('ListWrap())}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"static-nil"}}}
}{}{}{\kattribute{step}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#declareStatic}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{Value}}}})}{}
\end{syntaxBlock}
\begin{kblock}[text]
 When a static variable declaration is encountered at top level we basically 
    ignore it, and transform it into a standard assignment by value. 
    NOTE: Honestly I (Daniele) don't understand what's the meaning of a "static-global" 
    variable. To me it just looks like a normal variable that lives in the global scope. 
    However, I guess it might be relevant when using 'include' and stuff like that. 
    So, the following rule might need an update at some point. \end{kblock}
\krule[declare-static]{
\kprefix{k}{\reduce{{}\terminal{\#declareStatic}({'Variable('Simple(\variable[String]{X}))},{\variable[Value]{V}})}{'Expr('Assign('Variable('Simple(\variable[String]{X}))\kcomma\variable[Value]{V}))}}
}{}{}{}{}
\begin{kblock}[text]
 \subsection{The global construct} \end{kblock}
\krule[global-cons]{
\kprefix{k}{\reduce{'DeclareGlobal('ListWrap(\variable[K]{G}\kcomma\variable[KList]{Gs}))}{{}\terminal{\#declareGlobal}({\variable[K]{G}})\kra'DeclareGlobal('ListWrap(\variable[KList]{Gs}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"global-cons"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[global-nil]{
\kprefix{k}{\reduce{'DeclareGlobal('ListWrap())}{\dotCt{K}}}
}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#declareGlobal}({{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\kcontext{
{}\terminal{\#declareGlobal}({'IndirectReference(\khole{})})}{}{}{\kattribute{context}}
\krule[declare-global-indirect-arg2LangVal]{
\kprefix{k}{{}\terminal{\#declareGlobal}({'IndirectReference(\reduce{\variable[Ref]{R}}{{}\terminal{convertToLanguageValue}({\variable[Ref]{R}})})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"declare-global-indirect-arg2LangVal"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[declare-global-indirect]{
\kprefix{k}{\reduce{{}\terminal{\#declareGlobal}({'IndirectReference(\variable[String]{X})})}{{}\terminal{\#declareGlobal}({'Variable('Simple(\variable[String]{X}))})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"declare-global-indirect"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[declare-global]{
\kprefix{k}{\reduce{{}\terminal{\#declareGlobal}({'Variable('Simple(\variable[String]{X}))})}{'Expr('ReferenceAssign('Variable('Simple(\variable[String]{X}))\kcomma'ArrayAccess('Variable('Simple(\constant[\#String]{"GLOBALS"}))\kcomma\variable[String]{X})))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"declare-global"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \section{Internal operations for functions} 
		As usual with dealing with complex operations, we define a number of auxiliary 
		specialized functions, which we'll combine in order to complete the task. \end{kblock}
\kcontext{
'Param(\khole{})}{}{}{}
\krule[param]{
\kprefix{k}{\reduce{'Param(\variable[Value]{V})}{\variable[Value]{V}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"param"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Changing the current scope} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#setCrntScope}({{\nonTerminal{\sort{Loc}}}})}{}
\end{syntaxBlock}
\krule[set-crtn-scope]{
\kprefix{k}{\reduce{{}\terminal{\#setCrntScope}({\variable[Loc]{L}})}{\dotCt{K}}}
\mathrel{}\kall{currentScope}{\reduce{\AnyVar[K]}{\variable[Loc]{L}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"set-crtn-scope"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Changing the current object} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#setCrntObj}({{\nonTerminal{\sort{OptionLoc}}}})}{}
\end{syntaxBlock}
\krule[set-crnt-obj]{
\kprefix{k}{\reduce{{}\terminal{\#setCrntObj}({\variable[K]{Obj}})}{\dotCt{K}}}
\mathrel{}\kall{object}{\reduce{\AnyVar[K]}{\variable[K]{Obj}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"set-crnt-obj"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Allocating the current object} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#allocCrntObj}({{\nonTerminal{\sort{OptionLoc}}}})}{}
\end{syntaxBlock}
\krule[alloc-crnt-obj]{
\kprefix{k}{\reduce{{}\terminal{\#allocCrntObj}({\variable[Loc]{Obj}})}{{}\terminal{\#write}({\variable[Object]{V}},{\variable[Loc]{L1}})}}
\mathrel{}\kall{object}{\reduce{\AnyVar[K]}{\variable[Loc]{L1}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{Obj}\mapsto{}\terminal{zval}({\variable[Object]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"alloc-crnt-obj"}}}
}{{}\terminal{fresh}({\variable[Loc]{L1}})}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Changing the current class} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#setCrntClass}({{\nonTerminal{\sort{OptionId}}}})}{}
\end{syntaxBlock}
\krule[set-crnt-class]{
\kprefix{k}{\reduce{{}\terminal{\#setCrntClass}({\variable[K]{Class}})}{\dotCt{K}}}
\mathrel{}\kall{class}{\reduce{\AnyVar[K]}{\variable[K]{Class}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"set-crnt-class"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Pushing a stack frame} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#pushStackFrame}({{\nonTerminal{\sort{String}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[push-stack-frame]{
\kprefix{k}{\reduce{{}\terminal{\#pushStackFrame}({\variable[String]{FName}},{\variable[K]{K}},{\variable[Loc]{OldScope}},{\variable[K]{Class}},{\variable[K]{Obj}},{\variable[K]{RetType}},{\variable[K]{D}})}{\dotCt{K}}}
\mathrel{}\kprefix{functionStack}{\reduce{\dotCt{List}}{{}\terminal{sf}({\variable[String]{FName}},{\variable[K]{K}},{\variable[Loc]{OldScope}},{\variable[K]{Class}},{\variable[K]{Obj}},{\variable[K]{RetType}},{\variable[K]{D}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"push-stack-frame"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Popping a stack frame} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#popStackFrame}}{}
\end{syntaxBlock}
\krule[pop-stack-frame]{
\kprefix{k}{\reduce{{}\terminal{\#popStackFrame}}{\dotCt{K}}}
\mathrel{}\kprefix{functionStack}{\reduce{{}\terminal{sf}({\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}{\dotCt{List}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"pop-stack-frame"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Processing functions arguments} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#processFunArgs}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\kcontext{
{}\terminal{\#processFunArgs}({'ListWrap('Param(\variable[K]{Param})\kcomma\variable[KList]{Params})},{'ListWrap('Param(\khole{})\kcomma\variable[KList]{Args})})}{}{}{}
\krule[process-fun-args-arg2LangValue]{
\kprefix{k}{\reduce{{}\terminal{\#processFunArgs}({'ListWrap('Param(\variable[K]{Hint}\kcomma\variable[K]{Var})\kcomma\variable[KList]{Params})},{\AnyVar[K]})}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"Type hints"}})}}
}{}{}{}{}
\krule[process-fun-args-arg2LangValue]{
\kprefix{k}{{}\terminal{\#processFunArgs}({'ListWrap('Param(\variable[K]{Param})\kcomma\variable[KList]{Params})},{'ListWrap('Param(\reduce{\variable[Ref]{R}}{{}\terminal{convertToLanguageValue}({\variable[Ref]{R}})})\kcomma\variable[KList]{Args})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"process-fun-args-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[process-fun-args-param]{
\kprefix{k}{\reduce{{}\terminal{\#processFunArgs}({'ListWrap('Param(\variable[K]{Param})\kcomma\variable[KList]{Params})},{'ListWrap('Param(\variable[Value]{V})\kcomma\variable[KList]{Args})})}{{}\terminal{\#processFunArgs}({'ListWrap(\variable[KList]{Params})},{'ListWrap(\variable[KList]{Args})})}}
\mathrel{}\kall{functionArgumentsDeclaration}{\reduce{\variable[K]{I}}{\variable[K]{I}\kra'Expr('Assign(\variable[K]{Param}\kcomma\variable[Value]{V}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"process-fun-args-param"}}}
}{}{}{\kattribute{intermediate}}{}
\krule{
\kprefix{k}{\reduce{{}\terminal{\#processFunArgs}({'ListWrap('Param(\variable[K]{Param})\kcomma\variable[KList]{Params})},{'ListWrap(\variable[Value]{V}\kcomma\variable[KList]{Args})})}{{}\terminal{\#processFunArgs}({'ListWrap(\variable[KList]{Params})},{'ListWrap(\variable[KList]{Args})})}}
\mathrel{}\kall{functionArgumentsDeclaration}{\reduce{\variable[K]{I}}{\variable[K]{I}\kra'Expr('Assign(\variable[K]{Param}\kcomma\variable[Value]{V}))}}
}{}{}{}{}
\kcontext{
{}\terminal{\#processFunArgs}({'ListWrap('ParamDefault(\variable[K]{Param}\kcomma\variable[K]{Default})\kcomma\variable[KList]{Params})},{'ListWrap('Param(\khole{})\kcomma\variable[KList]{Args})})}{}{}{}
\krule[process-fun-args-default-arg2LangValue]{
\kprefix{k}{{}\terminal{\#processFunArgs}({'ListWrap('ParamDefault(\variable[K]{Param}\kcomma\variable[K]{Default})\kcomma\variable[KList]{Params})},{'ListWrap('Param(\reduce{\variable[Ref]{R}}{{}\terminal{convertToLanguageValue}({\variable[Ref]{R}})})\kcomma\variable[KList]{Args})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"process-fun-args-default-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[process-fun-args-default]{
\kprefix{k}{\reduce{{}\terminal{\#processFunArgs}({'ListWrap('ParamDefault(\variable[K]{Param}\kcomma\variable[K]{Default})\kcomma\variable[KList]{Params})},{'ListWrap('Param(\variable[Value]{V})\kcomma\variable[KList]{Args})})}{{}\terminal{\#processFunArgs}({'ListWrap(\variable[KList]{Params})},{'ListWrap(\variable[KList]{Args})})}}
\mathrel{}\kall{functionArgumentsDeclaration}{\reduce{\variable[K]{I}}{\variable[K]{I}\kra'Expr('Assign(\variable[K]{Param}\kcomma\variable[Value]{V}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"process-fun-args-default"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[process-fun-args-default-none]{
\kprefix{k}{\reduce{{}\terminal{\#processFunArgs}({'ListWrap('ParamDefault(\variable[K]{Param}\kcomma\variable[K]{Default})\kcomma\variable[KList]{Params})},{'ListWrap()})}{{}\terminal{\#processFunArgs}({'ListWrap(\variable[KList]{Params})},{'ListWrap()})}}
\mathrel{}\kall{functionArgumentsDeclaration}{\reduce{\variable[K]{I}}{\variable[K]{I}\kra'Expr('Assign(\variable[K]{Param}\kcomma\variable[K]{Default}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"process-fun-args-default-none"}}}
}{}{}{\kattribute{intermediate}}{}
\kcontext{
{}\terminal{\#processFunArgs}({'ListWrap('ParamRef(\variable[K]{Param})\kcomma\variable[KList]{Params})},{'ListWrap('Param(\khole{})\kcomma\variable[KList]{Args})})}{}{}{}
\krule[process-fun-args-ref]{
\kprefix{k}{\reduce{{}\terminal{\#processFunArgs}({'ListWrap('ParamRef(\variable[K]{Param})\kcomma\variable[KList]{Params})},{'ListWrap('Param(\variable[Value]{V})\kcomma\variable[KList]{Args})})}{{}\terminal{\#processFunArgs}({'ListWrap(\variable[KList]{Params})},{'ListWrap(\variable[KList]{Args})})}}
\mathrel{}\kall{functionArgumentsDeclaration}{\reduce{\variable[K]{I}}{\variable[K]{I}\kra'Expr('ReferenceAssign(\variable[K]{Param}\kcomma\variable[Value]{V}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"process-fun-args-ref"}}}
}{}{}{\kattribute{intermediate}}{}
\krule{
\kprefix{k}{\reduce{{}\terminal{\#processFunArgs}({'ListWrap('ParamRef(\variable[K]{Param})\kcomma\variable[KList]{Params})},{'ListWrap(\variable[Value]{V}\kcomma\variable[KList]{Args})})}{{}\terminal{\#processFunArgs}({'ListWrap(\variable[KList]{Params})},{'ListWrap(\variable[KList]{Args})})}}
\mathrel{}\kall{functionArgumentsDeclaration}{\reduce{\variable[K]{I}}{\variable[K]{I}\kra'Expr('ReferenceAssign(\variable[K]{Param}\kcomma\variable[Value]{V}))}}
}{}{}{}{}
\krule[process-fun-args-empty]{
\kprefix{k}{\reduce{{}\terminal{\#processFunArgs}({'ListWrap()},{\AnyVar[K]})}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"process-fun-args-empty"}}}
}{}{}{\kattribute{step}}{}
\krule[process-fun-args-error]{
\kprefix{k}{\reduce{{}\terminal{\#processFunArgs}({'ListWrap('ParamDefault(\variable[String]{TypeHint}\kcomma\AnyVar[K]\kcomma\AnyVar[K]))},{\AnyVar[K]})}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"Type Hints"}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"process-fun-args-error"}}}
}{}{}{\kattribute{step}, \kattribute{error}}{}
\begin{kblock}[text]
 \subsection{Trying to reference assing on a function which returns a value} 
		This operation is clearly not possible, and it is managed by treating the 
		reference assignment as a value assignment (which we do via desugaring). 
		TODO: probably a warning should be issues. \end{kblock}
\krule[ref-assign-fun-returns-value]{
\kprefix{k}{\reduce{'ReferenceAssign(\variable[K]{X}\kcomma'FunctionCall(\variable[String]{Fname}\kcomma'ListWrap(\variable[KList]{Args})))}{'Assign(\variable[K]{X}\kcomma'FunctionCall(\variable[String]{Fname}\kcomma'ListWrap(\variable[KList]{Args})))}}
\mathrel{}\kmiddle{functions}{\variable[String]{Fname}\mapsto{}\terminal{f}({\AnyVar[K]},{\AnyVar[K]},{{}\terminal{@byValue}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"ref-assign-fun-returns-value"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Internal function and method call operation} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#runFunction}({{\nonTerminal{\sort{String}}}},{{\nonTerminal{\sort{FunDef}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{Bool}}}},{{\nonTerminal{\sort{OptionId}}}},{{\nonTerminal{\sort{OptionLoc}}}})}{}
\end{syntaxBlock}
\krule[run-function]{
\kall{k}{\reduce{{}\terminal{\#runFunction}({\variable[String]{FName}},{{}\terminal{f}({\variable[K]{Parameters}},{\variable[K]{Body}},{\variable[K]{RetType}},{\variable[Loc]{LStatic}})},{\variable[Bool]{Static}},{\variable[K]{Args}},{\variable[OptionId]{Class}},{\variable[OptionLoc]{Obj}})\kra\variable[K]{K}}{{}\terminal{*Cond}({{\left({\neg_{\scriptstyle\it Bool}{\variable[Bool]{Static}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{\left({{\variable[OptionLoc]{Obj}}\mathrel{=_K}{{}\terminal{none}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{\variable[K]{CurrentObj}}\mathrel{=_K}{\dotCt{K}}}\right)}}\right)}},{{}\terminal{NOTICE}({\constant[\#String]{"Non-static method should not be called statically\textbackslash n"}})},{\dotCt{K}})\kra{}\terminal{\#processFunArgs}({\variable[K]{Parameters}},{\variable[K]{Args}})\kra{}\terminal{\#pushStackFrame}({\variable[String]{FName}},{\variable[K]{K}},{\variable[Loc]{L}},{\variable[K]{CurrentClass}},{\variable[K]{CurrentObj}},{\variable[K]{RetType}},{\variable[K]{D}})\kra{}\terminal{ArrayCreateEmpty}({\variable[Loc]{L1}})\kra{}\terminal{\#setCrntScope}({\variable[Loc]{L1}})\kra{}\terminal{incRefCount}({\variable[Loc]{L1}})\kra{}\terminal{\#setCrntClass}({\variable[OptionId]{Class}})\kra{}\terminal{*Cond}({{\variable[OptionLoc]{Obj}}\mathrel{\neq_K}{{}\terminal{none}}},{{}\terminal{\#allocCrntObj}({\variable[OptionLoc]{Obj}})},{\dotCt{K}})\kra{}\terminal{LgetDecls}\kra\variable[K]{Body}\kra'Return({}\terminal{NULL})}}
\mathrel{}\kall{functionArgumentsDeclaration}{\reduce{\variable[K]{D}}{\dotCt{K}}}
\mathrel{}\kall{currentScope}{\variable[Loc]{L}}
\mathrel{}\kall{class}{\variable[K]{CurrentClass}}
\mathrel{}\kall{object}{\variable[K]{CurrentObj}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"run-function"}}}
}{{}\terminal{fresh}({\variable[Loc]{L1}})}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Getting the function arguments} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{LgetDecls}}{}
\end{syntaxBlock}
\krule[get-fun-decls]{
\kprefix{k}{\reduce{{}\terminal{LgetDecls}}{\variable[K]{Declarations}}}
\mathrel{}\kall{functionArgumentsDeclaration}{\reduce{\variable[K]{Declarations}}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"get-fun-decls"}}}
}{}{}{\kattribute{internal}}{}
\end{module}
\begin{module}{\moduleName{CLASSES}}

\begin{syntaxBlock}{\nonTerminal{\sort{Id}}}\syntax{{}\terminal{this}}{}\syntaxCont{{}\terminal{stdClass}}{}\syntaxCont{{}\terminal{ROOT}}{}
\end{syntaxBlock}
\begin{kblock}[text]
 \section{Class Declaration} \end{kblock}
\begin{kblock}[text]
 \subsection{Data Structures} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{ClassDef}}}\syntax{{}\terminal{class}({{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{List}}}},{{\nonTerminal{\sort{Map}}}},{{\nonTerminal{\sort{Loc}}}})}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{ClassProp}}}\syntax{{}\terminal{prop}({{\nonTerminal{\sort{String}}}},{{\nonTerminal{\sort{OptionArrayItemVisibility}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{ClassMethod}}}\syntax{{}\terminal{method}({{\nonTerminal{\sort{FunDef}}}},{{\nonTerminal{\sort{OptionArrayItemVisibility}}}},{{\nonTerminal{\sort{Bool}}}})}{}
\end{syntaxBlock}
\begin{kblock}[text]
 \subsection{Surface syntax} \end{kblock}
\krule[class-no-extends]{
\kprefix{k}{'Class(\AnyVar[KList]\kcomma\variable[String]{Name}\kcomma\reduce{'None(\AnyVar[KList])}{'Some('Extends(\constant[\#String]{"stdClass"}))}\kcomma\AnyVar[KList]\kcomma\AnyVar[KList])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"class-no-extends"}}}
}{{\variable[String]{Name}}\terminal{=/=String}{\constant[\#String]{"stdClass"}}}{}{\kattribute{structural}}{}
\krule[class-stdClass]{
\kprefix{k}{'Class(\AnyVar[KList]\kcomma\constant[\#String]{"stdClass"}\kcomma\reduce{'None(\AnyVar[KList])}{'Some('Extends(\constant[\#String]{"ROOT"}))}\kcomma\AnyVar[KList]\kcomma\AnyVar[KList])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"class-stdClass"}}}
}{}{}{\kattribute{internal}}{}
\krule[class]{
\kprefix{k}{\reduce{'Class('Normal(\AnyVar[KList])\kcomma\variable[String]{Name}\kcomma'Some('Extends(\variable[String]{Parent}))\kcomma'None(\AnyVar[KList])\kcomma'ListWrap(\variable[KList]{Members}))}{{}\terminal{createEmptyClass}({{}\terminal{String2Id}({\variable[String]{Name}})},{{}\terminal{String2Id}({\variable[String]{Parent}})})\kra{}\terminal{initClass}({{}\terminal{String2Id}({\variable[String]{Name}})},{'ListWrap(\variable[KList]{Members})})}}
\mathrel{}\kmiddle{classInstanceCounters}{\reduce{\dotCt{Map}}{{}\terminal{String2Id}({\variable[String]{Name}})\mapsto\constant[\#Int]{0}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"class"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 The Implements construct is not supported yet :( \end{kblock}
\krule[class-implements]{
\kprefix{k}{\reduce{'Class(\AnyVar[KList]\kcomma\AnyVar[KList]\kcomma\AnyVar[KList]\kcomma'Some('Implements(\AnyVar[KList]))\kcomma\AnyVar[KList])}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"KPHP ERROR: Interfaces not supported!"}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"class-implements"}}}
}{}{}{\kattribute{step}, \kattribute{error}}{}
\begin{kblock}[text]
 \subsection{Internal operations for class declaration} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{isStatic}({{\nonTerminal{\sort{K}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{isStatic}({'Modifiers('ListWrap('Static(\AnyVar[KList])\kcomma'Public(\AnyVar[KList])))})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{isStatic}({'Modifiers('ListWrap('Static(\AnyVar[KList])\kcomma'Protected(\AnyVar[KList])))})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{isStatic}({'Modifiers('ListWrap('Static(\AnyVar[KList])\kcomma'Private(\AnyVar[KList])))})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{isStatic}({'Modifiers('ListWrap('Public(\AnyVar[KList])\kcomma'Static(\AnyVar[KList])))})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{isStatic}({'Modifiers('ListWrap('Protected(\AnyVar[KList])\kcomma'Static(\AnyVar[KList])))})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{isStatic}({'Modifiers('ListWrap('Private(\AnyVar[KList])\kcomma'Static(\AnyVar[KList])))})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{isStatic}({'Modifiers('ListWrap('Static(\AnyVar[KList])))})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{isStatic}({'Modifiers('ListWrap('Public(\AnyVar[KList])))})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{isStatic}({'Modifiers('ListWrap('Protected(\AnyVar[KList])))})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{isStatic}({'Modifiers('ListWrap('Private(\AnyVar[KList])))})}{\constant[\#Bool]{false}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{OptionArrayItemVisibility}}}\syntax{{}\terminal{getVisibility}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{Id}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{getVisibility}({'Modifiers('ListWrap('Static(\AnyVar[KList])\kcomma'Public(\AnyVar[KList])))},{\AnyVar[K]})}{{}\terminal{none}}}{}{}{}{}
\krule{
\reduce{{}\terminal{getVisibility}({'Modifiers('ListWrap('Static(\AnyVar[KList])\kcomma'Protected(\AnyVar[KList])))},{\AnyVar[K]})}{{}\terminal{pro}}}{}{}{}{}
\krule{
\reduce{{}\terminal{getVisibility}({'Modifiers('ListWrap('Static(\AnyVar[KList])\kcomma'Private(\AnyVar[KList])))},{\variable[K]{ClassName}})}{{}\terminal{pri}({\variable[K]{ClassName}})}}{}{}{}{}
\krule{
\reduce{{}\terminal{getVisibility}({'Modifiers('ListWrap('Public(\AnyVar[KList])\kcomma'Static(\AnyVar[KList])))},{\AnyVar[K]})}{{}\terminal{none}}}{}{}{}{}
\krule{
\reduce{{}\terminal{getVisibility}({'Modifiers('ListWrap('Protected(\AnyVar[KList])\kcomma'Static(\AnyVar[KList])))},{\AnyVar[K]})}{{}\terminal{pro}}}{}{}{}{}
\krule{
\reduce{{}\terminal{getVisibility}({'Modifiers('ListWrap('Private(\AnyVar[KList])\kcomma'Static(\AnyVar[KList])))},{\variable[K]{ClassName}})}{{}\terminal{pri}({\variable[K]{ClassName}})}}{}{}{}{}
\krule{
\reduce{{}\terminal{getVisibility}({'Modifiers('ListWrap('Static(\AnyVar[KList])))},{\AnyVar[K]})}{{}\terminal{none}}}{}{}{}{}
\krule{
\reduce{{}\terminal{getVisibility}({'Modifiers('ListWrap('Public(\AnyVar[KList])))},{\AnyVar[K]})}{{}\terminal{none}}}{}{}{}{}
\krule{
\reduce{{}\terminal{getVisibility}({'Modifiers('ListWrap('Protected(\AnyVar[KList])))},{\AnyVar[K]})}{{}\terminal{pro}}}{}{}{}{}
\krule{
\reduce{{}\terminal{getVisibility}({'Modifiers('ListWrap('Private(\AnyVar[KList])))},{\variable[K]{ClassName}})}{{}\terminal{pri}({\variable[K]{ClassName}})}}{}{}{}{}
\begin{kblock}[text]
 Creating an empty class \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{createEmptyClass}({{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{Id}}}})}{}
\end{syntaxBlock}
\krule[create-empty-class]{
\kprefix{k}{\reduce{{}\terminal{createEmptyClass}({\variable[Id]{ClassName}},{\variable[Id]{ParentName}})}{{}\terminal{ArrayCreateEmpty}({\variable[Loc]{L1}})\kra{}\terminal{incRefCount}({\variable[Loc]{L1}})}}
\mathrel{}\kall{classes}{\reduce{\variable[Map]{Classes}}{{\variable[Map]{Classes}}[{{}\terminal{class}({\variable[Id]{ParentName}},{\dotCt{List}},{\dotCt{Map}},{\variable[Loc]{L1}})}\terminal{/}{\variable[Id]{ClassName}}]}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"create-empty-class"}}}
}{{\neg_{\scriptstyle\it Bool}{\left({{\variable[Id]{ClassName}}\terminal{in}{{}\terminal{keys}{\left({\variable[Map]{Classes}}\right)}}}\right)}}\wedge_{\scriptstyle\it Bool}{{}\terminal{fresh}({\variable[Loc]{L1}})}}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 Class initialization \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{initClass}({{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[init-class-cons]{
\kprefix{k}{\reduce{{}\terminal{initClass}({\variable[Id]{ClassName}},{'ListWrap(\variable[K]{D}\kcomma\variable[KList]{Ds})})}{{}\terminal{initClassMemberDecl}({\variable[Id]{ClassName}},{\variable[K]{D}})\kra{}\terminal{initClass}({\variable[Id]{ClassName}},{'ListWrap(\variable[KList]{Ds})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-class-cons"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[init-class-nil]{
\kprefix{k}{\reduce{{}\terminal{initClass}({\variable[Id]{ClassName}},{'ListWrap()})}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-class-nil"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{initClassMemberDecl}({{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[init-class-member-nil]{
\kprefix{k}{\reduce{{}\terminal{initClassMemberDecl}({\variable[Id]{ClassName}},{'InstanceVariable(\AnyVar[KList]\kcomma'ListWrap())})}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-class-member-nil"}}}
}{}{}{\kattribute{internal}}{}
\krule[init-class-member-constant-decl-list]{
\kprefix{k}{\reduce{{}\terminal{initClassMemberDecl}({\AnyVar[K]},{'ClassConstantDeclList(\AnyVar[KList])})}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"ClassConstantDeclList"}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-class-member-constant-decl-list"}}}
}{}{}{\kattribute{internal}}{}
\krule[init-class-member-decl-no-modifier]{
\kprefix{k}{\reduce{{}\terminal{initClassMemberDecl}({\variable[Id]{ClassName}},{'InstanceVariable('ListWrap(\variable[K]{Vars}))})}{{}\terminal{initClassMemberDecl}({\variable[Id]{ClassName}},{'InstanceVariable('Modifiers('ListWrap('Public()))\kcomma'ListWrap(\variable[K]{Vars}))})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-class-member-decl-no-modifier"}}}
}{}{}{\kattribute{structural}}{}
\krule[init-class-member-decl-static]{
\kprefix{k}{\reduce{{}\terminal{initClassMemberDecl}({\variable[Id]{ClassName}},{'InstanceVariable(\variable[K]{Modifiers}\kcomma\variable[K]{Members})})}{{}\terminal{writeClassInstanceMembers}({\variable[Id]{ClassName}},{\variable[K]{Members}},{{}\terminal{getVisibility}({\variable[K]{Modifiers}},{\variable[Id]{ClassName}})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-class-member-decl-static"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{isStatic}({\variable[K]{Modifiers}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[init-class-member-decl-instance]{
\reduce{{}\terminal{initClassMemberDecl}({\variable[Id]{ClassName}},{'InstanceVariable(\variable[K]{Modifiers}\kcomma\variable[K]{Members})})}{{}\terminal{writeClassStaticMembers}({\variable[Id]{ClassName}},{\variable[K]{Members}},{{}\terminal{getVisibility}({\variable[K]{Modifiers}},{\variable[Id]{ClassName}})})}}{{}\terminal{isStatic}({\variable[K]{Modifiers}})}{}{\kattribute{intermediate}}{}
\krule[init-class-member-decl-meth-no-modifiers]{
\kprefix{k}{\reduce{{}\terminal{initClassMemberDecl}({\variable[Id]{ClassName}},{'FunctionDecl(\variable[String]{FName}\kcomma\variable[K]{Parameters}\kcomma\variable[K]{Body})})}{{}\terminal{initClassMemberDecl}({\variable[Id]{ClassName}},{'FunctionDecl('Modifiers('ListWrap('Public()))\kcomma\variable[String]{FName}\kcomma\variable[K]{Parameters}\kcomma\variable[K]{Body})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-class-member-decl-meth-no-modifiers"}}}
}{}{}{\kattribute{structural}}{}
\krule[init-class-member-decl-meth-ref-no-modifiers]{
\kprefix{k}{\reduce{{}\terminal{initClassMemberDecl}({\variable[Id]{ClassName}},{'FunctionDeclRef(\variable[String]{FName}\kcomma\variable[K]{Parameters}\kcomma\variable[K]{Body})})}{{}\terminal{initClassMemberDecl}({\variable[Id]{ClassName}},{'FunctionDeclRef('Modifiers('ListWrap('Public()))\kcomma\variable[String]{FName}\kcomma\variable[K]{Parameters}\kcomma\variable[K]{Body})})}}
}{}{}{}{}
\krule[init-class-member-decl-meth]{
\kprefix{k}{\reduce{{}\terminal{initClassMemberDecl}({\variable[Id]{ClassName}},{'FunctionDecl(\variable[K]{Modifiers}\kcomma\variable[String]{FName}\kcomma\variable[K]{Parameters}\kcomma\variable[K]{Body})})}{{}\terminal{ArrayCreateEmpty}({\variable[Loc]{L}})\kra{}\terminal{incRefCount}({\variable[Loc]{L}})\kra{}\terminal{writeClassMethod}({\variable[Id]{ClassName}},{\variable[String]{FName}},{\variable[K]{Parameters}},{{}\terminal{@byValue}},{{}\terminal{getVisibility}({\variable[K]{Modifiers}},{\variable[Id]{ClassName}})},{{}\terminal{isStatic}({\variable[K]{Modifiers}})},{{}\terminal{\#makeStaticDecls}({\variable[K]{Body}},{\variable[Loc]{L}})},{\variable[Loc]{L}})}}
\mathrel{}\kmiddle{classes}{\variable[Id]{ClassName}\mapsto{}\terminal{class}({\AnyVar[K]},{\AnyVar[List]},{\variable[Map]{Methods}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-class-member-decl-meth"}}}
}{{\neg_{\scriptstyle\it Bool}{\left({{\variable[String]{FName}}\terminal{in}{{}\terminal{keys}{\left({\variable[Map]{Methods}}\right)}}}\right)}}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{fresh}({\variable[Loc]{L}})}\right)}}{}{\kattribute{internal}}{}
\krule[init-class-member-decl-meth-ref]{
\kprefix{k}{\reduce{{}\terminal{initClassMemberDecl}({\variable[Id]{ClassName}},{'FunctionDeclRef(\variable[K]{Modifiers}\kcomma\variable[String]{FName}\kcomma\variable[K]{Parameters}\kcomma\variable[K]{Body})})}{{}\terminal{ArrayCreateEmpty}({\variable[Loc]{L}})\kra{}\terminal{incRefCount}({\variable[Loc]{L}})\kra{}\terminal{writeClassMethod}({\variable[Id]{ClassName}},{\variable[String]{FName}},{\variable[K]{Parameters}},{{}\terminal{@byRef}},{{}\terminal{getVisibility}({\variable[K]{Modifiers}},{\variable[Id]{ClassName}})},{{}\terminal{isStatic}({\variable[K]{Modifiers}})},{{}\terminal{\#makeStaticDecls}({\variable[K]{Body}},{\variable[Loc]{L}})},{\variable[Loc]{L}})}}
\mathrel{}\kmiddle{classes}{\variable[Id]{ClassName}\mapsto{}\terminal{class}({\AnyVar[K]},{\AnyVar[List]},{\variable[Map]{Methods}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-class-member-decl-meth-ref"}}}
}{{\neg_{\scriptstyle\it Bool}{\left({{\variable[String]{FName}}\terminal{in}{{}\terminal{keys}{\left({\variable[Map]{Methods}}\right)}}}\right)}}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{fresh}({\variable[Loc]{L}})}\right)}}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{{\nonTerminal{\sort{List}}}}\terminal{hasMember}{{\nonTerminal{\sort{K}}}}}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{{}\terminal{prop}({\variable[K]{K2}},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[List]{L2}}\terminal{hasMember}{\variable[K]{K1}}}{{\left({{\variable[K]{K1}}\mathrel{=_K}{\variable[K]{K2}}}\right)}\vee_{\scriptstyle\it Bool}{\left({{\variable[List]{L2}}\terminal{hasMember}{\variable[K]{K1}}}\right)}}}{}{}{}{}
\krule{
\reduce{{\dotCt{List}}\terminal{hasMember}{\AnyVar[K]}}{\constant[\#Bool]{false}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{writeClassInstanceMembers}({{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{OptionArrayItemVisibility}}}})}{}
\end{syntaxBlock}
\krule[write-class-instance-members-nil]{
\kprefix{k}{\reduce{{}\terminal{writeClassInstanceMembers}({\AnyVar[K]},{'ListWrap()},{\AnyVar[K]})}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"write-class-instance-members-nil"}}}
}{}{}{\kattribute{internal}}{}
\krule[write-class-instance-members-no-default]{
\kprefix{k}{{}\terminal{writeClassInstanceMembers}({\variable[Id]{ClassName}},{'ListWrap(\reduce{'Normal('Variable('Simple(\variable[String]{X})))}{'Default('Variable('Simple(\variable[String]{X}))\kcomma{}\terminal{NULL})}\kcomma\variable[KList]{Others})},{\variable[K]{Visib}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"write-class-instance-members-no-default"}}}
}{}{}{\kattribute{structural}}{}
\krule[write-class-instance-members]{
\kprefix{k}{\reduce{{}\terminal{writeClassInstanceMembers}({\variable[Id]{ClassName}},{'ListWrap('Default('Variable('Simple(\variable[String]{X}))\kcomma\variable[K]{DefValue})\kcomma\variable[KList]{Others})},{\variable[K]{Visib}})}{{}\terminal{writeClassInstanceMembers}({\variable[Id]{ClassName}},{'ListWrap(\variable[KList]{Others})},{\variable[K]{Visib}})}}
\mathrel{}\kmiddle{classes}{\variable[Id]{ClassName}\mapsto{}\terminal{class}({\AnyVar[K]},{\reduce{\variable[List]{ClassProps}}{\variable[List]{ClassProps}\mathrel{}{}\terminal{prop}({\variable[String]{X}},{\variable[K]{Visib}},{\variable[K]{DefValue}})}},{\AnyVar[Map]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"write-class-instance-members"}}}
}{}{}{\kattribute{intermediate}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{writeClassStaticMembers}({{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{OptionArrayItemVisibility}}}})}{}
\end{syntaxBlock}
\krule[write-class-static-members]{
\kprefix{k}{\reduce{{}\terminal{writeClassStaticMembers}({\AnyVar[K]},{'ListWrap()},{\AnyVar[K]})}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"write-class-static-members"}}}
}{}{}{\kattribute{internal}}{}
\krule[write-class-static-members-no-default]{
{}\terminal{writeClassStaticMembers}({\variable[Id]{ClassName}},{'ListWrap(\reduce{'Normal('Variable('Simple(\variable[String]{X})))}{'Default('Variable('Simple(\variable[String]{X}))\kcomma{}\terminal{NULL})}\kcomma\variable[KList]{Others})},{\variable[K]{Visib}})}{}{}{\kattribute{structural}}{}
\kcontext{
{}\terminal{writeClassStaticMembers}({\AnyVar[K]},{'ListWrap('Default('Variable('Simple(\variable[String]{X}))\kcomma\khole{})\kcomma\variable[KList]{Others})},{\AnyVar[K]})}{}{}{}
\krule[write-class-static-members-default]{
\kprefix{k}{\reduce{{}\terminal{writeClassStaticMembers}({\variable[Id]{ClassName}},{'ListWrap('Default('Variable('Simple(\variable[String]{X}))\kcomma\variable[Value]{DefValue})\kcomma\variable[KList]{Others})},{\variable[K]{Visib}})}{{}\terminal{ArrayCreateElem}({\variable[K]{L}},{\variable[String]{X}},{\variable[K]{Visib}},{{}\terminal{allocValue}({\variable[Value]{DefValue}})})\kra{}\terminal{writeClassStaticMembers}({\variable[Id]{ClassName}},{'ListWrap(\variable[KList]{Others})},{\variable[K]{Visib}})}}
\mathrel{}\kmiddle{classes}{\variable[Id]{ClassName}\mapsto{}\terminal{class}({\AnyVar[K]},{\AnyVar[List]},{\AnyVar[Map]},{\variable[K]{L}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"write-class-static-members"}}}
}{}{}{\kattribute{intermediate}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{writeClassMethod}({{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{String}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{OptionArrayItemVisibility}}}},{{\nonTerminal{\sort{Bool}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{Loc}}}})}{\kattribute{strict}(7)}
\end{syntaxBlock}
\krule[write-class-method-if-visited]{
\kprefix{k}{{}\terminal{writeClassMethod}({\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\framebox{${\reduce{'MethodBody(\variable[K]{Body})}{\variable[K]{Body}}}$}},{\variable[Loc]{L}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"write-class-method-if-visited"}}}
}{}{}{\kattribute{structural}}{}
\krule[write-class-method]{
\kprefix{k}{\reduce{{}\terminal{writeClassMethod}({\variable[Id]{ClassName}},{\variable[String]{FName}},{\variable[K]{Parameters}},{\variable[K]{RetType}},{\variable[K]{V}},{\variable[Bool]{StaticOrNot}},{\framebox{${\variable[K]{Body}}$}},{\variable[Loc]{L}})}{\dotCt{K}}}
\mathrel{}\kmiddle{classes}{\variable[Id]{ClassName}\mapsto{}\terminal{class}({\AnyVar[K]},{\AnyVar[List]},{\reduce{\variable[Map]{Methods}}{{\variable[Map]{Methods}}[{\left({{}\terminal{method}({{}\terminal{f}({\variable[K]{Parameters}},{\variable[K]{Body}},{\variable[K]{RetType}},{\variable[Loc]{L}})},{\variable[K]{V}},{\variable[Bool]{StaticOrNot}})}\right)}\terminal{/}{\variable[String]{FName}}]}},{\AnyVar[K]})}
}{{{}\terminal{getKLabel}{\left({\variable[K]{Body}}\right)}}\mathrel{=_{\it KLabel}}{'ListWrap}}{}{}{}
\end{module}
\begin{module}{\moduleName{OBJECTS}}

\begin{syntaxBlock}{\nonTerminal{\sort{Id}}}\syntax{{}\terminal{stdclass}}{}
\end{syntaxBlock}
\krule{
\reduce{\constant[\#String]{"stdclass"}}{\constant[\#String]{"stdClass"}}}{}{}{\kattribute{function}, \kattribute{anywhere}}{}
\krule{
\reduce{{}\terminal{stdclass}}{{}\terminal{stdClass}}}{}{}{\kattribute{function}, \kattribute{anywhere}}{}
\begin{kblock}[text]
 \section{Object creation} \end{kblock}
\begin{kblock}[text]
 \subsection{This} \end{kblock}
\krule[this-obj-cntx]{
\kprefix{k}{\reduce{{}\terminal{var}({\variable[Id]{X}})}{{}\terminal{thisTag}({\variable[Loc]{L}})}}
\mathrel{}\kall{object}{\variable[Loc]{L}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"this-obj-cntx"}}}
}{{{}\terminal{Id2String}({\variable[Id]{X}})}\terminal{==String}{\constant[\#String]{"this"}}}{}{\kattribute{step}}{}
\krule[this-no-obj-cntx]{
\kprefix{k}{\reduce{{}\terminal{var}({\variable[Id]{X}})}{{}\terminal{thisTag}({{}\terminal{NULL}})}}
\mathrel{}\kall{object}{\dotCt{K}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"this-no-obj-cntx"}}}
}{{{}\terminal{Id2String}({\variable[Id]{X}})}\terminal{==String}{\constant[\#String]{"this"}}}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \subsection{Object creation (new construct)} \end{kblock}
\begin{kblock}[text]
 Surface syntax  \end{kblock}
\krule{
\reduce{isKResult(\variable[Id]{X})}{\constant[\#Bool]{true}}}{}{}{}{}
\kcontext{
'ObjectCreation(\khole{}\kcomma\AnyVar[KList])}{}{}{}
\krule[obj-creation-className2LangValue]{
\kprefix{k}{'ObjectCreation(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}\kcomma\AnyVar[KList])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"obj-creation-className2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[obj-creation-className2Id]{
\kprefix{k}{'ObjectCreation(\reduce{\variable[String]{Name}}{{}\terminal{String2Id}({\variable[String]{Name}})}\kcomma\AnyVar[KList])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"obj-creation-className2Id"}}}
}{}{}{\kattribute{intermediate}}{}
\krule{
\reduce{'ObjectCreation(\variable[K]{ClassName})}{'ObjectCreation(\variable[K]{ClassName}\kcomma'ListWrap())}}{}{}{}{}
\krule[obj-creation]{
\kprefix{k}{\reduce{'ObjectCreation(\variable[Id]{ClassName}\kcomma\variable[K]{Args})}{{}\terminal{Literal}({'ObjectCreation(\variable[Id]{ClassName}\kcomma\variable[K]{Args})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"obj-creation"}}}
}{}{}{\kattribute{step}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{makeNewObject}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{K}}}})}{\kattribute{strict}(1)}
\end{syntaxBlock}
\krule[make-new-obj]{
\kprefix{k}{\reduce{{}\terminal{makeNewObject}({\variable[Loc]{L1}},{\variable[Id]{ClassName}},{\variable[K]{ConstructArgs}})}{{}\terminal{ArrayCreateEmpty}({\variable[Loc]{L}})\kra{}\terminal{\#objectInit}({\variable[Loc]{L}},{\variable[Id]{ClassName}})\kra{}\terminal{copyValueToLoc}({{}\terminal{OID}({\variable[Loc]{L}},{\variable[Id]{ClassName}},{\constant[\#Int]{0}})},{\variable[Loc]{L1}})\kra{}\terminal{\#allocAndRunConstructor}({\variable[Loc]{L1}},{\variable[K]{ConstructArgs}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"make-new-obj"}}}
}{{}\terminal{fresh}({\variable[Loc]{L}})}{}{\kattribute{internal}, \kattribute{mem}}{}
\begin{kblock}[text]
 \subsection{Initialization of the object data structure} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#objectInit}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{Id}}}})}{}
\end{syntaxBlock}
\krule[obj-init]{
\kprefix{k}{\reduce{{}\terminal{\#objectInit}({\variable[Loc]{L}},{\variable[K]{ClassName}})}{{}\terminal{\#buildObjElemList}({\variable[Loc]{L}},{\variable[K]{ClassName}},{\variable[List]{PropList}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\dotCt{List}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kmiddle{classes}{\variable[K]{ClassName}\mapsto{}\terminal{class}({\AnyVar[K]},{\variable[List]{PropList}},{\AnyVar[Map]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"obj-init"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#buildObjElemList}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{List}}}})}{}
\end{syntaxBlock}
\krule[built-obj-prop-list-parent]{
\kprefix{k}{\reduce{{}\terminal{\#buildObjElemList}({\variable[K]{L}},{\variable[K]{ClassName}},{\dotCt{List}})}{{}\terminal{\#buildObjElemList}({\variable[K]{L}},{\variable[K]{Parent}},{\variable[List]{PropList}})}}
\mathrel{}\kmiddle{classes}{\variable[K]{ClassName}\mapsto{}\terminal{class}({\variable[K]{Parent}},{\AnyVar[List]},{\AnyVar[Map]},{\AnyVar[K]})\mathrel{}\variable[K]{Parent}\mapsto{}\terminal{class}({\AnyVar[K]},{\variable[List]{PropList}},{\AnyVar[Map]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"built-obj-prop-list-parent"}}}
}{}{}{\kattribute{internal}}{}
\krule[built-obj-prop-list-root]{
\kprefix{k}{\reduce{{}\terminal{\#buildObjElemList}({\variable[K]{L}},{\variable[Id]{ClassName}},{\dotCt{List}})}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"built-obj-prop-list-root"}}}
}{\left({{{}\terminal{Id2String}({\variable[Id]{ClassName}})}\terminal{==String}{\constant[\#String]{"stdClass"}}}\right)}{}{\kattribute{internal}}{}
\kcontext{
{}\terminal{\#buildObjElemList}({\variable[K]{L}},{\variable[K]{ClassName}},{{}\terminal{prop}({\variable[K]{X}},{\AnyVar[K]},{\khole{}})\mathrel{}\variable[List]{Items}})}{}{}{\kattribute{structural}}
\krule[built-obj-prop-list-non-private-add]{
\kprefix{k}{\reduce{{}\terminal{\#buildObjElemList}({\variable[K]{L}},{\variable[K]{ClassName}},{{}\terminal{prop}({\variable[K]{X}},{\variable[K]{Visib}},{\variable[Value]{V}})\mathrel{}\variable[List]{Items}})}{{}\terminal{ArrayCreateElem}({\variable[K]{L}},{\variable[K]{X}},{\variable[K]{Visib}},{{}\terminal{allocValue}({\variable[Value]{V}})})\kra{}\terminal{\#buildObjElemList}({\variable[K]{L}},{\variable[K]{ClassName}},{\variable[List]{Items}})}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{ObjItems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"built-obj-prop-list-non-private-add"}}}
}{{\left({\neg_{\scriptstyle\it Bool}{{\variable[List]{ObjItems}}\terminal{hasProperty}{\variable[K]{X}}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{{\variable[K]{Visib}}\mathrel{=_K}{{}\terminal{none}}}\vee_{\scriptstyle\it Bool}{{\variable[K]{Visib}}\mathrel{=_K}{{}\terminal{pro}}}}\right)}}{}{\kattribute{internal}}{}
\krule[built-obj-prop-list-non-private-skip]{
\kprefix{k}{\reduce{{}\terminal{\#buildObjElemList}({\variable[K]{L}},{\variable[K]{ClassName}},{{}\terminal{prop}({\variable[K]{X}},{\variable[K]{Visib}},{\AnyVar[K]})\mathrel{}\variable[List]{Items}})}{{}\terminal{\#buildObjElemList}({\variable[K]{L}},{\variable[K]{ClassName}},{\variable[List]{Items}})}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{ObjItems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"built-obj-prop-list-non-private-skip"}}}
}{{\left({{\variable[List]{ObjItems}}\terminal{hasProperty}{\variable[K]{X}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{{\variable[K]{Visib}}\mathrel{=_K}{{}\terminal{none}}}\vee_{\scriptstyle\it Bool}{{\variable[K]{Visib}}\mathrel{=_K}{{}\terminal{pro}}}}\right)}}{}{\kattribute{internal}}{}
\krule[built-obj-prop-list-private]{
\kprefix{k}{\reduce{{}\terminal{\#buildObjElemList}({\variable[K]{L}},{\variable[K]{ClassName}},{{}\terminal{prop}({\variable[K]{X}},{{}\terminal{pri}({\variable[K]{ClassName}})},{\variable[Value]{V}})\mathrel{}\variable[List]{Items}})}{{}\terminal{ArrayCreateElem}({\variable[K]{L}},{\variable[K]{X}},{{}\terminal{pri}({\variable[K]{ClassName}})},{{}\terminal{allocValue}({\variable[Value]{V}})})\kra{}\terminal{\#buildObjElemList}({\variable[K]{L}},{\variable[K]{ClassName}},{\variable[List]{Items}})}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{ObjItems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"built-obj-prop-list-private"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Object field access} \end{kblock}
\kcontext{
'ObjectAccess(\khole{}\kcomma\AnyVar[K])}{}{}{\kattribute{structural}}
\kcontext{
'ObjectAccess(\AnyVar[K]\kcomma\khole{})}{}{}{\kattribute{structural}}
\krule[obj-access-RHS2LangValue]{
\kprefix{k}{'ObjectAccess(\AnyVar[K]\kcomma\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"obj-access-RHS2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{ThisOrLiteral}}}\syntax{{\nonTerminal{\sort{ThisTag}}}}{}\syntaxCont{{\nonTerminal{\sort{LiteralValue}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{ConvertibleToLoc}}}\syntax{{\nonTerminal{\sort{ThisOrLiteral}}}}{}
\end{syntaxBlock}
\krule[obj-access-RHS2Loc-ThisOrLiteral]{
\kprefix{k}{'ObjectAccess(\reduce{\variable[ThisOrLiteral]{V}}{{}\terminal{convertToLoc}({\variable[ThisOrLiteral]{V}},{{}\terminal{r}})}\kcomma\AnyVar[KList])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"obj-access-RHS2Loc-ThisOrLiteral"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[obj-access-nested]{
\kprefix{k}{\reduce{'ObjectAccess(\variable[Ref]{R}\kcomma\variable[Key]{K})}{{}\terminal{lref}({\variable[Ref]{R}},{\variable[Key]{K}},{{}\terminal{obj}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"obj-access-nested"}}}
}{}{}{\kattribute{step}}{}
\krule[obj-access-simple]{
\kprefix{k}{\reduce{'ObjectAccess(\variable[Loc]{L}\kcomma\variable[Key]{K})}{{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{K}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"obj-access-simple"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \subsection{Object Property} \end{kblock}
\kcontext{
'ObjectProperty('Variable('Braced(\khole{})))}{}{}{}
\krule{
\reduce{'ObjectProperty('Variable('Braced(\variable[Value]{V})))}{\variable[Value]{V}}}{}{}{}{}
\krule{
'ObjectProperty('Variable(\reduce{'Braced(\variable[ConvertibleToLanguageValue]{V})}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{V}})}))}{}{}{}{}
\krule{
\reduce{'ObjectProperty('Simple(\variable[Value]{V}))}{\variable[Value]{V}}}{}{}{}{}
\krule{
\reduce{'ObjectProperty('Variable('Simple(\variable[String]{X})))}{'Variable('Simple(\variable[String]{X}))}}{}{}{}{}
\begin{kblock}[text]
 \subsection{Method Call} \end{kblock}
\kcontext{
'FunctionCall(\AnyVar[K]\kcomma\khole{}\kcomma\AnyVar[K])}{}{}{\kattribute{structural}}
\kcontext{
'FunctionCall(\khole{}\kcomma\AnyVar[K]\kcomma\AnyVar[K])}{}{}{\kattribute{structural}}
\krule[meth-call-obj2Loc]{
\kprefix{k}{'FunctionCall(\left({\reduce{\variable[ConvertibleToLoc]{R}}{{}\terminal{convertToLoc}({\variable[ConvertibleToLoc]{R}},{{}\terminal{r}})}\kcomma\AnyVar[K]\kcomma\AnyVar[K]}\right))}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"meth-call-obj2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[meth-call-name2LangValue]{
\kprefix{k}{'FunctionCall(\AnyVar[K]\kcomma\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}\kcomma\AnyVar[K])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"meth-call-name2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[meth-call]{
\kprefix{k}{\reduce{'FunctionCall(\variable[K]{L}\kcomma\variable[String]{MethodName}\kcomma'ListWrap(\variable[KList]{Args}))}{{}\terminal{\#methRunIfVisible}({{}\terminal{\#methodLookup}({\variable[Id]{ObjClass}},{\variable[String]{MethodName}})},{'ListWrap(\variable[KList]{Args})},{\variable[K]{L}})}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[Loc]{L1}},{\variable[Id]{ObjClass}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"meth-call"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \section{Auxiliary operations for method call} \end{kblock}
\begin{kblock}[text]
 \subsection{Method Lookup} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#methodLookup}({{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{String}}}})}{}\syntaxCont{{}\terminal{methodInfo}({{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{String}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{Bool}}}})}{}\syntaxCont{{}\terminal{MethodNotFound}}{}
\end{syntaxBlock}
\krule{
\reduce{isKResult({}\terminal{methodInfo}({\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]}))}{\constant[\#Bool]{true}}}{}{}{}{}
\krule[meth-lookup-found]{
\kprefix{k}{\reduce{{}\terminal{\#methodLookup}({\variable[Id]{ClassName}},{\variable[String]{MethName}})}{{}\terminal{methodInfo}({\variable[Id]{ClassName}},{\variable[String]{MethName}},{\variable[OptionArrayItemVisibility]{Visibility}},{\variable[Bool]{Static}})}}
\mathrel{}\kmiddle{classes}{\variable[Id]{ClassName}\mapsto{}\terminal{class}({\AnyVar[K]},{\AnyVar[List]},{\variable[Map]{Meths}\mathrel{}\left({\variable[String]{MethName}\mapsto{}\terminal{method}({\AnyVar[K]},{\variable[OptionArrayItemVisibility]{Visibility}},{\variable[Bool]{Static}})}\right)},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"meth-lookup-found"}}}
}{}{}{\kattribute{internal}}{}
\krule[meth-lookup-parent]{
\kprefix{k}{\reduce{{}\terminal{\#methodLookup}({\variable[Id]{ClassName}},{\variable[String]{MethName}})}{{}\terminal{\#methodLookup}({\variable[Id]{Parent}},{\variable[String]{MethName}})}}
\mathrel{}\kmiddle{classes}{\variable[Id]{ClassName}\mapsto{}\terminal{class}({\variable[Id]{Parent}},{\AnyVar[List]},{\variable[Map]{Meths}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"meth-lookup-parent"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[String]{MethName}}\terminal{in}{{}\terminal{keys}{\left({\variable[Map]{Meths}}\right)}}}\right)}}{}{\kattribute{internal}}{}
\krule[meth-lookup-not-found]{
\kprefix{k}{\reduce{{}\terminal{\#methodLookup}({{}\terminal{ROOT}},{\variable[String]{MethName}})}{{}\terminal{MethodNotFound}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"meth-lookup-not-found"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Run the method is visibility constraints are met} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#methRunIfVisible}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{OptionLoc}}}})}{\kattribute{strict}(1)}
\end{syntaxBlock}
\krule[meth-run-if-visib-non-static]{
\kprefix{k}{\reduce{{}\terminal{\#methRunIfVisible}({{}\terminal{methodInfo}({\variable[Id]{Class}},{\variable[String]{Name}},{\variable[OptionArrayItemVisibility]{Visibility}},{\constant[\#Bool]{false}})},{\variable[K]{Args}},{\variable[K]{Obj}})}{{}\terminal{*Cond}({{}\terminal{\#isVisible}({\variable[Id]{Class}},{\variable[K]{CurrentClass}},{\variable[OptionArrayItemVisibility]{Visibility}})},{{}\terminal{\#methExecute}({\variable[Id]{Class}},{\variable[String]{Name}},{\variable[K]{Args}},{\variable[K]{Obj}})},{\constant[\#Int]{99}})}}
\mathrel{}\kall{class}{\variable[K]{CurrentClass}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"meth-run-if-visib-non-static"}}}
}{}{}{\kattribute{internal}}{}
\krule[meth-run-if-visib-static]{
\kprefix{k}{\reduce{{}\terminal{\#methRunIfVisible}({{}\terminal{methodInfo}({\variable[Id]{Class}},{\variable[String]{Name}},{\variable[OptionArrayItemVisibility]{Visibility}},{\constant[\#Bool]{true}})},{\variable[K]{Args}},{\variable[K]{Obj}})}{{}\terminal{*Cond}({{}\terminal{\#isVisible}({\variable[Id]{Class}},{\variable[K]{CurrentClass}},{\variable[OptionArrayItemVisibility]{Visibility}})},{{}\terminal{\#methExecute}({\variable[Id]{Class}},{\variable[String]{Name}},{\variable[K]{Args}},{{}\terminal{none}})},{\constant[\#Int]{99}})}}
\mathrel{}\kall{class}{\variable[K]{CurrentClass}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"meth-run-if-visib-static"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Run a method} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#methExecute}({{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{String}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{OptionLoc}}}})}{}
\end{syntaxBlock}
\krule[meth-exec]{
\kprefix{k}{\reduce{{}\terminal{\#methExecute}({\variable[Id]{Class}},{\variable[String]{MethName}},{\variable[K]{Args}},{\variable[OptionLoc]{Obj}})}{{}\terminal{\#runFunction}({\variable[String]{MethName}},{\variable[K]{FunDef}},{\variable[K]{Static}},{\variable[K]{Args}},{\variable[Id]{Class}},{\variable[OptionLoc]{Obj}})}}
\mathrel{}\kmiddle{classes}{\variable[Id]{Class}\mapsto{}\terminal{class}({\AnyVar[K]},{\AnyVar[List]},{\variable[Map]{Meths}\mathrel{}\left({\variable[String]{MethName}\mapsto{}\terminal{method}({\variable[K]{FunDef}},{\AnyVar[K]},{\variable[K]{Static}})}\right)},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"meth-exec"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Running a constructor} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#allocAndRunConstructor}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[run-constructor-old]{
\kprefix{k}{\reduce{{}\terminal{\#allocAndRunConstructor}({\variable[K]{L}},{\variable[K]{Args}})}{'Expr('FunctionCall(\variable[K]{L}\kcomma{}\terminal{Id2String}({\variable[K]{ClassName}})\kcomma\variable[K]{Args}))}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\AnyVar[K]},{\variable[K]{ClassName}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kmiddle{classes}{\variable[K]{ClassName}\mapsto{}\terminal{class}({\AnyVar[K]},{\AnyVar[List]},{\variable[Map]{Meths}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"run-constructor-old"}}}
}{\left({{{}\terminal{Id2String}({\variable[K]{ClassName}})}\terminal{in}{{}\terminal{keys}{\left({\variable[Map]{Meths}}\right)}}}\right)}{}{\kattribute{internal}}{}
\krule[run-constructor-PHP-5]{
\kprefix{k}{\reduce{{}\terminal{\#allocAndRunConstructor}({\variable[K]{L}},{\variable[K]{Args}})}{'Expr('FunctionCall(\variable[K]{L}\kcomma\constant[\#String]{"\_\_construct"}\kcomma\variable[K]{Args}))}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\AnyVar[K]},{\variable[K]{ClassName}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kmiddle{classes}{\variable[K]{ClassName}\mapsto{}\terminal{class}({\AnyVar[K]},{\AnyVar[List]},{\variable[Map]{Meths}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"run-constructor-PHP-5"}}}
}{\left({{\constant[\#String]{"\_\_construct"}}\terminal{in}{{}\terminal{keys}{\left({\variable[Map]{Meths}}\right)}}}\right)}{}{\kattribute{internal}}{}
\krule[run-constructor-none]{
\kprefix{k}{\reduce{{}\terminal{\#allocAndRunConstructor}({\variable[K]{L}},{\variable[K]{Args}})}{\dotCt{K}}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\AnyVar[K]},{\variable[K]{ClassName}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kmiddle{classes}{\variable[K]{ClassName}\mapsto{}\terminal{class}({\AnyVar[K]},{\AnyVar[List]},{\variable[Map]{Meths}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"run-constructor-none"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{{}\terminal{Id2String}({\variable[K]{ClassName}})}\terminal{in}{{}\terminal{keys}{\left({\variable[Map]{Meths}}\right)}}}\right)}}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \section{Auxiliary stuff for Objects} \end{kblock}
\begin{kblock}[text]
 \subsection{isVisible} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#isVisible}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{OptionArrayItemVisibility}}}})}{}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{\#isVisible}({\AnyVar[K]},{\AnyVar[K]},{{}\terminal{none}})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isVisible}({\variable[K]{ObjClass}},{\dotCt{K}},{{}\terminal{pro}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isVisible}({\variable[K]{ObjClass}},{\dotCt{K}},{{}\terminal{pri}({\AnyVar[K]})})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isVisible}({\variable[Id]{Context}},{\variable[Id]{Context}},{{}\terminal{pri}({\AnyVar[K]})})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isVisible}({\variable[K]{ObjClass}},{\variable[Id]{Context}},{{}\terminal{pri}({\AnyVar[K]})})}{\constant[\#Bool]{false}}}{\left({{\variable[K]{ObjClass}}\mathrel{\neq_K}{\variable[Id]{Context}}}\right)}{}{}{}
\krule{
\reduce{{}\terminal{\#isVisible}({\variable[Id]{ObjClass}},{\variable[Id]{Context}},{{}\terminal{pro}})}{{}\terminal{*or}({{}\terminal{\#isSuperclass}({\variable[Id]{Context}},{\variable[Id]{ObjClass}})},{{}\terminal{\#isSubclass}({\variable[Id]{Context}},{\variable[Id]{ObjClass}})})}}{}{}{}{}
\begin{kblock}[text]
 \subsection{isInPath} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#isInPath}({{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{Id}}}})}{}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{\#isInPath}({\variable[Id]{Root}},{\AnyVar[K]})}{\constant[\#Bool]{false}}}{{{}\terminal{Id2String}({\variable[Id]{Root}})}\terminal{==String}{\constant[\#String]{"ROOT"}}}{}{}{}
\krule{
\reduce{{}\terminal{\#isInPath}({\variable[Id]{Origin}},{\variable[Id]{Root}})}{\constant[\#Bool]{true}}}{{{}\terminal{Id2String}({\variable[Id]{Root}})}\terminal{==String}{\constant[\#String]{"ROOT"}}}{}{}{}
\krule{
\reduce{{}\terminal{\#isInPath}({\variable[Id]{Origin}},{\variable[Id]{Origin}})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\kprefix{k}{\reduce{{}\terminal{\#isInPath}({\variable[Id]{Origin}},{\variable[Id]{Dest}})}{{}\terminal{\#isInPath}({\variable[Id]{Parent}},{\variable[Id]{Dest}})}}
\mathrel{}\kmiddle{classes}{\variable[Id]{Origin}\mapsto{}\terminal{class}({\variable[Id]{Parent}},{\AnyVar[List]},{\AnyVar[Map]},{\AnyVar[K]})}
}{}{}{}{}
\begin{kblock}[text]
 \subsection{isSubclass and isSuperclass} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#isSubclass}({{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{Id}}}})}{}\syntaxCont{{}\terminal{\#isSuperclass}({{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{Id}}}})}{}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{\#isSubclass}({\variable[Id]{Origin}},{\variable[Id]{Dest}})}{{}\terminal{\#isInPath}({\variable[Id]{Origin}},{\variable[Id]{Dest}})}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isSuperclass}({\variable[Id]{Origin}},{\variable[Id]{Dest}})}{{}\terminal{\#isInPath}({\variable[Id]{Dest}},{\variable[Id]{Origin}})}}{}{}{}{}
\end{module}
\begin{module}{\moduleName{ARRAYS}}
\begin{kblock}[text]
 \section{Array literal} \end{kblock}
\begin{kblock}[text]
 \subsection{Surface syntax} \end{kblock}
\krule[array-literal]{
\kprefix{k}{\reduce{'Array(\variable[K]{Elems})}{{}\terminal{Literal}({'Array(\variable[K]{Elems})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-literal"}}}
}{}{}{\kattribute{structural}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{makeArrayLiteral}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{K}}}})}{\kattribute{strict}(1)}
\end{syntaxBlock}
\kcontext{
{}\terminal{makeArrayLiteral}({\AnyVar[K]},{'ListWrap(\AnyVar[KList]\kcomma\khole{}\kcomma\AnyVar[KList])})}{}{}{}
\kcontext{
'Pair('Some('Key(\khole{}))\kcomma\AnyVar[K])}{}{}{}
\kcontext{
'Pair(\AnyVar[K]\kcomma'Value(\khole{}))}{}{}{}
\kcontext{
'Pair(\AnyVar[K]\kcomma'RefValue(\khole{}))}{}{}{}
\krule{
\reduce{isKResult('Pair('Some('Key(\variable[KResult]{K}))\kcomma'Value(\variable[KResult]{V})))}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{isKResult('Pair('None(\AnyVar[KList])\kcomma'Value(\variable[KResult]{V})))}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{isKResult('Pair('Some('Key(\variable[KResult]{K}))\kcomma'RefValue(\variable[KResult]{V})))}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{isKResult('Pair('None(\AnyVar[KList])\kcomma'RefValue(\variable[KResult]{V})))}{\constant[\#Bool]{true}}}{}{}{}{}
\krule[make-array-literal]{
\kprefix{k}{\reduce{{}\terminal{makeArrayLiteral}({\variable[Loc]{L}},{'ListWrap(\variable[KList]{KVs})})}{{}\terminal{ArrayCreateEmpty}({\variable[Loc]{L}})\kra{}\terminal{ArrayInitProps}({\variable[Loc]{L}},{'ListWrap(\variable[KList]{KVs})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"make-array-literal"}}}
}{isKResult(\variable[KList]{KVs})}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 Initialise an array property \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{ArrayInitProps}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[array-init-props-nil]{
\kprefix{k}{\reduce{{}\terminal{ArrayInitProps}({\variable[Loc]{L}},{'ListWrap()})}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-init-props-nil"}}}
}{}{}{\kattribute{internal}}{}
\krule[array-init-props-cons]{
\kprefix{k}{\reduce{{}\terminal{ArrayInitProps}({\variable[Loc]{L}},{'ListWrap(\variable[K]{Kv}\kcomma\variable[KList]{KVs})})}{{}\terminal{ArrayInitProp}({\variable[Loc]{L}},{\variable[K]{Kv}})\kra{}\terminal{ArrayInitProps}({\variable[Loc]{L}},{'ListWrap(\variable[KList]{KVs})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-init-props-cons"}}}
}{}{}{\kattribute{intermediate}}{}
\begin{kblock}[text]
 Initialize a list of array properties \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{ArrayInitProp}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[array-init-prop-key]{
\kprefix{k}{\reduce{{}\terminal{ArrayInitProp}({\variable[Loc]{L}},{'Pair('Some('Key(\variable[Value]{X}))\kcomma'Value(\variable[KResult]{V}))})}{'Expr('Assign('ArrayAccess(\variable[Loc]{L}\kcomma\variable[Value]{X})\kcomma\variable[KResult]{V}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-init-prop-key"}}}
}{}{}{\kattribute{internal}}{}
\krule[array-init-prop-key-ref]{
\kprefix{k}{\reduce{{}\terminal{ArrayInitProp}({\variable[Loc]{L}},{'Pair('Some('Key(\variable[Value]{X}))\kcomma'RefValue(\variable[KResult]{V}))})}{'Expr('ReferenceAssign('ArrayAccess(\variable[Loc]{L}\kcomma\variable[Value]{X})\kcomma\variable[KResult]{V}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-init-prop-key-ref"}}}
}{}{}{\kattribute{internal}}{}
\krule[array-init-prop-def-key]{
\kprefix{k}{\reduce{{}\terminal{ArrayInitProp}({\variable[Loc]{L}},{'Pair('None(\AnyVar[KList])\kcomma'Value(\variable[KResult]{V}))})}{'Expr('Assign({}\terminal{ref}({\variable[Loc]{L}},{{{}\terminal{biggestIntKey}({\variable[List]{Elems}})}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})\kcomma\variable[KResult]{V}))}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-init-prop-def-key"}}}
}{}{}{\kattribute{internal}}{}
\krule[array-init-prop-def-key-ref]{
\kprefix{k}{\reduce{{}\terminal{ArrayInitProp}({\variable[Loc]{L}},{'Pair('None(\AnyVar[KList])\kcomma'RefValue(\variable[KResult]{V}))})}{'Expr('ReferenceAssign({}\terminal{ref}({\variable[Loc]{L}},{{{}\terminal{biggestIntKey}({\variable[List]{Elems}})}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})\kcomma\variable[KResult]{V}))}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-init-prop-def-key-ref"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Arrays internal functions} \end{kblock}
\kcontext{
'InternalFunction('Empty(\khole{}))}{}{}{}
\krule[empty-arg2LangValue]{
\kprefix{k}{'InternalFunction('Empty(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}))}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"empty-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[empty-not-array]{
\kprefix{k}{\reduce{'InternalFunction('Empty(\variable[Value]{V}))}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"empty-not-array"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isArrayType}({\variable[Value]{V}})}\right)}}{}{\kattribute{step}}{}
\krule[empty-true]{
\kprefix{k}{\reduce{'InternalFunction('Empty({}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})))}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"empty-true"}}}
}{{\variable[List]{Elems}}\terminal{==List}{\dotCt{List}}}{}{}{}
\krule[empty-false]{
\kprefix{k}{\reduce{'InternalFunction('Empty({}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})))}{\constant[\#Bool]{false}}}
}{{\variable[List]{Elems}}\terminal{=/=List}{\dotCt{List}}}{}{}{}
\end{module}
\begin{module}{\moduleName{MEMORY}}
\begin{kblock}[text]
 \section{Memory representation and low-level operations} \end{kblock}
\begin{kblock}[text]
 \subsection{Values} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{LanguageValue}}}\syntax{{\nonTerminal{\sort{PlainLanguageValue}}}}{}\syntaxCont{{\nonTerminal{\sort{LiteralValue}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{PlainLanguageValue}}}\syntax{{\nonTerminal{\sort{ScalarValue}}}}{}\syntaxCont{{\nonTerminal{\sort{CompoundValue}}}}{}\syntaxCont{{\nonTerminal{\sort{SpecialValue}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{ScalarValue}}}\syntax{{\nonTerminal{\sort{Bool}}}}{}\syntaxCont{{\nonTerminal{\sort{Int}}}}{}\syntaxCont{{\nonTerminal{\sort{Float}}}}{}\syntaxCont{{\nonTerminal{\sort{String}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{CompoundValue}}}\syntax{{\nonTerminal{\sort{Object}}}}{}\syntaxCont{{\nonTerminal{\sort{Array}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{Null}}}\syntax{{}\terminal{NULL}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{SpecialValue}}}\syntax{{\nonTerminal{\sort{Null}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{Object}}}\syntax{{}\terminal{OID}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{Int}}}})}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{Array}}}\syntax{{}\terminal{Array}({{\nonTerminal{\sort{OptionArrayItem}}}},{{\nonTerminal{\sort{List}}}})}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{ArrayItem}}}\syntax{[{{\nonTerminal{\sort{Key}}}},{{\nonTerminal{\sort{OptionArrayItemVisibility}}}},{{\nonTerminal{\sort{Loc}}}}]}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{ArrayItemVisibility}}}\syntax{{}\terminal{pro}}{}\syntaxCont{{}\terminal{pri}({{\nonTerminal{\sort{Id}}}})}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{Key}}}\syntax{{\nonTerminal{\sort{Int}}}}{}\syntaxCont{{\nonTerminal{\sort{String}}}}{}\syntaxCont{{\nonTerminal{\sort{SpecialValue}}}}{}
\end{syntaxBlock}
\krule{
\reduce{isKResult(\variable[Key]{K})}{\constant[\#Bool]{true}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{SemanticValue}}}\syntax{{\nonTerminal{\sort{Loc}}}}{}\syntaxCont{{\nonTerminal{\sort{Ref}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{Loc}}}\syntax{{}\terminal{locNull}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{RefType}}}\syntax{{}\terminal{arr}}{}\syntaxCont{{}\terminal{obj}}{}\syntaxCont{{}\terminal{nul}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{Ref}}}\syntax{{\nonTerminal{\sort{BasicRef}}}}{}\syntaxCont{{\nonTerminal{\sort{LRef}}}}{}\syntaxCont{{}\terminal{refNull}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{BasicRef}}}\syntax{{}\terminal{ref}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{Key}}}})}{\kattribute{strict}(1), \kattribute{klabel}('ref)}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{LRef}}}\syntax{{}\terminal{lref}({{\nonTerminal{\sort{Ref}}}},{{\nonTerminal{\sort{Key}}}},{{\nonTerminal{\sort{RefType}}}})}{\kattribute{strict}(1), \kattribute{klabel}('lref)}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{LiteralValue}}}\syntax{{}\terminal{Literal}({{\nonTerminal{\sort{K}}}})}{\kattribute{klabel}('lit)}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{Value}}}\syntax{{\nonTerminal{\sort{LanguageValue}}}}{}\syntaxCont{{\nonTerminal{\sort{SemanticValue}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KResult}}}\syntax{{\nonTerminal{\sort{Value}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{None}}}\syntax{{}\terminal{none}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{OptionId}}}\syntax{{\nonTerminal{\sort{Id}}}}{}\syntaxCont{{\nonTerminal{\sort{None}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{OptionLoc}}}\syntax{{\nonTerminal{\sort{Loc}}}}{}\syntaxCont{{\nonTerminal{\sort{None}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{OptionInt}}}\syntax{{\nonTerminal{\sort{Int}}}}{}\syntaxCont{{\nonTerminal{\sort{None}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{OptionString}}}\syntax{{\nonTerminal{\sort{String}}}}{}\syntaxCont{{\nonTerminal{\sort{None}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{OptionArrayItem}}}\syntax{{\nonTerminal{\sort{ArrayItem}}}}{}\syntaxCont{{\nonTerminal{\sort{None}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{OptionArrayItemVisibility}}}\syntax{{\nonTerminal{\sort{ArrayItemVisibility}}}}{}\syntaxCont{{\nonTerminal{\sort{None}}}}{}
\end{syntaxBlock}
\begin{kblock}[text]
 \subsection{Types} 
		In the official PHP implementation, the (runtime) type of values is stored in memory. 
		We define here the different types. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Type}}}\syntax{{}\terminal{int}}{}\syntaxCont{{}\terminal{integer}}{}\syntaxCont{{}\terminal{bool}}{}\syntaxCont{{}\terminal{boolean}}{}\syntaxCont{{}\terminal{float}}{}\syntaxCont{{}\terminal{double}}{}\syntaxCont{{}\terminal{real}}{}\syntaxCont{{}\terminal{string}}{}\syntaxCont{{}\terminal{array}}{}\syntaxCont{{}\terminal{object}}{}\syntaxCont{{}\terminal{unset}}{}
\end{syntaxBlock}
\begin{kblock}[text]
 For semantic purposes, we actually need types to be considered as values. For clarity we 
	choose not to directly add types to the set of values, but instead we just add the following 
	line, telling the \K tool that a type is to be considered as a KResult, i.e something which 
	cannot reduce anymore. \end{kblock}
\krule{
\reduce{isKResult(\variable[Type]{T})}{\constant[\#Bool]{true}}}{}{}{}{}
\begin{kblock}[text]
 We define here some helper predicates that will make the semantic rules more concise. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{\#isArrayType}({{\nonTerminal{\sort{Value}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{\#isArrayType}({\variable[Array]{V}})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isArrayType}({\variable[ScalarValue]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isArrayType}({\variable[Object]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isArrayType}({\variable[SpecialValue]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{\#isFloatType}({{\nonTerminal{\sort{Value}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{\#isFloatType}({\variable[Array]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isFloatType}({\variable[Bool]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isFloatType}({\variable[Int]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isFloatType}({\variable[Float]{V}})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isFloatType}({\variable[String]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isFloatType}({\variable[Object]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isFloatType}({\variable[SpecialValue]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{\#isIntType}({{\nonTerminal{\sort{Value}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{\#isIntType}({\variable[Array]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isIntType}({\variable[Bool]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isIntType}({\variable[Int]{V}})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isIntType}({\variable[Float]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isIntType}({\variable[String]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isIntType}({\variable[Object]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isIntType}({\variable[SpecialValue]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{\#isBoolType}({{\nonTerminal{\sort{Value}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{\#isBoolType}({\variable[Array]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isBoolType}({\variable[Bool]{V}})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isBoolType}({\variable[Int]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isBoolType}({\variable[Float]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isBoolType}({\variable[String]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isBoolType}({\variable[Object]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isBoolType}({\variable[SpecialValue]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{\#isStringType}({{\nonTerminal{\sort{Value}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{\#isStringType}({\variable[Array]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isStringType}({\variable[Bool]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isStringType}({\variable[Int]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isStringType}({\variable[Float]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isStringType}({\variable[String]{V}})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isStringType}({\variable[Object]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isStringType}({\variable[SpecialValue]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isStringType}({\variable[LiteralValue]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{\#isObjectType}({{\nonTerminal{\sort{Value}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{\#isObjectType}({\variable[Array]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isObjectType}({\variable[Bool]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isObjectType}({\variable[Int]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isObjectType}({\variable[Float]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isObjectType}({\variable[String]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isObjectType}({\variable[Object]{V}})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#isObjectType}({\variable[SpecialValue]{V}})}{\constant[\#Bool]{false}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Type}}}\syntax{{}\terminal{\#typeOf}({{\nonTerminal{\sort{Value}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{\#typeOf}({\variable[Bool]{V}})}{{}\terminal{bool}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#typeOf}({\variable[Int]{V}})}{{}\terminal{int}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#typeOf}({\variable[Float]{V}})}{{}\terminal{float}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#typeOf}({\variable[String]{V}})}{{}\terminal{string}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#typeOf}({\variable[Object]{V}})}{{}\terminal{object}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#typeOf}({\variable[Array]{V}})}{{}\terminal{array}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#typeOf}({\variable[Object]{V}})}{{}\terminal{object}}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#typeOf}({{}\terminal{NULL}})}{{}\terminal{unset}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{{\nonTerminal{\sort{Value}}}}\terminal{isNumeric}}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{\variable[K]{V}}\terminal{isNumeric}}{{{}\terminal{\#isIntType}({\variable[K]{V}})}\vee_{\scriptstyle\it Bool}{{}\terminal{\#isFloatType}({\variable[K]{V}})}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{{\nonTerminal{\sort{Value}}}}\terminal{isCompoundValue}}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{\variable[K]{V}}\terminal{isCompoundValue}}{{{}\terminal{\#isArrayType}({\variable[K]{V}})}\vee_{\scriptstyle\it Bool}{{}\terminal{\#isObjectType}({\variable[K]{V}})}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{{\nonTerminal{\sort{Value}}}}\terminal{isScalar}}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{\variable[K]{V}}\terminal{isScalar}}{{{{{}\terminal{\#isStringType}({\variable[K]{V}})}\vee_{\scriptstyle\it Bool}{{}\terminal{\#isIntType}({\variable[K]{V}})}}\vee_{\scriptstyle\it Bool}{{}\terminal{\#isFloatType}({\variable[K]{V}})}}\vee_{\scriptstyle\it Bool}{{}\terminal{\#isBoolType}({\variable[K]{V}})}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{hasSameType}({{\nonTerminal{\sort{Value}}}},{{\nonTerminal{\sort{Value}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{hasSameType}({\variable[K]{V1}},{\variable[K]{V2}})}{{{}\terminal{\#typeOf}({\variable[K]{V1}})}\mathrel{=_K}{{}\terminal{\#typeOf}({\variable[K]{V2}})}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{isLiteral}({{\nonTerminal{\sort{ConvertibleToLoc}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{isLiteral}({\variable[K]{V}})}{\constant[\#Bool]{true}}}{\left({{{}\terminal{getKLabel}{\left({\variable[K]{V}}\right)}}\mathrel{=_{\it KLabel}}{'lit}}\right)}{}{}{}
\krule{
\reduce{{}\terminal{isLiteral}({\variable[K]{V}})}{\constant[\#Bool]{false}}}{\left({{{}\terminal{getKLabel}{\left({\variable[K]{V}}\right)}}\mathrel{\neq_{\it KLabel}}{'lit}}\right)}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{locHoldsArray}({{\nonTerminal{\sort{Map}}}},{{\nonTerminal{\sort{Loc}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{locHoldsArray}({\variable[Map]{Mem}\mathrel{}\left({\variable[K]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}\right)},{\variable[K]{L}})}{{}\terminal{\#isArrayType}({\variable[Value]{V}})}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{locHoldsObject}({{\nonTerminal{\sort{Map}}}},{{\nonTerminal{\sort{Loc}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{locHoldsObject}({\variable[Map]{Mem}\mathrel{}\left({\variable[K]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}\right)},{\variable[K]{L}})}{{}\terminal{\#isObjectType}({\variable[Value]{V}})}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{locsHoldSameCompound}({{\nonTerminal{\sort{Map}}}},{{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{Loc}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{locsHoldSameCompound}({\variable[Map]{M}},{\variable[K]{V1}},{\variable[K]{V2}})}{{\left({{{}\terminal{locHoldsArray}({\variable[Map]{M}},{\variable[K]{V1}})}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{locHoldsArray}({\variable[Map]{M}},{\variable[K]{V2}})}\right)}}\right)}\vee_{\scriptstyle\it Bool}{\left({{{}\terminal{locHoldsObject}({\variable[Map]{M}},{\variable[K]{V1}})}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{locHoldsObject}({\variable[Map]{M}},{\variable[K]{V2}})}\right)}}\right)}}}{}{}{}{}
\begin{kblock}[text]
 \subsection{Zvalues} 
		As in the official PHP implementation, values are stored in memory alongside other 
		information, such as the type, the 'refCount' flag and the 'isRef' flag, in a structure
		which is called ZValue, which we define as follows:	 \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Zval}}}\syntax{{}\terminal{zval}({{\nonTerminal{\sort{Value}}}},{{\nonTerminal{\sort{Type}}}},{{\nonTerminal{\sort{Int}}}},{{\nonTerminal{\sort{Bool}}}})}{}
\end{syntaxBlock}
\begin{kblock}[text]
 We also define a number of low-level rules for reading and writing a given field of a 
	ZValue, as well as for creating or destroying them. Those operations will be used as 
	building blocks in the rest of the semantics. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{ZvalField}}}\syntax{{}\terminal{@Value}}{}\syntaxCont{{}\terminal{@Type}}{}\syntaxCont{{}\terminal{@RefCount}}{}\syntaxCont{{}\terminal{@IsRef}}{}
\end{syntaxBlock}
\begin{kblock}[text]
 TODO: try to replace 'K' with 'Loc' (i.e. the real type). Will also need to change 
    the return type of other operations which returns a Loc.  \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#zvalRead}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{ZvalField}}}})}{\kattribute{strict}(1)}
\end{syntaxBlock}
\krule[zval-read-value]{
\kprefix{k}{\reduce{{}\terminal{\#zvalRead}({\variable[K]{L}},{{}\terminal{@Value}})}{\variable[K]{V}}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({\variable[K]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"zval-read-value"}}}
}{}{}{\kattribute{internal}}{}
\krule[zval-read-type]{
\kprefix{k}{\reduce{{}\terminal{\#zvalRead}({\variable[K]{L}},{{}\terminal{@Type}})}{\variable[K]{T}}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({\AnyVar[K]},{\variable[K]{T}},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"zval-read-type"}}}
}{}{}{\kattribute{internal}}{}
\krule[zval-read-refCount]{
\kprefix{k}{\reduce{{}\terminal{\#zvalRead}({\variable[Loc]{L}},{{}\terminal{@RefCount}})}{\variable[Int]{RC}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\AnyVar[K]},{\AnyVar[K]},{\variable[Int]{RC}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"zval-read-refCount"}}}
}{}{}{\kattribute{internal}}{}
\krule[zval-read-isRef]{
\kprefix{k}{\reduce{{}\terminal{\#zvalRead}({\variable[Loc]{L}},{{}\terminal{@IsRef}})}{\variable[Bool]{IR}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\variable[Bool]{IR}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"zval-read-isRef"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{LanguageValueOrType}}}\syntax{{\nonTerminal{\sort{LanguageValue}}}}{}\syntaxCont{{\nonTerminal{\sort{Type}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#zvalWrite}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{ZvalField}}}},{{\nonTerminal{\sort{LanguageValueOrType}}}})}{\kattribute{strict}(1,3)}
\end{syntaxBlock}
\krule[zval-write-value]{
\kprefix{k}{\reduce{{}\terminal{\#zvalWrite}({\variable[K]{L}},{{}\terminal{@Value}},{\variable[LanguageValue]{V}})}{\dotCt{K}}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({\reduce{\AnyVar[K]}{\variable[LanguageValue]{V}}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"zval-write-value"}}}
}{}{}{\kattribute{internal}, \kattribute{mem}}{}
\krule[zval-write-type]{
\kprefix{k}{\reduce{{}\terminal{\#zvalWrite}({\variable[K]{L}},{{}\terminal{@Type}},{\variable[Type]{T}})}{\dotCt{K}}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({\AnyVar[K]},{\reduce{\AnyVar[K]}{\variable[Type]{T}}},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"zval-write-type"}}}
}{}{}{\kattribute{internal}, \kattribute{mem}}{}
\krule[zval-write-refCount]{
\kprefix{k}{\reduce{{}\terminal{\#zvalWrite}({\variable[K]{L}},{{}\terminal{@RefCount}},{\variable[Int]{N}})}{\dotCt{K}}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({\AnyVar[K]},{\AnyVar[K]},{\reduce{\AnyVar[K]}{\variable[Int]{N}}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"zval-write-refCount"}}}
}{}{}{\kattribute{internal}, \kattribute{mem}}{}
\krule[zval-write-isRef]{
\kprefix{k}{\reduce{{}\terminal{\#zvalWrite}({\variable[Loc]{L}},{{}\terminal{@IsRef}},{\variable[Bool]{B}})}{\dotCt{K}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\reduce{\AnyVar[K]}{\variable[Bool]{B}}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"zval-write-isRef"}}}
}{}{}{\kattribute{internal}, \kattribute{mem}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#zvalCreate}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{Value}}}},{{\nonTerminal{\sort{Type}}}},{{\nonTerminal{\sort{Int}}}},{{\nonTerminal{\sort{Bool}}}})}{}
\end{syntaxBlock}
\krule[zval-create]{
\kprefix{k}{\reduce{{}\terminal{\#zvalCreate}({\variable[Loc]{L}},{\variable[KResult]{V}},{\variable[Type]{T}},{\variable[Int]{R}},{\variable[Bool]{IR}})}{\dotCt{K}}}
\mathrel{}\kall{heap}{\reduce{\variable[Map]{{\rho}}}{{\variable[Map]{{\rho}}}[{{}\terminal{zval}({\variable[KResult]{V}},{\variable[Type]{T}},{\variable[Int]{R}},{\variable[Bool]{IR}})}\terminal{/}{\variable[Loc]{L}}]}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"zval-create"}}}
}{}{}{\kattribute{internal}, \kattribute{mem}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#zvalDestroy}({{\nonTerminal{\sort{Loc}}}})}{}
\end{syntaxBlock}
\krule[zval-destroy]{
\kprefix{k}{\reduce{{}\terminal{\#zvalDestroy}({\variable[Loc]{L}})}{\dotCt{K}}}
\mathrel{}\kmiddle{heap}{\reduce{\left({\variable[Loc]{L}\mapsto\AnyVar[K]}\right)}{\dotCt{Map}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"zval-destroy"}}}
}{}{}{\kattribute{internal}, \kattribute{mem}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{incRefCount}({{\nonTerminal{\sort{Loc}}}})}{}
\end{syntaxBlock}
\krule[inc-refCount-1]{
\kprefix{k}{\reduce{{}\terminal{incRefCount}({\variable[Loc]{L}})}{{}\terminal{\#zvalWrite}({\variable[Loc]{L}},{{}\terminal{@RefCount}},{{\variable[Int]{Refs}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\AnyVar[K]},{\AnyVar[K]},{\variable[Int]{Refs}},{\constant[\#Bool]{false}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"inc-refCount-1"}}}
}{\left({{\variable[Int]{Refs}}\mathrel{{=}{=}_{\scriptstyle\it Int}}{\constant[\#Int]{0}}}\right)}{}{\kattribute{internal}, \kattribute{mem}}{}
\krule[inc-refCount-2]{
\kprefix{k}{\reduce{{}\terminal{incRefCount}({\variable[Loc]{L}})}{{}\terminal{\#zvalWrite}({\variable[Loc]{L}},{{}\terminal{@RefCount}},{{\variable[Int]{Refs}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\AnyVar[K]},{\AnyVar[K]},{\variable[Int]{Refs}},{\reduce{\constant[\#Bool]{false}}{\constant[\#Bool]{true}}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"inc-refCount-2"}}}
}{\left({{\variable[Int]{Refs}}\mathrel{{=}{=}_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)}{}{\kattribute{internal}, \kattribute{mem}}{}
\krule[inc-refCount-3]{
\kprefix{k}{\reduce{{}\terminal{incRefCount}({\variable[Loc]{L}})}{{}\terminal{\#zvalWrite}({\variable[Loc]{L}},{{}\terminal{@RefCount}},{{\variable[Int]{Refs}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\AnyVar[K]},{\AnyVar[K]},{\variable[Int]{Refs}},{\constant[\#Bool]{true}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"inc-refCount-3"}}}
}{\left({{\variable[Int]{Refs}}\mathrel{>_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)}{}{\kattribute{internal}, \kattribute{mem}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{decRefCount}({{\nonTerminal{\sort{Loc}}}})}{}
\end{syntaxBlock}
\krule[dec-refCount-1]{
\kprefix{k}{\reduce{{}\terminal{decRefCount}({\variable[Loc]{L}})}{{}\terminal{\#zvalWrite}({\variable[Loc]{L}},{{}\terminal{@RefCount}},{{\variable[Int]{Refs}}\mathrel{-_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\AnyVar[K]},{\AnyVar[K]},{\variable[Int]{Refs}},{\constant[\#Bool]{true}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dec-refCount-1"}}}
}{\left({{\variable[Int]{Refs}}\mathrel{>_{\scriptstyle\it Int}}{\constant[\#Int]{2}}}\right)}{}{\kattribute{internal}, \kattribute{mem}}{}
\krule[dec-refCount-2]{
\kprefix{k}{\reduce{{}\terminal{decRefCount}({\variable[Loc]{L}})}{{}\terminal{\#zvalWrite}({\variable[Loc]{L}},{{}\terminal{@RefCount}},{{\variable[K]{Refs}}\mathrel{-_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\AnyVar[K]},{\AnyVar[K]},{\variable[K]{Refs}},{\reduce{\constant[\#Bool]{true}}{\constant[\#Bool]{false}}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dec-refCount-2"}}}
}{\left({{\variable[K]{Refs}}\mathrel{{=}{=}_{\scriptstyle\it Int}}{\constant[\#Int]{2}}}\right)}{}{\kattribute{internal}, \kattribute{mem}}{}
\krule[dec-refCount-3]{
\kprefix{k}{\reduce{{}\terminal{decRefCount}({\variable[Loc]{L}})}{{}\terminal{\#zvalWrite}({\variable[Loc]{L}},{{}\terminal{@RefCount}},{{\variable[K]{Refs}}\mathrel{-_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})\kra{}\terminal{*Cond}({{\variable[K]{V}}\terminal{isCompoundValue}},{{}\terminal{decRefCountCompound}({\variable[Loc]{L}})},{\dotCt{K}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[K]{V}},{\AnyVar[K]},{\variable[K]{Refs}},{\constant[\#Bool]{false}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dec-refCount-2"}}}
}{\left({{\variable[K]{Refs}}\mathrel{\leq_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)}{}{\kattribute{internal}, \kattribute{mem}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{decRefCountCompound}({{\nonTerminal{\sort{Loc}}}})}{}
\end{syntaxBlock}
\krule[dec-refCount-compound-array]{
\kprefix{k}{\reduce{{}\terminal{decRefCountCompound}({\variable[K]{L}})}{{}\terminal{decRefCountArrayElems}({\variable[K]{L}},{\variable[List]{Elems}})}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dec-refCount-compound-array"}}}
}{}{}{\kattribute{internal}}{}
\krule[dec-refCount-compound-obj]{
\kprefix{k}{{}\terminal{decRefCountCompound}({\reduce{\variable[Loc]{L}}{\variable[K]{L1}}})}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L1}},{\AnyVar[K]},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[K]{L1}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dec-refCount-compound-obj"}}}
}{}{}{\kattribute{structural}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{decRefCountArrayElems}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{List}}}})}{}
\end{syntaxBlock}
\krule[dec-refCount-array-elems-cons]{
\kprefix{k}{\reduce{{}\terminal{decRefCountArrayElems}({\variable[Loc]{L}},{\variable[List]{Elems}\mathrel{}[{\variable[K]{X}},{\AnyVar[K]},{\variable[K]{L1}}]})}{{}\terminal{decRefCount}({\variable[K]{L1}})\kra{}\terminal{decRefCountArrayElems}({\variable[Loc]{L}},{\variable[List]{Elems}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dec-refCount-array-elems-cons"}}}
}{}{}{\kattribute{internal}}{}
\krule[dec-refCount-array-elems-nil]{
\kprefix{k}{\reduce{{}\terminal{decRefCountArrayElems}({\variable[Loc]{L}},{\dotCt{List}})}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dec-refCount-array-elems-nil"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Operations on Arrays} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Array}}}\syntax{{}\terminal{emptyArray}}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{emptyArray}}{{}\terminal{Array}({{}\terminal{none}},{\dotCt{List}})}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{ArrayCreateEmpty}({{\nonTerminal{\sort{Loc}}}})}{}
\end{syntaxBlock}
\krule[array-create-empty]{
\kprefix{k}{\reduce{{}\terminal{ArrayCreateEmpty}({\variable[Loc]{L}})}{{}\terminal{\#write}({{}\terminal{emptyArray}},{\variable[Loc]{L}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-create-empty"}}}
}{}{}{\kattribute{structural}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{ArrayCreateElem}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{Key}}}},{{\nonTerminal{\sort{OptionArrayItemVisibility}}}},{{\nonTerminal{\sort{Loc}}}})}{\kattribute{strict}(4)}
\end{syntaxBlock}
\krule[array-create-elem]{
\kprefix{k}{\reduce{{}\terminal{ArrayCreateElem}({\variable[K]{L}},{\variable[K]{K}},{\variable[K]{V}},{\variable[Loc]{L1}})}{{}\terminal{incRefCount}({\variable[Loc]{L1}})}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\variable[K]{Crnt}},{\variable[List]{ArrayElems}\mathrel{}\reduce{\dotCt{List}}{[{\variable[K]{K}},{\variable[K]{V}},{\variable[Loc]{L1}}]}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-create-elem"}}}
}{{\variable[K]{Crnt}}\mathrel{\neq_K}{{}\terminal{none}}}{}{\kattribute{internal}}{}
\krule[array-create-elem-update-crnt]{
\kprefix{k}{\reduce{{}\terminal{ArrayCreateElem}({\variable[K]{L}},{\variable[K]{K}},{\variable[K]{V}},{\variable[Loc]{L1}})}{{}\terminal{incRefCount}({\variable[Loc]{L1}})}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\reduce{{}\terminal{none}}{[{\variable[K]{K}},{\variable[K]{V}},{\variable[Loc]{L1}}]}},{\reduce{\variable[List]{List}}{[{\variable[K]{K}},{\variable[K]{V}},{\variable[Loc]{L1}}]}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-create-elem-update-crnt"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{ArrayUpdateElem}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{Key}}}},{{\nonTerminal{\sort{Loc}}}})}{}
\end{syntaxBlock}
\krule[array-update-elem-update]{
\kprefix{k}{\reduce{{}\terminal{ArrayUpdateElem}({\variable[Loc]{L1}},{\variable[Key]{X}},{\variable[Loc]{L2}})}{\dotCt{K}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\AnyVar[List]\mathrel{}[{\variable[Key]{X}},{\AnyVar[K]},{\reduce{\AnyVar[K]}{\variable[Loc]{L2}}}]\mathrel{}\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-update-elem-update"}}}
}{}{}{\kattribute{internal}}{}
\krule[array-update-elem-create]{
\kprefix{k}{\reduce{{}\terminal{ArrayUpdateElem}({\variable[Loc]{L1}},{\variable[Key]{X}},{\variable[Loc]{L2}})}{{}\terminal{ArrayCreateElem}({\variable[Loc]{L1}},{\variable[Key]{X}},{{}\terminal{none}},{\variable[Loc]{L2}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"array-update-elem-create"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[List]{Elems}}\terminal{hasProperty}{\variable[Key]{X}}}\right)}}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Auxiliary List and arithmetic ops} 
		TODO: this functions deal with lists. What about using a wrapper which deals 
			  directly with array or objects? \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{{\nonTerminal{\sort{List}}}}\terminal{hasProperty}{{\nonTerminal{\sort{K}}}}}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{[{\variable[K]{K2}},{\AnyVar[K]},{\AnyVar[K]}]\mathrel{}\variable[List]{L2}}\terminal{hasProperty}{\variable[K]{K1}}}{{\left({{\variable[K]{K1}}\mathrel{=_K}{\variable[K]{K2}}}\right)}\vee_{\scriptstyle\it Bool}{\left({{\variable[List]{L2}}\terminal{hasProperty}{\variable[K]{K1}}}\right)}}}{}{}{}{}
\krule{
\reduce{{\dotCt{List}}\terminal{hasProperty}{\AnyVar[K]}}{\constant[\#Bool]{false}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{{\nonTerminal{\sort{List}}}}\terminal{hasPrivateProperty}{{\nonTerminal{\sort{K}}}}\terminal{for}{{\nonTerminal{\sort{K}}}}}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{[{\variable[K]{P}},{\variable[K]{C}},{\AnyVar[K]}]\mathrel{}\variable[List]{L2}}\terminal{hasPrivateProperty}{\variable[K]{Prop}}\terminal{for}{\variable[K]{Class}}}{{\left({{\left({{\variable[K]{P}}\mathrel{=_K}{\variable[K]{Prop}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{\variable[K]{C}}\mathrel{=_K}{{}\terminal{pri}({\variable[K]{Class}})}}\right)}}\right)}\vee_{\scriptstyle\it Bool}{\left({{\variable[List]{L2}}\terminal{hasPrivateProperty}{\variable[K]{Prop}}\terminal{for}{\variable[K]{Class}}}\right)}}}{}{}{}{}
\krule{
\reduce{{\dotCt{List}}\terminal{hasPrivateProperty}{\AnyVar[K]}\terminal{for}{\AnyVar[K]}}{\constant[\#Bool]{false}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{head}({{\nonTerminal{\sort{List}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{head}({\variable[K]{H}\mathrel{}\variable[List]{L}})}{\variable[K]{H}}}{}{}{}{}
\krule{
\reduce{{}\terminal{head}({\dotCt{List}})}{{}\terminal{none}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Int}}}\syntax{{}\terminal{len}({{\nonTerminal{\sort{List}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{len}({\dotCt{List}})}{\constant[\#Int]{0}}}{}{}{}{}
\krule{
\reduce{{}\terminal{len}({\AnyVar[K]\mathrel{}\variable[List]{Tail}})}{{\constant[\#Int]{1}}\mathrel{+_{\scriptstyle\it Int}}{{}\terminal{len}({\variable[List]{Tail}})}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Int}}}\syntax{{}\terminal{biggestIntKey}({{\nonTerminal{\sort{List}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{biggestIntKey}({\dotCt{List}})}{\constant[\#Int]{-1}}}{}{}{}{}
\krule{
\reduce{{}\terminal{biggestIntKey}({[{\variable[String]{Key}},{\AnyVar[K]},{\AnyVar[K]}]\mathrel{}\variable[List]{Tail}})}{{}\terminal{biggestIntKey}({\variable[List]{Tail}})}}{}{}{}{}
\krule{
\reduce{{}\terminal{biggestIntKey}({[{\variable[Int]{Key}},{\AnyVar[K]},{\AnyVar[K]}]\mathrel{}\variable[List]{Tail}})}{{}\terminal{max}({\variable[Int]{Key}},{{}\terminal{biggestIntKey}({\variable[List]{Tail}})})}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Int}}}\syntax{{}\terminal{max}({{\nonTerminal{\sort{Int}}}},{{\nonTerminal{\sort{Int}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{max}({\variable[K]{I1}},{\variable[K]{I2}})}{\variable[K]{I1}}}{{\variable[K]{I1}}\mathrel{\geq_{\scriptstyle\it Int}}{\variable[K]{I2}}}{}{}{}
\krule{
\reduce{{}\terminal{max}({\variable[K]{I1}},{\variable[K]{I2}})}{\variable[K]{I2}}}{{\variable[K]{I1}}\mathrel{<_{\scriptstyle\it Int}}{\variable[K]{I2}}}{}{}{}
\begin{kblock}[text]
 \subsection{Macros} 
		We define here a nummber of useful operations which allows us to manipulate the heap 
		without having to update all the low level details manually (e.g. the type of a value, 
		the reference counter etc.). 
		We will mostly use this operations in the semantics, so that the low-level actions 
		are all defined here. This will make the semantic rules easier to write and also easy
		to fix. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#read}({{\nonTerminal{\sort{K}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[read-loc]{
\kprefix{k}{\reduce{{}\terminal{\#read}({\variable[Loc]{L}})}{{}\terminal{\#zvalRead}({\variable[Loc]{L}},{{}\terminal{@Value}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"read-loc"}}}
}{\left({{\variable[Loc]{L}}\mathrel{\neq_K}{{}\terminal{locNull}}}\right)}{}{\kattribute{internal}}{}
\krule[read-locNull]{
\kprefix{k}{\reduce{{}\terminal{\#read}({{}\terminal{locNull}})}{{}\terminal{NULL}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"read-locNull"}}}
}{}{}{\kattribute{internal}}{}
\krule[read-string]{
\kprefix{k}{\reduce{{}\terminal{\#read}({\variable[String]{S}})}{\variable[String]{S}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"read-string"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#write}({{\nonTerminal{\sort{Value}}}},{{\nonTerminal{\sort{Loc}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[write-loc-exists]{
\kprefix{k}{\reduce{{}\terminal{\#write}({\variable[KResult]{V}},{\variable[Loc]{L}})}{{}\terminal{\#zvalWrite}({\variable[Loc]{L}},{{}\terminal{@Value}},{\variable[KResult]{V}})\kra{}\terminal{\#zvalWrite}({\variable[Loc]{L}},{{}\terminal{@Type}},{{}\terminal{\#typeOf}({\variable[KResult]{V}})})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto\AnyVar[K]}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"write-loc-exists"}}}
}{}{}{\kattribute{internal}}{}
\krule[write-loc-undef]{
\kprefix{k}{\reduce{{}\terminal{\#write}({\variable[KResult]{V}},{\variable[Loc]{L}})}{{}\terminal{\#zvalCreate}({\variable[Loc]{L}},{\variable[KResult]{V}},{{}\terminal{\#typeOf}({\variable[KResult]{V}})},{\constant[\#Int]{0}},{\constant[\#Bool]{false}})}}
\mathrel{}\kall{heap}{\variable[Map]{Mem}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"write-loc-undef"}}}
}{{\left({\neg_{\scriptstyle\it Bool}{\left({{\variable[Loc]{L}}\terminal{in}{{}\terminal{keys}{\left({\variable[Map]{Mem}}\right)}}}\right)}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{\variable[Loc]{L}}\mathrel{\neq_K}{{}\terminal{locNull}}}\right)}}{}{\kattribute{internal}}{}
\krule[write-locNull]{
\kprefix{k}{\reduce{{}\terminal{\#write}({\variable[KResult]{V}},{{}\terminal{locNull}})}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"write-locNull"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{allocValue}({{\nonTerminal{\sort{Value}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[alloc-value]{
\kprefix{k}{\reduce{{}\terminal{allocValue}({\variable[Value]{V}})}{{}\terminal{copyValueToLoc}({\variable[Value]{V}},{\variable[Loc]{L}})\kra\variable[Loc]{L}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"alloc-value"}}}
}{{}\terminal{fresh}({\variable[Loc]{L}})}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 Copies the value contained in a location into another location. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{copyValueToLoc}({{\nonTerminal{\sort{Value}}}},{{\nonTerminal{\sort{Loc}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[copy-value-to-loc-LHS2Loc]{
\kprefix{k}{{}\terminal{copyValueToLoc}({\reduce{\variable[Ref]{R}}{{}\terminal{Rget}({\variable[Ref]{R}})}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"copy-value-to-loc-LHS2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[copy-value-to-loc-null]{
\kprefix{k}{{}\terminal{copyValueToLoc}({\reduce{{}\terminal{locNull}}{{}\terminal{NULL}}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"copy-value-to-loc-null"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[copy-value-to-loc-scalar]{
\kprefix{k}{\reduce{{}\terminal{copyValueToLoc}({\variable[LanguageValue]{V}},{\variable[Loc]{L}})}{{}\terminal{\#detectForeachItemChange}({\variable[Loc]{L}},{\variable[LanguageValue]{V}})\kra{}\terminal{\#write}({\variable[LanguageValue]{V}},{\variable[Loc]{L}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"copy-value-to-loc-scalar"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{{}\terminal{\#isArrayType}({\variable[LanguageValue]{V}})}\vee_{\scriptstyle\it Bool}{{}\terminal{\#isObjectType}({\variable[LanguageValue]{V}})}}\right)}}{}{\kattribute{internal}}{}
\krule[copy-value-to-loc-array]{
\kprefix{k}{\reduce{{}\terminal{copyValueToLoc}({{}\terminal{Array}({\variable[K]{Crnt}},{\variable[List]{Elems}})},{\variable[Loc]{L}})}{{}\terminal{\#detectForeachItemChange}({\variable[Loc]{L}},{\left({{}\terminal{Array}({\variable[K]{Crnt}},{\variable[List]{Elems}})}\right)})\kra{}\terminal{ArrayCreateEmpty}({\variable[Loc]{L}})\kra{}\terminal{copyArrayMembers}({\variable[Loc]{L}},{\variable[List]{Elems}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"copy-value-to-loc-array"}}}
}{}{}{\kattribute{internal}}{}
\krule[copy-value-to-loc-obj]{
\kprefix{k}{\reduce{{}\terminal{copyValueToLoc}({{}\terminal{OID}({\variable[K]{L1}},{\variable[K]{ClassName}},{\variable[K]{InstanceN}})},{\variable[Loc]{L}})}{{}\terminal{\#detectForeachItemChange}({\variable[Loc]{L}},{{}\terminal{OID}({\variable[K]{L1}},{\variable[K]{ClassName}},{\variable[K]{InstanceN}})})\kra{}\terminal{incRefCount}({\variable[K]{L1}})\kra{}\terminal{\#write}({{}\terminal{OID}({\variable[K]{L1}},{\variable[K]{ClassName}},{\variable[K]{InstanceN}})},{\variable[Loc]{L}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"copy-value-to-loc-obj"}}}
}{}{}{\kattribute{internal}}{}
\krule[copy-value-to-loc-array-literal]{
\kprefix{k}{\reduce{{}\terminal{copyValueToLoc}({{}\terminal{Literal}({'Array(\variable[K]{Elems})})},{\variable[K]{L1}})}{{}\terminal{makeArrayLiteral}({\variable[K]{L1}},{\variable[K]{Elems}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"copy-value-to-loc-array-literal"}}}
}{}{}{\kattribute{internal}}{}
\krule[copy-value-to-loc-object-literal]{
\kprefix{k}{\reduce{{}\terminal{copyValueToLoc}({{}\terminal{Literal}({'ObjectCreation(\variable[Id]{ClassName}\kcomma\variable[K]{Args})})},{\variable[K]{L1}})}{{}\terminal{makeNewObject}({\variable[K]{L1}},{\variable[Id]{ClassName}},{\variable[K]{Args}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"copy-value-to-loc-object-literal"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#detectForeachItemChange}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{Value}}}})}{}
\end{syntaxBlock}
\krule[detectForeachItemChange-true]{
\kprefix{k}{\reduce{{}\terminal{\#detectForeachItemChange}({\variable[Loc]{L}},{\variable[Value]{V}})}{\dotCt{K}}}
\mathrel{}\kall{currentForeachItem}{\variable[Loc]{L}}
\mathrel{}\ksuffix{loopStack}{{}\terminal{\#loopFrame}({\variable[K]{K}},{\reduce{\AnyVar[K]}{\constant[\#Bool]{true}}})}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V1}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"detectForeachItemChange-true"}}}
}{{\variable[Value]{V}}\mathrel{\neq_K}{\variable[Value]{V1}}}{}{\kattribute{internal}}{}
\krule[detectForeachItemChange-false-1]{
\kprefix{k}{\reduce{{}\terminal{\#detectForeachItemChange}({\variable[Loc]{L}},{\variable[Value]{V}})}{\dotCt{K}}}
\mathrel{}\kall{currentForeachItem}{\variable[Loc]{L}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"detectForeachItemChange-false-1"}}}
}{}{}{\kattribute{internal}}{}
\krule[detectForeachItemChange-false-2]{
\kprefix{k}{\reduce{{}\terminal{\#detectForeachItemChange}({\variable[Loc]{L}},{\AnyVar[K]})}{\dotCt{K}}}
\mathrel{}\kall{currentForeachItem}{\variable[K]{K}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"detectForeachItemChange-false-2"}}}
}{{\variable[K]{K}}\mathrel{\neq_K}{\variable[Loc]{L}}}{}{\kattribute{internal}}{}
\krule[detectForeachItemChange-false-3]{
\kprefix{k}{\reduce{{}\terminal{\#detectForeachItemChange}({\AnyVar[K]},{\AnyVar[K]})}{\dotCt{K}}}
\mathrel{}\kall{loopStack}{\dotCt{List}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"detectForeachItemChange-false-3"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 Array copy in PHP have an unique semantics, which is modelled below. More on this later. 
	NOTE: this is crucial for the "correctness" of the semantics, as it is one of the most
	challenging features of PHP. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{copyArrayMembers}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{List}}}})}{}
\end{syntaxBlock}
\krule[copyArrayMembers-cons-no-aliasing]{
\kprefix{k}{\reduce{{}\terminal{copyArrayMembers}({\variable[Loc]{L1}},{[{\variable[K]{Key}},{\variable[K]{Visib}},{\variable[K]{L}}]\mathrel{}\variable[List]{Elems}})}{{}\terminal{ArrayCreateElem}({\variable[Loc]{L1}},{\variable[K]{Key}},{\variable[K]{Visib}},{{}\terminal{allocValue}({\variable[Value]{V}})})\kra{}\terminal{copyArrayMembers}({\variable[Loc]{L1}},{\variable[List]{Elems}})}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\constant[\#Bool]{false}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"copyArrayMembers-cons-no-aliasing"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[copyArrayMembers-cons-aliasing]{
\kprefix{k}{\reduce{{}\terminal{copyArrayMembers}({\variable[Loc]{L1}},{[{\variable[K]{Key}},{\variable[K]{Visib}},{\variable[K]{L}}]\mathrel{}\variable[List]{Elems}})}{{}\terminal{ArrayCreateElem}({\variable[Loc]{L1}},{\variable[K]{Key}},{\variable[K]{Visib}},{\variable[K]{L}})\kra{}\terminal{copyArrayMembers}({\variable[Loc]{L1}},{\variable[List]{Elems}})}}
\mathrel{}\kmiddle{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\constant[\#Bool]{true}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"copyArrayMembers-cons-aliasing"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[copyArrayMembers-nil]{
\kprefix{k}{\reduce{{}\terminal{copyArrayMembers}({\AnyVar[K]},{\dotCt{List}})}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"copyArrayMembers-nil"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Basic Operations on references} 
		We define here a number of internal oparations on references, that will be used 
		extensively in the semantics. \end{kblock}
\begin{kblock}[text]
 get operations take a reference as input and returns a memory location, i.e. the location 
    designated by the reference. In order to accurately model PHP behaviour we define two variants
    of the get operation: getL and getR, which are meant to be used on the left and right hand sides 
    of assignment. getR, whose meaning is closer to standard get operations, simply tries to 
    resolve the reference and, if the reference refers to something which is not allocated, returns
    NULL. getL also tries to resolve the reference, but it also "fill the gaps" by allocating 
    new memory locations when needed. We use this in order to model. e.g. assignment. If the variable 
    (or array or object member) on the left-hand-side does not exists it is created, while if 
    the variable on the right-hand-side does not exists, NULL is returned. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{Rget}({{\nonTerminal{\sort{Ref}}}})}{\kattribute{strict}}\syntaxCont{{}\terminal{RgetRef}({{\nonTerminal{\sort{Ref}}}},{{\nonTerminal{\sort{RefType}}}})}{\kattribute{strict}(1)}
\end{syntaxBlock}
\krule[rget-default]{
\kprefix{k}{\reduce{{}\terminal{Rget}({\variable[Ref]{R}})}{{}\terminal{RgetRef}({\variable[Ref]{R}},{{}\terminal{nul}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"rget-default"}}}
}{}{}{\kattribute{structural}}{}
\krule[rget-propagate]{
\kprefix{k}{\reduce{{}\terminal{RgetRef}({{}\terminal{lref}({\variable[Ref]{R}},{\variable[Key]{X}},{\variable[RefType]{T1}})},{\variable[RefType]{T2}})}{{}\terminal{RgetRef}({{}\terminal{ref}({{}\terminal{RgetRef}({\variable[Ref]{R}},{\variable[RefType]{T1}})},{\variable[Key]{X}})},{\variable[RefType]{T2}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"rget-propagate"}}}
}{}{}{\kattribute{structural}}{}
\krule[rget-array-prop]{
\kprefix{k}{\reduce{{}\terminal{RgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})},{\AnyVar[K]})}{\variable[K]{L1}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\AnyVar[List]\mathrel{}[{\variable[Key]{X}},{{}\terminal{none}},{\variable[K]{L1}}]\mathrel{}\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"rget-array-prop"}}}
}{}{}{\kattribute{internal}}{}
\krule[rget-array-prop-undefined]{
\kprefix{k}{\reduce{{}\terminal{RgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})},{\AnyVar[K]})}{{}\terminal{NOTICE}({\constant[\#String]{"Undefined variable: \%s in \%s on line \%d\textbackslash n"}})\kra{}\terminal{locNull}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{ArrayElements}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"rget-array-prop-undefined"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[List]{ArrayElements}}\terminal{hasProperty}{\variable[Key]{X}}}\right)}}{}{\kattribute{internal}, \kattribute{error}}{}
\krule[rget-obj-prop-public]{
\kprefix{k}{\reduce{{}\terminal{RgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[String]{X}})},{\AnyVar[K]})}{\variable[Loc]{L2}}}
\mathrel{}\kall{class}{\variable[K]{Context}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[Loc]{L1}},{\AnyVar[K]},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\left({\variable[List]{E}\mathrel{}[{\variable[String]{X}},{{}\terminal{none}},{\variable[Loc]{L2}}]\mathrel{}\variable[List]{F}}\right)})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"rget-obj-prop-public"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[List]{E}\mathrel{}\variable[List]{F}}\terminal{hasPrivateProperty}{\variable[String]{X}}\terminal{for}{\variable[K]{Context}}}\right)}}{}{\kattribute{internal}}{}
\krule[rget-obj-prop-protected]{
\kprefix{k}{\reduce{{}\terminal{RgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[String]{X}})},{\AnyVar[K]})}{{}\terminal{*Cond}({{}\terminal{\#isVisible}({\variable[Id]{ObjClass}},{\variable[K]{Context}},{{}\terminal{pro}})},{\variable[Loc]{L2}},{{}\terminal{ERROR}({\constant[\#String]{"ERROR-PROTECTED"}})})}}
\mathrel{}\kall{class}{\variable[K]{Context}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[Loc]{L1}},{\variable[Id]{ObjClass}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\left({\variable[List]{E}\mathrel{}[{\variable[String]{X}},{{}\terminal{pro}},{\variable[Loc]{L2}}]\mathrel{}\variable[List]{F}}\right)})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"rget-obj-prop-protected"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[List]{E}\mathrel{}\variable[List]{F}}\terminal{hasPrivateProperty}{\variable[String]{X}}\terminal{for}{\variable[K]{Context}}}\right)}}{}{\kattribute{internal}}{}
\krule[rget-obj-prop-private]{
\kprefix{k}{\reduce{{}\terminal{RgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[String]{X}})},{\AnyVar[K]})}{\variable[Loc]{L2}}}
\mathrel{}\kall{class}{\variable[K]{Context}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[Loc]{L1}},{\variable[K]{ObjClass}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\left({\variable[List]{E}\mathrel{}[{\variable[String]{X}},{{}\terminal{pri}({\variable[K]{Context}})},{\variable[Loc]{L2}}]\mathrel{}\variable[List]{F}}\right)})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"rget-obj-prop-private"}}}
}{}{}{\kattribute{internal}}{}
\krule[rget-obj-prop-undefined]{
\kprefix{k}{\reduce{{}\terminal{RgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[String]{X}})},{\AnyVar[K]})}{{}\terminal{NOTICE}({\constant[\#String]{"Undefined property: \%s in \%s on line \%d\textbackslash n"}})\kra{}\terminal{locNull}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[Loc]{L1}},{\AnyVar[K]},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{E}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"rget-obj-prop-undefined"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[List]{E}}\terminal{hasProperty}{\variable[String]{X}}}\right)}}{}{\kattribute{internal}}{}
\krule[rget-obj-scalar]{
\kprefix{k}{\reduce{{}\terminal{RgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{\AnyVar[K]})},{\AnyVar[K]})}{{}\terminal{locNull}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"rget-obj-scalar"}}}
}{{{\left({\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isArrayType}({\variable[Value]{V}})}\right)}}\right)}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isStringType}({\variable[Value]{V}})}\right)}}\right)}}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isObjectType}({\variable[Value]{V}})}\right)}}\right)}}{}{\kattribute{internal}}{}
\krule[rget-null]{
\kprefix{k}{\reduce{{}\terminal{RgetRef}({{}\terminal{ref}({{}\terminal{locNull}},{\AnyVar[K]})},{\AnyVar[K]})}{{}\terminal{locNull}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"rget-null"}}}
}{}{}{\kattribute{internal}}{}
\krule[rget-string-index]{
\kprefix{k}{\reduce{{}\terminal{RgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Int]{Index}})},{\AnyVar[K]})}{{}\terminal{substrString}({\variable[String]{Str}},{\variable[Int]{Index}},{{\variable[Int]{Index}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[String]{Str}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"rget-string-index"}}}
}{}{}{\kattribute{internal}}{}
\krule[rget-string-undef]{
\kprefix{k}{\reduce{{}\terminal{RgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[String]{Index}})},{\AnyVar[K]})}{{}\terminal{locNull}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[String]{Str}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"rget-string-undef"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Lget} 
		LGet works the same ways as RGet when the reference being resolved does exists. 
		The difference between RGet is that in the case the reference does not exists, 
		it is created. This has to be used on the LHS, and allows behaviour like 
		(supposing $x is fresh) '$x["foo"][12][] = 0'; \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{Lget}({{\nonTerminal{\sort{Ref}}}})}{\kattribute{strict}}
\end{syntaxBlock}
\krule[lget-default]{
\kprefix{k}{\reduce{{}\terminal{Lget}({\variable[Ref]{R}})}{{}\terminal{LgetRef}({\variable[Ref]{R}},{{}\terminal{nul}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lget-default"}}}
}{}{}{\kattribute{structural}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{LgetRef}({{\nonTerminal{\sort{Ref}}}},{{\nonTerminal{\sort{RefType}}}})}{\kattribute{strict}(1), \kattribute{klabel}('put)}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{Loc}}}\syntax{{}\terminal{LError}}{}
\end{syntaxBlock}
\krule[lget-propagate]{
\kprefix{k}{\reduce{{}\terminal{LgetRef}({{}\terminal{lref}({\variable[Ref]{R}},{\variable[Key]{X}},{\variable[RefType]{T1}})},{\variable[RefType]{T2}})}{{}\terminal{LgetRef}({{}\terminal{ref}({{}\terminal{LgetRef}({\variable[Ref]{R}},{\variable[RefType]{T1}})},{\variable[Key]{X}})},{\variable[RefType]{T2}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lget-propagate"}}}
}{}{}{\kattribute{structural}}{}
\krule[lget-found-array]{
\kprefix{k}{\reduce{{}\terminal{LgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})},{\AnyVar[K]})}{{}\terminal{Rget}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{ArrayElems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lget-found-array"}}}
}{{\left({{\variable[List]{ArrayElems}}\terminal{hasProperty}{\variable[Key]{X}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{\variable[Loc]{L}}\mathrel{\neq_K}{{}\terminal{LError}}}\right)}}{}{\kattribute{internal}}{}
\krule[lget-found-obj]{
\kprefix{k}{\reduce{{}\terminal{LgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})},{\AnyVar[K]})}{{}\terminal{Rget}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[Loc]{L1}},{\AnyVar[K]},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lget-found-obj"}}}
}{\left({{\variable[List]{Elems}}\terminal{hasProperty}{\variable[Key]{X}}}\right)}{}{\kattribute{internal}}{}
\krule[lget-not-found-init-null]{
\kprefix{k}{\reduce{{}\terminal{LgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})},{{}\terminal{nul}})}{{}\terminal{ArrayCreateElem}({\variable[Loc]{L}},{\variable[Key]{X}},{{}\terminal{none}},{{}\terminal{allocValue}({{}\terminal{NULL}})})\kra{}\terminal{Rget}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{ArrayElems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lget-not-found-init-null"}}}
}{{{\left({\neg_{\scriptstyle\it Bool}{{\variable[List]{ArrayElems}}\terminal{hasProperty}{\variable[Key]{X}}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{\variable[Loc]{L}}\mathrel{\neq_K}{{}\terminal{LError}}}\right)}}\wedge_{\scriptstyle\it Bool}{\left({{\variable[Key]{X}}\mathrel{\neq_K}{{}\terminal{NULL}}}\right)}}{}{\kattribute{internal}}{}
\krule[lget-not-found-init-array]{
\kprefix{k}{\reduce{{}\terminal{LgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})},{{}\terminal{arr}})}{{}\terminal{ArrayCreateElem}({\variable[Loc]{L}},{\variable[Key]{X}},{{}\terminal{none}},{{}\terminal{allocValue}({{}\terminal{emptyArray}})})\kra{}\terminal{Rget}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{ArrayElems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lget-not-found-init-array"}}}
}{{{\left({\neg_{\scriptstyle\it Bool}{{\variable[List]{ArrayElems}}\terminal{hasProperty}{\variable[Key]{X}}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{\variable[Loc]{L}}\mathrel{\neq_K}{{}\terminal{LError}}}\right)}}\wedge_{\scriptstyle\it Bool}{\left({{\variable[Key]{X}}\mathrel{\neq_K}{{}\terminal{NULL}}}\right)}}{}{\kattribute{internal}}{}
\krule[lget-not-found-init-obj]{
\kprefix{k}{\reduce{{}\terminal{LgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})},{{}\terminal{obj}})}{'Expr('Assign({}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})\kcomma\left({'ObjectCreation(\constant[\#String]{"stdClass"})}\right)))\kra{}\terminal{Rget}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lget-not-found-init-obj"}}}
}{{{\left({\neg_{\scriptstyle\it Bool}{{\variable[List]{Elems}}\terminal{hasProperty}{\variable[Key]{X}}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{\variable[Loc]{L}}\mathrel{\neq_K}{{}\terminal{LError}}}\right)}}\wedge_{\scriptstyle\it Bool}{\left({{\variable[Key]{X}}\mathrel{\neq_K}{{}\terminal{NULL}}}\right)}}{}{\kattribute{internal}}{}
\krule[lget-not-found-in-obj]{
\kprefix{k}{{}\terminal{LgetRef}({{}\terminal{ref}({\reduce{\variable[Loc]{L}}{\variable[Loc]{L2}}},{\variable[Key]{X}})},{\AnyVar[K]})}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[Loc]{L2}},{\AnyVar[K]},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{ArrayElems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lget-not-found-in-obj"}}}
}{\left({\neg_{\scriptstyle\it Bool}{{\variable[List]{ArrayElems}}\terminal{hasProperty}{\variable[Key]{X}}}}\right)}{}{\kattribute{internal}}{}
\krule[lget-not-found-default-array-key]{
\kprefix{k}{\reduce{{}\terminal{LgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{{}\terminal{NULL}})},{\variable[K]{T}})}{{}\terminal{LgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{{{}\terminal{biggestIntKey}({\variable[List]{Elems}})}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})},{\variable[K]{T}})}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lget-not-found-default-array-key"}}}
}{\left({{\variable[Loc]{L}}\mathrel{\neq_K}{{}\terminal{LError}}}\right)}{}{\kattribute{internal}}{}
\krule[lget-error-1]{
\kprefix{k}{\reduce{{}\terminal{LgetRef}({{}\terminal{ref}({\variable[Loc]{L}},{\variable[Key]{X}})},{\AnyVar[K]})}{{}\terminal{WARNING}({\constant[\#String]{"Cannot use a scalar value as an array in \%s on line \%d"}})\kra{}\terminal{locNull}}}
\mathrel{}\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lget-error-1"}}}
}{{\left({\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isArrayType}({\variable[Value]{V}})}\right)}}\right)}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isObjectType}({\variable[Value]{V}})}\right)}}\right)}}{}{\kattribute{internal}, \kattribute{error}}{}
\krule[lget-error-2]{
\kprefix{k}{\reduce{{}\terminal{LgetRef}({{}\terminal{ref}({{}\terminal{LError}},{\variable[Key]{X}})},{\AnyVar[K]})}{{}\terminal{ref}({{}\terminal{LError}},{\variable[Key]{X}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lget-error-2"}}}
}{}{}{\kattribute{internal}, \kattribute{error}}{}
\end{module}
\begin{module}{\moduleName{INIT}}
\begin{kblock}[text]
 \section{Initialization} \end{kblock}
\begin{kblock}[text]
 \subsection{Building the initial state} 
		The following operations loads the (currently defined) builtin functions such as
		key, current, vardump, etc. 
		TODO: put all this stuff into an external file, and load it via krun options. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Internal}}}\syntax{{}\terminal{buildInitState}}{}\syntaxCont{{}\terminal{initScopes}}{}\syntaxCont{{}\terminal{initBuiltinFunctions}}{}\syntaxCont{{}\terminal{initBuiltinClasses}}{}\syntaxCont{{}\terminal{initSuperGlobals}}{}
\end{syntaxBlock}
\krule[built-init-state]{
\kprefix{k}{\reduce{{}\terminal{buildInitState}}{{}\terminal{initScopes}\kra{}\terminal{initBuiltinFunctions}\kra{}\terminal{initBuiltinClasses}\kra{}\terminal{initSuperGlobals}\kra{}\terminal{buildArrayCompareFun}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"built-init-state"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Initializing builtin functions} \end{kblock}
\krule[init-builtin-functions]{
\left(\begin{array}{@{}c@{}}\kprefix{k}{\reduce{{}\terminal{initBuiltinFunctions}}{\dotCt{K}}}
\mathrel{}\kmiddle{heap}{\reduce{\dotCt{Map}}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({{}\terminal{none}},{\dotCt{List}})},{{}\terminal{array}},{\constant[\#Int]{1}},{\constant[\#Bool]{false}})}}
\mathrel{}\\\mathrel{}\kall{functions}{\reduce{\dotCt{Map}}{\constant[\#String]{"current"}\mapsto{}\terminal{f}({'ListWrap('ParamRef('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{\#current}({'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"count"}\mapsto{}\terminal{f}({'ListWrap('ParamRef('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{count}({'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"array\_key\_exists"}\mapsto{}\terminal{f}({'ListWrap('Param('Variable('Simple(\constant[\#String]{"k"})))\kcomma'ParamRef('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{array\_key\_exists}({'Variable('Simple(\constant[\#String]{"k"}))},{'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"key"}\mapsto{}\terminal{f}({'ListWrap('ParamRef('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{\#key}({'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byRef}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"next"}\mapsto{}\terminal{f}({'ListWrap('ParamRef('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{\#next}({'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"each"}\mapsto{}\terminal{f}({'ListWrap('ParamRef('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{\#each}({'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"reset"}\mapsto{}\terminal{f}({'ListWrap('ParamRef('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{\#reset}({'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"var\_dump"}\mapsto{}\terminal{f}({'ListWrap('Param('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap({}\terminal{\#var\_dump}({'Variable('Simple(\constant[\#String]{"x"}))}))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"print\_r"}\mapsto{}\terminal{f}({'ListWrap('Param('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap({}\terminal{\#print\_r}({'Variable('Simple(\constant[\#String]{"x"}))}))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"strlen"}\mapsto{}\terminal{f}({'ListWrap('Param('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{\#strlen}({'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"substr"}\mapsto{}\terminal{f}({'ListWrap('Param('Variable('Simple(\constant[\#String]{"str"})))\kcomma'Param('Variable('Simple(\constant[\#String]{"start"})))\kcomma'ParamDefault('Variable('Simple(\constant[\#String]{"len"}))\kcomma\constant[\#Int]{999}))},{'ListWrap('Return({}\terminal{\#substr}({'Variable('Simple(\constant[\#String]{"str"}))},{'Variable('Simple(\constant[\#String]{"start"}))},{'Variable('Simple(\constant[\#String]{"len"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"define"}\mapsto{}\terminal{f}({'ListWrap('Param('Variable('Simple(\constant[\#String]{"name"})))\kcomma'Param('Variable('Simple(\constant[\#String]{"value"}))))},{'ListWrap('Return({}\terminal{\#define}({'Variable('Simple(\constant[\#String]{"name"}))},{'Variable('Simple(\constant[\#String]{"value"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"gettype"}\mapsto{}\terminal{f}({'ListWrap('Param('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{\#gettype}({'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"defined"}\mapsto{}\terminal{f}({'ListWrap('Param('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{\#defined}({'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"is\_float"}\mapsto{}\terminal{f}({'ListWrap('Param('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{\#is\_float}({'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"is\_string"}\mapsto{}\terminal{f}({'ListWrap('Param('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{\#is\_string}({'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"is\_array"}\mapsto{}\terminal{f}({'ListWrap('Param('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{\#is\_array}({'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"is\_scalar"}\mapsto{}\terminal{f}({'ListWrap('Param('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{\#is\_scalar}({'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"is\_numeric"}\mapsto{}\terminal{f}({'ListWrap('Param('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{\#is\_numeric}({'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"user\_input"}\mapsto{}\terminal{f}({'ListWrap()},{'ListWrap('Return({}\terminal{\#user\_input}))},{{}\terminal{@byValue}},{\variable[Loc]{L}})\mathrel{}\constant[\#String]{"label"}\mapsto{}\terminal{f}({'ListWrap('Param('Variable('Simple(\constant[\#String]{"x"}))))},{'ListWrap('Return({}\terminal{\#label}({'Variable('Simple(\constant[\#String]{"x"}))})))},{{}\terminal{@byValue}},{\variable[Loc]{L}})}}
\end{array}\right)}{{}\terminal{fresh}({\variable[Loc]{L}})}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Initialising the scopes} \end{kblock}
\krule[init-scopes]{
\kprefix{k}{\reduce{{}\terminal{initScopes}}{\dotCt{K}}}
\mathrel{}\kall{heap}{\reduce{\dotCt{Map}}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({{}\terminal{none}},{\dotCt{List}})},{{}\terminal{array}},{\constant[\#Int]{0}},{\constant[\#Bool]{false}})\mathrel{}\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{Array}({{}\terminal{none}},{\dotCt{List}})},{{}\terminal{array}},{\constant[\#Int]{1}},{\constant[\#Bool]{false}})\mathrel{}\variable[Loc]{L3}\mapsto{}\terminal{zval}({{}\terminal{Array}({{}\terminal{none}},{\dotCt{List}})},{{}\terminal{array}},{\constant[\#Int]{1}},{\constant[\#Bool]{false}})}}
\mathrel{}\kall{currentScope}{\reduce{\dotCt{K}}{\variable[Loc]{L}}}
\mathrel{}\kall{globalScope}{\reduce{\dotCt{K}}{\variable[Loc]{L}}}
\mathrel{}\kall{superGlobalScope}{\reduce{\dotCt{K}}{\variable[Loc]{L1}}}
\mathrel{}\kall{globalStaticScope}{\reduce{\dotCt{K}}{\variable[Loc]{L3}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-scopes"}}}
}{{{{}\terminal{fresh}({\variable[Loc]{L}})}\wedge_{\scriptstyle\it Bool}{{}\terminal{fresh}({\variable[Loc]{L1}})}}\wedge_{\scriptstyle\it Bool}{{}\terminal{fresh}({\variable[Loc]{L3}})}}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Superglobals initialization} 
		This operation initializes (some of the) superglobals. \end{kblock}
\krule[init-superglobals]{
\kprefix{k}{\reduce{{}\terminal{initSuperGlobals}}{'Expr('Assign({}\terminal{ref}({\variable[Loc]{Lsg}},{\constant[\#String]{"\_GET"}})\kcomma'Array('ListWrap())))\kra'Expr('Assign({}\terminal{ref}({\variable[Loc]{Lsg}},{\constant[\#String]{"\_COOKIE"}})\kcomma'Array('ListWrap())))\kra'Expr('Assign({}\terminal{ref}({\variable[Loc]{Lsg}},{\constant[\#String]{"\_POST"}})\kcomma'Array('ListWrap())))\kra'Expr('ReferenceAssign({}\terminal{ref}({\variable[Loc]{Lsg}},{\constant[\#String]{"GLOBALS"}})\kcomma\variable[Loc]{Lg}))}}
\mathrel{}\kall{superGlobalScope}{\variable[Loc]{Lsg}}
\mathrel{}\kall{globalScope}{\variable[Loc]{Lg}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-superglobals"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Building the builtin classes} 
		Currently, we have just Exception and stdClass \end{kblock}
\krule[init-builtin-classes]{
\kprefix{k}{\reduce{{}\terminal{initBuiltinClasses}}{{}\terminal{\#makeExceptionClass}\kra{}\terminal{\#makeStdClass}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-builtin-classes"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#makeStdClass}}{}
\end{syntaxBlock}
\krule[make-stdClass]{
\kprefix{k}{\reduce{{}\terminal{\#makeStdClass}}{'Class('Normal()\kcomma\constant[\#String]{"stdClass"}\kcomma'None()\kcomma'None()\kcomma'ListWrap())}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"make-stdClass"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#makeExceptionClass}}{}
\end{syntaxBlock}
\krule[make-exception]{
\kprefix{k}{\reduce{{}\terminal{\#makeExceptionClass}}{'Class('Normal()\kcomma\constant[\#String]{"Exception"}\kcomma'None()\kcomma'None()\kcomma'ListWrap('InstanceVariable('Modifiers('ListWrap('Public()))\kcomma'ListWrap('Normal('Variable('Simple(\constant[\#String]{"errorMsg"})))))\kcomma'FunctionDecl(\constant[\#String]{"Exception"}\kcomma'ListWrap('Param('Variable('Simple(\constant[\#String]{"msg"}))))\kcomma'ListWrap('Expr('Assign('ObjectAccess('Variable('Simple(\constant[\#String]{"this"}))\kcomma'ObjectProperty('Simple(\constant[\#String]{"errorMsg"})))\kcomma'Variable('Simple(\constant[\#String]{"msg"}))))))\kcomma'FunctionDecl(\constant[\#String]{"getMessage"}\kcomma'ListWrap()\kcomma'ListWrap('Return('Some('ObjectAccess('Variable('Simple(\constant[\#String]{"this"}))\kcomma'ObjectProperty('Simple(\constant[\#String]{"errorMsg"})))))))))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"make-exception"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{buildArrayCompareFun}}{}
\end{syntaxBlock}
\krule[build-array-compare]{
\kprefix{k}{\reduce{{}\terminal{buildArrayCompareFun}}{'FunctionDecl(\constant[\#String]{"isEqualArray"}\kcomma'ListWrap('Param('Variable('Simple(\constant[\#String]{"op1"})))\kcomma'Param('Variable('Simple(\constant[\#String]{"op2"}))))\kcomma'ListWrap('If('Less('FunctionCall('FunctionName(\constant[\#String]{"count"})\kcomma'ListWrap('Param('Variable('Simple(\constant[\#String]{"op1"})))))\kcomma'FunctionCall('FunctionName(\constant[\#String]{"count"})\kcomma'ListWrap('Param('Variable('Simple(\constant[\#String]{"op2"}))))))\kcomma'Block('ListWrap('Return('Some('Negative('LNumber('Deci(\constant[\#String]{"1"})))))))\kcomma'ListWrap('ElseIf('Greater('FunctionCall('FunctionName(\constant[\#String]{"count"})\kcomma'ListWrap('Param('Variable('Simple(\constant[\#String]{"op1"})))))\kcomma'FunctionCall('FunctionName(\constant[\#String]{"count"})\kcomma'ListWrap('Param('Variable('Simple(\constant[\#String]{"op2"}))))))\kcomma'Block('ListWrap('Return('Some('LNumber('Deci(\constant[\#String]{"1"})))))))))\kcomma'ForEach('Variable('Simple(\constant[\#String]{"op1"}))\kcomma'Pattern('Some('Key('Variable('Simple(\constant[\#String]{"key"}))))\kcomma'Variable('Simple(\constant[\#String]{"val"})))\kcomma'Block('ListWrap('If('Not('FunctionCall('FunctionName(\constant[\#String]{"array\_key\_exists"})\kcomma'ListWrap('Param('Variable('Simple(\constant[\#String]{"key"})))\kcomma'Param('Variable('Simple(\constant[\#String]{"op2"}))))))\kcomma'Block('ListWrap('Return('Some('Null()))))\kcomma'ListWrap('ElseIf('Less('Variable('Simple(\constant[\#String]{"val"}))\kcomma'ArrayAccess('Variable('Simple(\constant[\#String]{"op2"}))\kcomma'Some('Variable('Simple(\constant[\#String]{"key"})))))\kcomma'Block('ListWrap('Return('Some('Negative('LNumber('Deci(\constant[\#String]{"1"}))))))))\kcomma'ElseIf('Greater('Variable('Simple(\constant[\#String]{"val"}))\kcomma'ArrayAccess('Variable('Simple(\constant[\#String]{"op2"}))\kcomma'Some('Variable('Simple(\constant[\#String]{"key"})))))\kcomma'Block('ListWrap('Return('Some('LNumber('Deci(\constant[\#String]{"1"}))))))))))))\kcomma'Return('Some('LNumber('Deci(\constant[\#String]{"0"}))))))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"build-array-compare"}}}
}{}{}{\kattribute{internal}}{}
\end{module}
\begin{module}{\moduleName{CONFIGURATION}}
\begin{kblock}[text]
 \section{Configuration} \end{kblock}
\kconfig{\kall{kphp}{\begin{array}{@{}c@{}}\kall[pink]{script}{\kall{declarations}{\dotCt{K}}
\mathrel{}\kall{commands}{\dotCt{K}}
\mathrel{}\kall{k}{{}\terminal{buildInitState}\kra\variable[K]{\$PGM}}
}
\mathrel{}\kall[yellow]{tables}{\kall{functions}{\dotCt{Map}}
\mathrel{}\kall{classes}{\dotCt{Map}}
\mathrel{}\kall{constants}{\dotCt{Map}}
\mathrel{}\kall{classInstanceCounters}{\dotCt{Map}}
}
\mathrel{}\\\mathrel{}\kall[green]{scopes}{\kall{currentScope}{\dotCt{K}}
\mathrel{}\kall{globalScope}{\dotCt{K}}
\mathrel{}\kall{globalStaticScope}{\dotCt{K}}
\mathrel{}\kall{superGlobalScope}{\dotCt{K}}
}
\mathrel{}\kall[red]{heap}{\dotCt{Map}}
\mathrel{}\\\mathrel{}\kall[cyan]{control}{\begin{array}{@{}c@{}}\kall{functionStack}{\dotCt{List}}
\mathrel{}\kall{exceptionStack}{\dotCt{List}}
\mathrel{}\kall{loopStack}{\dotCt{List}}
\mathrel{}\kall[pink]{context}{\kall{currentForeachItem}{\dotCt{K}}
\mathrel{}\kall{object}{\dotCt{K}}
\mathrel{}\kall{class}{\dotCt{K}}
\mathrel{}\kall{function}{\dotCt{K}}
}
\mathrel{}\\\mathrel{}\kall{functionArgumentsDeclaration}{\dotCt{K}}
\mathrel{}\kall{processedFunBody}{\dotCt{K}}
\mathrel{}\kall{processedStaticDeclarations}{\dotCt{K}}
\end{array}}
\mathrel{}\\\mathrel{}\kall[magenta]{IO}{\kall{in}{\dotCt{List}}
\mathrel{}\kall{out}{\dotCt{List}}
\mathrel{}\kall{exitStatus}{\constant[\#Int]{0}}
\mathrel{}\kall{errorManagement}{\constant[\#Int]{0}}
\mathrel{}\kall{varDumpLevel}{\constant[\#Int]{0}}
}
\mathrel{}\\\mathrel{}\kall[red]{instrumentation}{\kall{trace}{\dotCt{List}}
\mathrel{}\kall{cleanTraceOnTermination}{\constant[\#Bool]{true}}
\mathrel{}\kall{isTerminated}{\constant[\#Bool]{false}}
\mathrel{}\kall{label}{\constant[\#String]{"@"}}
}
\mathrel{}\kall[blue]{gc}{\kall{locationsToCollect}{\dotCt{List}}
\mathrel{}\kall{gcEnabled}{\constant[\#Bool]{false}}
}
\end{array}}
}
\end{module}
\begin{module}{\moduleName{SYNTAX}}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Document}}{}\syntaxCont{{}\terminal{'TemplateDocument}}{}\syntaxCont{{}\terminal{'FullOpenTag}}{}\syntaxCont{{}\terminal{'ShortOpenTag}}{}\syntaxCont{{}\terminal{'CloseTag}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'InternalFunction}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Empty}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'LNumber}}{}\syntaxCont{{}\terminal{'DNumber}}{}\syntaxCont{{}\terminal{'Deci}}{}\syntaxCont{{}\terminal{'Literal}}{}\syntaxCont{{}\terminal{'True}}{}\syntaxCont{{}\terminal{'False}}{}\syntaxCont{{}\terminal{'Null}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Block}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'ListWrap}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Expr}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Variable}}{}\syntaxCont{{}\terminal{'Simple}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'IndirectReference}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'ArrayAccess}}{}\syntaxCont{{}\terminal{'Some}}{}\syntaxCont{{}\terminal{'None}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Assign}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'ReferenceAssign}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'List}}{}\syntaxCont{{}\terminal{'ListAssign}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Isset}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Unset}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Class}}{}\syntaxCont{{}\terminal{'InstanceVariable}}{}\syntaxCont{{}\terminal{'Modifiers}}{}\syntaxCont{{}\terminal{'Default}}{}\syntaxCont{{}\terminal{'MethodBody}}{}\syntaxCont{{}\terminal{'Public}}{}\syntaxCont{{}\terminal{'Private}}{}\syntaxCont{{}\terminal{'Protected}}{}\syntaxCont{{}\terminal{'Normal}}{}\syntaxCont{{}\terminal{'Extends}}{}\syntaxCont{{}\terminal{'Static}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'ObjectCreation}}{}\syntaxCont{{}\terminal{'ClassName}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'ObjectAccess}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'ObjectProperty}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Array}}{}\syntaxCont{{}\terminal{'Pair}}{}\syntaxCont{{}\terminal{'Key}}{}\syntaxCont{{}\terminal{'Value}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'StaticFunctionCall}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'ClassConstant}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Echo}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'InlineEcho}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'ConstantVariable}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'ConstantEncapsedString}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'DoubleQuoted}}{}\syntaxCont{{}\terminal{'DQContent}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'SingleQuoted}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Concat}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'ConcatAssign}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Escape}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'PostDec}}{}\syntaxCont{{}\terminal{'PostInc}}{}\syntaxCont{{}\terminal{'PreDec}}{}\syntaxCont{{}\terminal{'PreInc}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Negative}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Positive}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Plus}}{\kattribute{transition}}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Min}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Mul}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Div}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Mod}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'IsEqual}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'IsIdentical}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'IsNotIdentical}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'IsNotEqual}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Less}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Greater}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'LessEqual}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'GreaterEqual}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'And}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Or}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'LXor}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Not}}{}
\end{syntaxBlock}
\kcontext{
'Not(\khole{})}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'LAnd}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'LOr}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'IntCast}}{}\syntaxCont{{}\terminal{'StringCast}}{}\syntaxCont{{}\terminal{'BoolCast}}{}\syntaxCont{{}\terminal{'FloatCast}}{}\syntaxCont{{}\terminal{'ObjectCast}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Try}}{}\syntaxCont{{}\terminal{'Catch}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Throw}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'FunctionDecl}}{}\syntaxCont{{}\terminal{'FunctionDeclRef}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'FunctionName}}{}\syntaxCont{{}\terminal{'FunctionCall}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Return}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'DeclareStatic}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'DeclareGlobal}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'ParamDefault}}{}\syntaxCont{{}\terminal{'Param}}{}\syntaxCont{{}\terminal{'ParamRef}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'If}}{}\syntaxCont{{}\terminal{'AltIf}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Ternary}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Break}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'While}}{}\syntaxCont{{}\terminal{'AltWhile}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'For}}{}\syntaxCont{{}\terminal{'AltFor}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Switch}}{}\syntaxCont{{}\terminal{'AltSwitch}}{}\syntaxCont{{}\terminal{'Case}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'DoWhile}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'ForEach}}{}\syntaxCont{{}\terminal{'Pattern}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'Include}}{}\syntaxCont{{}\terminal{'Require}}{}\syntaxCont{{}\terminal{'RequireOnce}}{}
\end{syntaxBlock}
\end{module}
\begin{module}{\moduleName{MODEL-CHECKING}}
\begin{kblock}[text]
 \section{Model checking} \end{kblock}
\begin{kblock}[text]

    A input program is a sequence of statements or a LTL Formula 
    (this is needed for parsing purposes)
  \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{\nonTerminal{\sort{LtlFormula}}}}{}
\end{syntaxBlock}
\begin{kblock}[text]

    The interface to the model-checker, given by the module \texttt{LTL-HOOKS}.
    The module \texttt{MODEL-CHECKER-HOOKS} is a \K interface to the Maude module 
    defining the syntax for the model-checker. 
    In addition to this interface, we have to define the atomic propositions.
    The states of the transition system to be model-checked are given
    by the configurations of programs, which are of sort \texttt{Bag}.
    Semantic transition rules must be annotated with the lable "kripke" if they are meant to introduce a transition from their pre-condition state to their post-condition state. Otherwise, both states will be in the same equivalence class as far as the model checker is concerned.
   \end{kblock}
\begin{kblock}[text]
 \subsection{Logic Language} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{KeyList}}}\syntax{List\{{\nonTerminal{\sort{Key}}}, \mbox{``},\mbox{''}\}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{Exp}}}\syntax{{}\terminal{gv}({{\nonTerminal{\sort{Variable}}}})}{}\syntaxCont{{}\terminal{fv}({{\nonTerminal{\sort{String}}}},{{\nonTerminal{\sort{Variable}}}})}{}\syntaxCont{{}\terminal{val}({{\nonTerminal{\sort{LanguageValue}}}})}{}\syntaxCont{{}\terminal{len}({{\nonTerminal{\sort{Exp}}}})}{}\syntaxCont{{{\nonTerminal{\sort{Exp}}}}\terminal{+}{{\nonTerminal{\sort{Exp}}}}}{\kattribute{strict}}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{Variable}}}\syntax{{}\terminal{variable}({{\nonTerminal{\sort{Key}}}})}{}\syntaxCont{{}\terminal{array}({{\nonTerminal{\sort{KeyList}}}})}{}
\end{syntaxBlock}
\begin{kblock}[text]
 \subsection{gettype} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Type}}}\syntax{{}\terminal{type}({{\nonTerminal{\sort{LanguageValue}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{type}({\variable[Int]{V}})}{{}\terminal{int}}}{}{}{}{}
\krule{
\reduce{{}\terminal{type}({\variable[Bool]{V}})}{{}\terminal{bool}}}{}{}{}{}
\krule{
\reduce{{}\terminal{type}({\variable[Float]{V}})}{{}\terminal{float}}}{}{}{}{}
\krule{
\reduce{{}\terminal{type}({\variable[String]{V}})}{{}\terminal{string}}}{}{}{}{}
\krule{
\reduce{{}\terminal{type}({\variable[Array]{V}})}{{}\terminal{array}}}{}{}{}{}
\krule{
\reduce{{}\terminal{type}({\variable[Object]{V}})}{{}\terminal{object}}}{}{}{}{}
\krule{
\reduce{{}\terminal{type}({{}\terminal{NULL}})}{{}\terminal{unset}}}{}{}{}{}
\begin{kblock}[text]
 \subsection{Arithmetic} \end{kblock}
\begin{kblock}[text]
 \subsection{Propositions} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Prop}}}\syntax{{}\terminal{eqTo}({{\nonTerminal{\sort{Exp}}}},{{\nonTerminal{\sort{Exp}}}})}{}
\end{syntaxBlock}
\krule{
\reduce{{\variable[Bag]{B}}\mathrel{\models_{\scriptstyle\it Ltl}}{{}\terminal{eqTo}({\variable[Exp]{E1}},{\variable[Exp]{E2}})}}{\constant[\#Bool]{true}}}{{{}\terminal{expEval}({\variable[Bag]{B}},{\variable[Exp]{E1}})}\mathrel{=_K}{{}\terminal{expEval}({\variable[Bag]{B}},{\variable[Exp]{E2}})}}{}{\kattribute{anywhere}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Prop}}}\syntax{{}\terminal{lab}({{\nonTerminal{\sort{String}}}})}{}
\end{syntaxBlock}
\krule{
\reduce{{\variable[Bag]{B}}\mathrel{\models_{\scriptstyle\it Ltl}}{{}\terminal{lab}({\variable[String]{X}})}}{\constant[\#Bool]{true}}}{{{}\terminal{get\_config\_label}({\variable[Bag]{B}})}\terminal{==String}{\variable[String]{X}}}{}{\kattribute{anywhere}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Prop}}}\syntax{{}\terminal{alias}({{\nonTerminal{\sort{Exp}}}},{{\nonTerminal{\sort{Exp}}}})}{}
\end{syntaxBlock}
\krule{
\reduce{{\variable[Bag]{B}}\mathrel{\models_{\scriptstyle\it Ltl}}{{}\terminal{alias}({\variable[Exp]{E1}},{\variable[Exp]{E2}})}}{\constant[\#Bool]{true}}}{{{}\terminal{expEvalLoc}({\variable[Bag]{B}},{\variable[Exp]{E1}})}\mathrel{=_K}{{}\terminal{expEvalLoc}({\variable[Bag]{B}},{\variable[Exp]{E2}})}}{}{\kattribute{anywhere}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Prop}}}\syntax{{}\terminal{hasType}({{\nonTerminal{\sort{Exp}}}},{{\nonTerminal{\sort{Type}}}})}{}
\end{syntaxBlock}
\krule{
\reduce{{\variable[Bag]{B}}\mathrel{\models_{\scriptstyle\it Ltl}}{{}\terminal{hasType}({\variable[Exp]{E}},{\variable[Type]{T}})}}{\constant[\#Bool]{true}}}{{{}\terminal{type}({{}\terminal{expEval}({\variable[Bag]{B}},{\variable[Exp]{E}})})}\mathrel{=_K}{\variable[Type]{T}}}{}{\kattribute{anywhere}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Prop}}}\syntax{{}\terminal{geq}({{\nonTerminal{\sort{Exp}}}},{{\nonTerminal{\sort{Exp}}}})}{}
\end{syntaxBlock}
\krule{
\reduce{{\variable[Bag]{B}}\mathrel{\models_{\scriptstyle\it Ltl}}{{}\terminal{geq}({\variable[Exp]{E1}},{\variable[Exp]{E2}})}}{\constant[\#Bool]{true}}}{{}\terminal{geqVal}({{}\terminal{expEval}({\variable[Bag]{B}},{\variable[Exp]{E1}})},{{}\terminal{expEval}({\variable[Bag]{B}},{\variable[Exp]{E2}})})}{}{\kattribute{anywhere}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Prop}}}\syntax{{}\terminal{leq}({{\nonTerminal{\sort{Exp}}}},{{\nonTerminal{\sort{Exp}}}})}{}
\end{syntaxBlock}
\krule{
\reduce{{\variable[Bag]{B}}\mathrel{\models_{\scriptstyle\it Ltl}}{{}\terminal{leq}({\variable[Exp]{E1}},{\variable[Exp]{E2}})}}{\constant[\#Bool]{true}}}{{}\terminal{leqVal}({{}\terminal{expEval}({\variable[Bag]{B}},{\variable[Exp]{E1}})},{{}\terminal{expEval}({\variable[Bag]{B}},{\variable[Exp]{E2}})})}{}{\kattribute{anywhere}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Prop}}}\syntax{{}\terminal{inFun}({{\nonTerminal{\sort{String}}}})}{}
\end{syntaxBlock}
\krule{
\reduce{{\variable[Bag]{B}}\mathrel{\models_{\scriptstyle\it Ltl}}{{}\terminal{inFun}({\variable[String]{X}})}}{\constant[\#Bool]{true}}}{{{}\terminal{get\_crnt\_fun}({\variable[Bag]{B}})}\terminal{==String}{\variable[String]{X}}}{}{\kattribute{anywhere}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{geqVal}({{\nonTerminal{\sort{LanguageValue}}}},{{\nonTerminal{\sort{LanguageValue}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{geqVal}({\variable[Int]{V1}},{\variable[Int]{V2}})}{{\variable[Int]{V1}}\mathrel{\geq_{\scriptstyle\it Int}}{\variable[Int]{V2}}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{leqVal}({{\nonTerminal{\sort{LanguageValue}}}},{{\nonTerminal{\sort{LanguageValue}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{leqVal}({\variable[Int]{V1}},{\variable[Int]{V2}})}{{\variable[Int]{V1}}\mathrel{\leq_{\scriptstyle\it Int}}{\variable[Int]{V2}}}}{}{}{}{}
\begin{kblock}[text]
 \subsection{Evaluation function for expressions} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{LanguageValue}}}\syntax{{}\terminal{expEval}({{\nonTerminal{\sort{Bag}}}},{{\nonTerminal{\sort{Exp}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{expEval}({\variable[Bag]{B}},{{}\terminal{gv}({\variable[Variable]{X}})})}{{}\terminal{read}({\variable[Bag]{B}},{{}\terminal{lookup\_glob}({\variable[Bag]{B}},{\variable[Variable]{X}})})}}{}{}{}{}
\krule{
\reduce{{}\terminal{expEval}({\variable[Bag]{B}},{{}\terminal{fv}({\variable[K]{FName}},{\variable[Variable]{X}})})}{{}\terminal{read}({\variable[Bag]{B}},{{}\terminal{lookup\_fun}({\variable[Bag]{B}},{\variable[K]{FName}},{\variable[Variable]{X}})})}}{}{}{}{}
\krule{
\reduce{{}\terminal{expEval}({\variable[Bag]{B}},{{}\terminal{len}({\variable[Exp]{X}})})}{{}\terminal{myStrlen}({\variable[Bag]{B}},{{}\terminal{expEvalLoc}({\variable[Bag]{B}},{\variable[Exp]{X}})})}}{}{}{}{}
\krule{
\reduce{{}\terminal{expEval}({\AnyVar[Bag]},{{}\terminal{val}({\variable[K]{V}})})}{\variable[K]{V}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Int}}}\syntax{{}\terminal{myStrlen}({{\nonTerminal{\sort{Bag}}}},{{\nonTerminal{\sort{Loc}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{myStrlen}({\kmiddle{generatedTop}{\kmiddle{T}{\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[String]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
}
}
},{\variable[Loc]{L}})}{{}\terminal{lengthString}({\variable[String]{V}})}}{{\variable[Loc]{L}}\mathrel{\neq_K}{{}\terminal{locNull}}}{}{}{}
\krule{
\reduce{{}\terminal{myStrlen}({\kmiddle{generatedTop}{\kmiddle{T}{\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[LanguageValue]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
}
}
},{\variable[Loc]{L}})}{\constant[\#Int]{0}}}{{\left({{\variable[Loc]{L}}\mathrel{\neq_K}{{}\terminal{locNull}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{{}\terminal{\#isStringType}({\variable[LanguageValue]{V}})}}\right)}}{}{}{}
\begin{kblock}[text]
 \subsection{Evaluation to a location} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Loc}}}\syntax{{}\terminal{expEvalLoc}({{\nonTerminal{\sort{Bag}}}},{{\nonTerminal{\sort{Exp}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{expEvalLoc}({\variable[Bag]{B}},{{}\terminal{gv}({\variable[Variable]{X}})})}{{}\terminal{lookup\_glob}({\variable[Bag]{B}},{\variable[Variable]{X}})}}{}{}{}{}
\krule{
\reduce{{}\terminal{expEvalLoc}({\variable[Bag]{B}},{{}\terminal{fv}({\variable[K]{FName}},{\variable[Variable]{X}})})}{{}\terminal{lookup\_fun}({\variable[Bag]{B}},{\variable[K]{FName}},{\variable[Variable]{X}})}}{}{}{}{}
\krule{
\reduce{{}\terminal{expEvalLoc}({\AnyVar[Bag]},{{}\terminal{val}({\variable[K]{V}})})}{{}\terminal{locNull}}}{}{}{}{}
\begin{kblock}[text]
 \subsection{Lookup} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Loc}}}\syntax{{}\terminal{lookup\_glob}({{\nonTerminal{\sort{Bag}}}},{{\nonTerminal{\sort{Variable}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{lookup\_glob}({\variable[Bag]{B}},{\variable[Variable]{X}})}{{}\terminal{lvalue}({\variable[Bag]{B}},{{}\terminal{getGlobalScope}({\variable[Bag]{B}})},{\variable[Variable]{X}})}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{Loc}}}\syntax{{}\terminal{lookup\_fun}({{\nonTerminal{\sort{Bag}}}},{{\nonTerminal{\sort{String}}}},{{\nonTerminal{\sort{Variable}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{lookup\_fun}({\variable[Bag]{B}},{\variable[String]{FunName}},{\variable[Variable]{X}})}{{}\terminal{lvalue}({\variable[Bag]{B}},{{}\terminal{getFunScope}({\variable[Bag]{B}},{\variable[String]{FunName}})},{\variable[Variable]{X}})}}{}{}{}{}
\begin{kblock}[text]
 \subsection{get global scope} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Loc}}}\syntax{{}\terminal{getGlobalScope}({{\nonTerminal{\sort{Bag}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{getGlobalScope}({\kmiddle{generatedTop}{\kmiddle{T}{\kall{globalScope}{\variable[Loc]{L}}
}
}
})}{\variable[Loc]{L}}}{}{}{}{}
\begin{kblock}[text]
 \subsection{get function scope} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Loc}}}\syntax{{}\terminal{getFunScope}({{\nonTerminal{\sort{Bag}}}},{{\nonTerminal{\sort{String}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{getFunScope}({\kmiddle{generatedTop}{\kmiddle{T}{\kmiddle{control}{\kprefix{functionStack}{{}\terminal{sf}({\variable[String]{FName}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
}
\mathrel{}\kall{currentScope}{\variable[Loc]{L}}
}
}
},{\variable[String]{FName}})}{\variable[Loc]{L}}}{}{}{}{}
\begin{kblock}[text]
 \subsection{get current function} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{String}}}\syntax{{}\terminal{get\_crnt\_fun}({{\nonTerminal{\sort{Bag}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{get\_crnt\_fun}({\kmiddle{generatedTop}{\kmiddle{T}{\kmiddle{control}{\kprefix{functionStack}{{}\terminal{sf}({\variable[String]{F}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
}
}
}
})}{\variable[String]{F}}}{}{}{}{}
\krule{
\reduce{{}\terminal{get\_crnt\_fun}({\kmiddle{generatedTop}{\kmiddle{T}{\kmiddle{control}{\kall{functionStack}{\dotCt{List}}
}
}
}
})}{\constant[\#String]{"top"}}}{}{}{}{}
\begin{kblock}[text]
 \subsection{lvalue} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{Loc}}}\syntax{{}\terminal{lvalue}({{\nonTerminal{\sort{Bag}}}},{{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{Variable}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
{}\terminal{lvalue}({\variable[Bag]{B}},{\variable[Loc]{L}},{\reduce{{}\terminal{variable}({\variable[Key]{X}})}{{}\terminal{array}({{\variable[Key]{X}}\mathpunct{\terminalNoSpace{,}}{\dotCt{KeyList}}})}})}{}{}{}{}
\krule{
{}\terminal{lvalue}({\kmiddle{generatedTop}{\kmiddle{T}{\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\AnyVar[List]\mathrel{}[{\variable[Key]{X1}},{\AnyVar[K]},{\variable[K]{L1}}]\mathrel{}\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[K]{L1}\mapsto{}\terminal{zval}({\variable[Array]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
}
}
},{\reduce{\variable[Loc]{L}}{\variable[K]{L1}}},{\left({{}\terminal{array}({\reduce{\left({{\variable[Key]{X1}}\mathpunct{\terminalNoSpace{,}}{\variable[KeyList]{Path}}}\right)}{\variable[KeyList]{Path}}})}\right)})}{\neg_{\scriptstyle\it Bool}{\left({{\variable[KeyList]{Path}}\mathrel{=_K}{\dotCt{KeyList}}}\right)}}{}{}{}
\krule{
\reduce{{}\terminal{lvalue}({\kmiddle{generatedTop}{\kmiddle{T}{\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{Elems}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
}
}
},{\variable[Loc]{L}},{{}\terminal{array}({{\variable[Key]{X1}}\mathpunct{\terminalNoSpace{,}}{\AnyVar[K]}})})}{{}\terminal{locNull}}}{\neg_{\scriptstyle\it Bool}{\left({{\variable[List]{Elems}}\terminal{hasProperty}{\variable[Key]{X1}}}\right)}}{}{}{}
\krule{
\reduce{{}\terminal{lvalue}({\kmiddle{generatedTop}{\kmiddle{T}{\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\AnyVar[List]\mathrel{}[{\variable[String]{X}},{\AnyVar[K]},{\variable[K]{L1}}]\mathrel{}\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
}
}
},{\variable[Loc]{L}},{{}\terminal{array}({{\variable[String]{X}}\mathpunct{\terminalNoSpace{,}}{\dotCt{KeyList}}})})}{\variable[K]{L1}}}{}{}{}{}
\begin{kblock}[text]
 \subsection{read} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{LanguageValue}}}\syntax{{}\terminal{read}({{\nonTerminal{\sort{Bag}}}},{{\nonTerminal{\sort{Loc}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{read}({\kmiddle{generatedTop}{\kmiddle{T}{\kmiddle{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[LanguageValue]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
}
}
},{\variable[Loc]{L}})}{\variable[LanguageValue]{V}}}{{\variable[Loc]{L}}\mathrel{\neq_K}{{}\terminal{locNull}}}{}{}{}
\krule{
\reduce{{}\terminal{read}({\AnyVar[Bag]},{{}\terminal{locNull}})}{{}\terminal{NULL}}}{}{}{}{}
\begin{kblock}[text]
 \subsection{Label} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{String}}}\syntax{{}\terminal{get\_config\_label}({{\nonTerminal{\sort{Bag}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{get\_config\_label}({\kmiddle{generatedTop}{\kmiddle{T}{\kmiddle{instrumentation}{\kall{label}{\variable[String]{S}}
}
}
}
})}{\variable[String]{S}}}{}{}{}{}
\end{module}
\begin{module}{\moduleName{ARITH-OPS}}
\begin{kblock}[text]
 \section{Arithmetic operations} \end{kblock}
\begin{kblock}[text]
 \subsection{Negation} \end{kblock}
\krule[negative]{
\kprefix{k}{\reduce{'Negative(\variable[K]{X})}{'Min(\constant[\#Int]{0}\kcomma\variable[K]{X})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"negative"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Positive} 
		It does nothing! \end{kblock}
\krule[positive]{
\kprefix{k}{\reduce{'Positive(\variable[K]{X})}{\variable[K]{X}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"positive"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Addition} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{BinaryOp}}}\syntax{{}\terminal{plus}}{}\syntaxCont{{}\terminal{min}}{}\syntaxCont{{}\terminal{mul}}{}\syntaxCont{{}\terminal{div}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{BinOp}({{\nonTerminal{\sort{BinaryOp}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[plus]{
\kprefix{k}{\reduce{'Plus(\variable[K]{L}\kcomma\variable[K]{R})}{{}\terminal{BinOp}({{}\terminal{plus}},{\variable[K]{L}},{\variable[K]{R}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus"}}}
}{}{}{\kattribute{step}}{}
\krule[min]{
\kprefix{k}{\reduce{'Min(\variable[K]{L}\kcomma\variable[K]{R})}{{}\terminal{BinOp}({{}\terminal{min}},{\variable[K]{L}},{\variable[K]{R}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"min"}}}
}{}{}{\kattribute{step}}{}
\krule[mul]{
\kprefix{k}{\reduce{'Mul(\variable[K]{L}\kcomma\variable[K]{R})}{{}\terminal{BinOp}({{}\terminal{mul}},{\variable[K]{L}},{\variable[K]{R}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"mul"}}}
}{}{}{\kattribute{step}}{}
\krule[div]{
\kprefix{k}{\reduce{'Div(\variable[K]{L}\kcomma\variable[K]{R})}{{}\terminal{BinOp}({{}\terminal{div}},{\variable[K]{L}},{\variable[K]{R}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"div"}}}
}{}{}{\kattribute{step}}{}
\kcontext{
{}\terminal{BinOp}({\AnyVar[K]},{\khole{}},{\AnyVar[K]})}{}{}{}
\kcontext{
{}\terminal{BinOp}({\AnyVar[K]},{\AnyVar[BasicRef]},{\khole{}})}{}{}{}
\kcontext{
{}\terminal{BinOp}({\AnyVar[K]},{\AnyVar[LanguageValue]},{\khole{}})}{}{}{}
\krule[binop-LHS2LangValue-lref]{
\kprefix{k}{{}\terminal{BinOp}({\AnyVar[K]},{\reduce{\variable[LRef]{R}}{{}\terminal{convertToLanguageValue}({\variable[LRef]{R}})}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-LHS2LangValue-lref"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[binop-LHS2LangValue-loc]{
\kprefix{k}{{}\terminal{BinOp}({\AnyVar[K]},{\reduce{\variable[Loc]{R}}{{}\terminal{convertToLanguageValue}({\variable[Loc]{R}})}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-LHS2LangValue-loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[binop-RHS2LangValue-1]{
\kprefix{k}{{}\terminal{BinOp}({\AnyVar[K]},{\AnyVar[LanguageValue]},{\reduce{\variable[ConvertibleToLanguageValue]{V1}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{V1}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-RHS2LangValue-1"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[binop-RHS2LangValue-2]{
\kprefix{k}{{}\terminal{BinOp}({\AnyVar[K]},{\AnyVar[BasicRef]},{\reduce{\variable[ConvertibleToLanguageValue]{V1}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{V1}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-RHS2LangValue-2"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[binop-LHS2LangValue]{
\kprefix{k}{{}\terminal{BinOp}({\AnyVar[K]},{\reduce{\variable[BasicRef]{V}}{{}\terminal{convertToLanguageValue}({\variable[BasicRef]{V}})}},{\AnyVar[LanguageValue]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-LHS2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[binop-RHS2Float]{
\kprefix{k}{{}\terminal{BinOp}({\AnyVar[K]},{\variable[Float]{V1}},{\reduce{\variable[LanguageValue]{V2}}{'FloatCast(\variable[LanguageValue]{V2})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-RHS2Float"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isFloatType}({\variable[LanguageValue]{V2}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[binop-LHS2Float]{
\kprefix{k}{{}\terminal{BinOp}({\AnyVar[K]},{\reduce{\variable[LanguageValue]{V1}}{'FloatCast(\variable[LanguageValue]{V1})}},{\variable[Float]{V2}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-LHS2Float"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isFloatType}({\variable[LanguageValue]{V1}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[binop-RHS2Int]{
\kprefix{k}{{}\terminal{BinOp}({\AnyVar[K]},{\variable[Int]{V1}},{\reduce{\variable[String]{V2}}{{}\terminal{\#string2Number}({\variable[String]{V2}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-RHS2Int"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[binop-LHS2Int]{
\kprefix{k}{{}\terminal{BinOp}({\AnyVar[K]},{\reduce{\variable[String]{V2}}{{}\terminal{\#string2Number}({\variable[String]{V2}})}},{\variable[Int]{V1}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-LHS2Int"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[binop-plus-int]{
\kprefix{k}{\reduce{{}\terminal{BinOp}({{}\terminal{plus}},{\variable[Int]{I1}},{\variable[Int]{I2}})}{{\variable[Int]{I1}}\mathrel{+_{\scriptstyle\it Int}}{\variable[Int]{I2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-int"}}}
}{}{}{\kattribute{step}}{}
\krule[binop-plus-float]{
\kprefix{k}{\reduce{{}\terminal{BinOp}({{}\terminal{plus}},{\variable[Float]{F1}},{\variable[Float]{F2}})}{{\variable[Float]{F1}}\mathrel{+_{\scriptstyle\it Float}}{\variable[Float]{F2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-float"}}}
}{}{}{\kattribute{step}}{}
\krule[binop-min-int]{
\kprefix{k}{\reduce{{}\terminal{BinOp}({{}\terminal{min}},{\variable[Int]{I1}},{\variable[Int]{I2}})}{{\variable[Int]{I1}}\mathrel{-_{\scriptstyle\it Int}}{\variable[Int]{I2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-int"}}}
}{}{}{\kattribute{step}}{}
\krule[binop-min-float]{
\kprefix{k}{\reduce{{}\terminal{BinOp}({{}\terminal{min}},{\variable[Float]{F1}},{\variable[Float]{F2}})}{{\variable[Float]{F1}}\mathrel{-_{\scriptstyle\it Float}}{\variable[Float]{F2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-float"}}}
}{}{}{\kattribute{step}}{}
\krule[binop-mul-int]{
\kprefix{k}{\reduce{{}\terminal{BinOp}({{}\terminal{mul}},{\variable[Int]{I1}},{\variable[Int]{I2}})}{{\variable[Int]{I1}}\mathrel{\ast_{\scriptstyle\it Int}}{\variable[Int]{I2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-int"}}}
}{}{}{\kattribute{step}}{}
\krule[binop-mul-float]{
\kprefix{k}{\reduce{{}\terminal{BinOp}({{}\terminal{mul}},{\variable[Float]{F1}},{\variable[Float]{F2}})}{{\variable[Float]{F1}}\mathrel{\ast_{\scriptstyle\it Float}}{\variable[Float]{F2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-float"}}}
}{}{}{\kattribute{step}}{}
\krule[binop-div-int]{
\kprefix{k}{\reduce{{}\terminal{BinOp}({{}\terminal{div}},{\variable[Int]{I1}},{\variable[Int]{I2}})}{{\variable[Int]{I1}}\mathrel{\div_{\scriptstyle\it Int}}{\variable[Int]{I2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-int"}}}
}{}{}{\kattribute{step}}{}
\krule[binop-div-float]{
\kprefix{k}{\reduce{{}\terminal{BinOp}({{}\terminal{div}},{\variable[Float]{F1}},{\variable[Float]{F2}})}{{\variable[Float]{F1}}\mathrel{\div_{\scriptstyle\it Float}}{\variable[Float]{F2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"plus-float"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \subsection{Modulus} \end{kblock}
\kcontext{
'Mod(\khole{}\kcomma\AnyVar[K])}{}{}{}
\kcontext{
'Mod(\AnyVar[K]\kcomma\khole{})}{}{}{}
\krule[mod-args2LangValue]{
\kprefix{k}{'Mod(\reduce{\variable[Ref]{R1}}{{}\terminal{convertToLanguageValue}({\variable[Ref]{R1}})}\kcomma\reduce{\variable[Ref]{R2}}{{}\terminal{convertToLanguageValue}({\variable[Ref]{R2}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"mod-args2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[mod-RHS2LangValue]{
\kprefix{k}{'Mod(\variable[ScalarValue]{V1}\kcomma\reduce{\variable[Ref]{R2}}{{}\terminal{convertToLanguageValue}({\variable[Ref]{R2}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"mod-RHS2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[mod-LHS2LangValue]{
\kprefix{k}{'Mod(\reduce{\variable[Ref]{R1}}{{}\terminal{convertToLanguageValue}({\variable[Ref]{R1}})}\kcomma\variable[ScalarValue]{V2})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"mod-LHS2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[mod-RHS2Int]{
\kprefix{k}{'Mod(\variable[Value]{V1}\kcomma\reduce{\variable[Value]{V2}}{'IntCast(\variable[Value]{V2})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"mod-RHS2Int"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isIntType}({\variable[Value]{V2}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[mod-LHS2Int]{
\kprefix{k}{'Mod(\reduce{\variable[Value]{V1}}{'IntCast(\variable[Value]{V1})}\kcomma\variable[Value]{V2})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"mod-LHS2Int"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isIntType}({\variable[Value]{V1}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[mod]{
\kprefix{k}{\reduce{'Mod(\variable[Int]{I1}\kcomma\variable[Int]{I2})}{{\variable[Int]{I1}}\terminal{modInt}{\variable[Int]{I2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"mod"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \section{Comparison operators} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{NonStrictComparisonOp}}}\syntax{{}\terminal{equal}}{}\syntaxCont{{}\terminal{less}}{}\syntaxCont{{}\terminal{lessEqual}}{}\syntaxCont{{}\terminal{greater}}{}\syntaxCont{{}\terminal{greaterEqual}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{StrictComparisonOp}}}\syntax{{}\terminal{identical}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{ComparisonOp}}}\syntax{{\nonTerminal{\sort{StrictComparisonOp}}}}{}\syntaxCont{{\nonTerminal{\sort{NonStrictComparisonOp}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{Bool}}}\syntax{{}\terminal{isStrictComparison}({{\nonTerminal{\sort{ComparisonOp}}}})}{\kattribute{function}}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{isStrictComparison}({\variable[StrictComparisonOp]{Op}})}{\constant[\#Bool]{true}}}{}{}{}{}
\krule{
\reduce{{}\terminal{isStrictComparison}({\variable[NonStrictComparisonOp]{Op}})}{\constant[\#Bool]{false}}}{}{}{}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{comparison}({{\nonTerminal{\sort{ComparisonOp}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[isEqual]{
\kprefix{k}{\reduce{'IsEqual(\variable[K]{L}\kcomma\variable[K]{R})}{{}\terminal{comparison}({{}\terminal{equal}},{\variable[K]{L}},{\variable[K]{R}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual"}}}
}{}{}{\kattribute{step}}{}
\krule[isIdentical]{
\kprefix{k}{\reduce{'IsIdentical(\variable[K]{L}\kcomma\variable[K]{R})}{{}\terminal{comparison}({{}\terminal{identical}},{\variable[K]{L}},{\variable[K]{R}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isIdentical"}}}
}{}{}{\kattribute{step}}{}
\krule[less]{
\kprefix{k}{\reduce{'Less(\variable[K]{L}\kcomma\variable[K]{R})}{{}\terminal{comparison}({{}\terminal{less}},{\variable[K]{L}},{\variable[K]{R}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"less"}}}
}{}{}{\kattribute{step}}{}
\krule[lessEqual]{
\kprefix{k}{\reduce{'LessEqual(\variable[K]{L}\kcomma\variable[K]{R})}{{}\terminal{comparison}({{}\terminal{lessEqual}},{\variable[K]{L}},{\variable[K]{R}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lessEqual"}}}
}{}{}{\kattribute{step}}{}
\krule[greater]{
\kprefix{k}{\reduce{'Greater(\variable[K]{L}\kcomma\variable[K]{R})}{{}\terminal{comparison}({{}\terminal{greater}},{\variable[K]{L}},{\variable[K]{R}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greater"}}}
}{}{}{\kattribute{step}}{}
\krule[greaterEqual]{
\kprefix{k}{\reduce{'GreaterEqual(\variable[K]{L}\kcomma\variable[K]{R})}{{}\terminal{comparison}({{}\terminal{greaterEqual}},{\variable[K]{L}},{\variable[K]{R}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greaterEqual"}}}
}{}{}{\kattribute{step}}{}
\kcontext{
{}\terminal{comparison}({\AnyVar[K]},{\khole{}},{\AnyVar[K]})}{}{}{}
\kcontext{
{}\terminal{comparison}({\AnyVar[K]},{\AnyVar[K]},{\khole{}})}{}{}{}
\krule[isEqual-LHS2Loc]{
\kprefix{k}{{}\terminal{comparison}({\AnyVar[K]},{\reduce{\variable[ConvertibleToLoc]{CL}}{{}\terminal{convertToLoc}({\variable[ConvertibleToLoc]{CL}},{{}\terminal{r}})}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-LHS2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[isEqual-RHS2Loc]{
\kprefix{k}{{}\terminal{comparison}({\AnyVar[K]},{\AnyVar[K]},{\reduce{\variable[ConvertibleToLoc]{CL}}{{}\terminal{convertToLoc}({\variable[ConvertibleToLoc]{CL}},{{}\terminal{r}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-LHS2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[isEqual-LHS2LangValue]{
\kprefix{k}{{}\terminal{comparison}({\AnyVar[K]},{\reduce{\variable[Loc]{L}}{\variable[Value]{V}}},{\AnyVar[K]})}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-LHS2LangValue"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[Value]{V}}\terminal{isCompoundValue}}\right)}}{}{\kattribute{intermediate}}{}
\krule[isEqual-RHS2LangValue]{
\kprefix{k}{{}\terminal{comparison}({\AnyVar[K]},{\AnyVar[K]},{\reduce{\variable[Loc]{L}}{\variable[Value]{V}}})}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-RHS2LangValue"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[Value]{V}}\terminal{isCompoundValue}}\right)}}{}{\kattribute{intermediate}}{}
\krule[isEqual-type-juggling-1-1]{
\kprefix{k}{{}\terminal{comparison}({\variable[ComparisonOp]{Op}},{\reduce{{}\terminal{NULL}}{\constant[\#String]{""}}},{\variable[String]{S}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-type-juggling-1"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{isStrictComparison}({\variable[ComparisonOp]{Op}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[isEqual-type-juggling-1-2]{
\kprefix{k}{{}\terminal{comparison}({\variable[ComparisonOp]{Op}},{\variable[String]{S}},{\reduce{{}\terminal{NULL}}{\constant[\#String]{""}}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-type-juggling-1"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{isStrictComparison}({\variable[ComparisonOp]{Op}})}\right)}}{}{\kattribute{intermediate}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{BoolOrNull}}}\syntax{{\nonTerminal{\sort{Bool}}}}{}\syntaxCont{{\nonTerminal{\sort{Null}}}}{}
\end{syntaxBlock}

\begin{syntaxBlock}{\nonTerminal{\sort{LanguageValue}}}\syntax{{\nonTerminal{\sort{BoolOrNull}}}}{}
\end{syntaxBlock}
\krule[isEqual-type-juggling-2]{
\kprefix{k}{{}\terminal{comparison}({\variable[ComparisonOp]{Op}},{\reduce{\variable[BoolOrNull]{B}}{{}\terminal{*toBoolean}({\variable[BoolOrNull]{B}})}},{\reduce{\variable[LanguageValue]{V2}}{{}\terminal{*toBoolean}({\variable[LanguageValue]{V2}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-type-juggling-2"}}}
}{{\neg_{\scriptstyle\it Bool}{\left({{\left({{}\terminal{\#isStringType}({\variable[LanguageValue]{V2}})}\right)}\vee_{\scriptstyle\it Bool}{\left({{}\terminal{\#isBoolType}({\variable[LanguageValue]{V2}})}\right)}}\right)}}\wedge_{\scriptstyle\it Bool}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{isStrictComparison}({\variable[ComparisonOp]{Op}})}\right)}}}{}{\kattribute{intermediate}}{}
\krule[isEqual-type-juggling-3]{
\kprefix{k}{{}\terminal{comparison}({\variable[ComparisonOp]{Op}},{\reduce{\variable[LanguageValue]{V2}}{{}\terminal{*toBoolean}({\variable[LanguageValue]{V2}})}},{\reduce{\variable[BoolOrNull]{B}}{{}\terminal{*toBoolean}({\variable[BoolOrNull]{B}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-type-juggling-2"}}}
}{{\neg_{\scriptstyle\it Bool}{\left({{\left({{}\terminal{\#isStringType}({\variable[LanguageValue]{V2}})}\right)}\vee_{\scriptstyle\it Bool}{\left({{}\terminal{\#isBoolType}({\variable[LanguageValue]{V2}})}\right)}}\right)}}\wedge_{\scriptstyle\it Bool}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{isStrictComparison}({\variable[ComparisonOp]{Op}})}\right)}}}{}{\kattribute{intermediate}}{}
\krule{
{}\terminal{comparison}({\variable[ComparisonOp]{Op}},{\reduce{\variable[String]{V1}}{{}\terminal{\#string2Number}({\variable[String]{V1}})}},{\AnyVar[K]})}{{\left({{}\terminal{isNumericString}({\variable[String]{V1}})}\right)}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{\left({{}\terminal{isStrictComparison}({\variable[ComparisonOp]{Op}})}\right)}}\right)}}{}{}{}
\krule{
{}\terminal{comparison}({\variable[ComparisonOp]{Op}},{\AnyVar[K]},{\reduce{\variable[String]{V2}}{{}\terminal{\#string2Number}({\variable[String]{V2}})}})}{{\left({{}\terminal{isNumericString}({\variable[String]{V2}})}\right)}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{\left({{}\terminal{isStrictComparison}({\variable[ComparisonOp]{Op}})}\right)}}\right)}}{}{}{}
\krule[comparison-ac]{
\kprefix{k}{{}\terminal{comparison}({\variable[ComparisonOp]{Op}},{\variable[Value]{V1}},{\reduce{\variable[String]{S}}{\constant[\#Int]{0}}})}
}{{{\left({\neg_{\scriptstyle\it Bool}{{}\terminal{\#isStringType}({\variable[Value]{V1}})}}\right)}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{{}\terminal{isNumericString}({\variable[String]{S}})}}\right)}}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{\left({{}\terminal{isStrictComparison}({\variable[ComparisonOp]{Op}})}\right)}}\right)}}{}{}{}
\krule[comparison-acd]{
\kprefix{k}{{}\terminal{comparison}({\variable[ComparisonOp]{Op}},{\reduce{\variable[String]{S}}{\constant[\#Int]{0}}},{\variable[Value]{V1}})}
}{{{\left({\neg_{\scriptstyle\it Bool}{{}\terminal{\#isStringType}({\variable[Value]{V1}})}}\right)}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{{}\terminal{isNumericString}({\variable[String]{S}})}}\right)}}\wedge_{\scriptstyle\it Bool}{\left({\neg_{\scriptstyle\it Bool}{\left({{}\terminal{isStrictComparison}({\variable[ComparisonOp]{Op}})}\right)}}\right)}}{}{}{}
\krule[isEqual-toFloat-RHS]{
\kprefix{k}{{}\terminal{comparison}({\variable[ComparisonOp]{Op}},{\variable[Float]{V1}},{\reduce{\variable[Int]{V2}}{{}\terminal{*toFloat}({\variable[Int]{V2}})}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-toFloat-RHS"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{isStrictComparison}({\variable[ComparisonOp]{Op}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[isEqual-toFloat-LHS]{
\kprefix{k}{{}\terminal{comparison}({\variable[ComparisonOp]{Op}},{\reduce{\variable[Int]{V1}}{{}\terminal{*toFloat}({\variable[Int]{V1}})}},{\variable[Float]{V2}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-toFloat-LHS"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{isStrictComparison}({\variable[ComparisonOp]{Op}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[isEqual-null-RHS]{
\kprefix{k}{{}\terminal{comparison}({\variable[ComparisonOp]{Op}},{\reduce{{}\terminal{locNull}}{{}\terminal{NULL}}},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-null-RHS"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{isStrictComparison}({\variable[ComparisonOp]{Op}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[isEqual-null-LHS]{
\kprefix{k}{{}\terminal{comparison}({\variable[ComparisonOp]{Op}},{\AnyVar[K]},{\reduce{{}\terminal{locNull}}{{}\terminal{NULL}}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-null-LHS"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{isStrictComparison}({\variable[ComparisonOp]{Op}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[comparison-equal-scalar]{
\kprefix{k}{\reduce{{}\terminal{comparison}({{}\terminal{equal}},{\variable[LanguageValue]{V1}},{\variable[LanguageValue]{V2}})}{{}\terminal{isEqual}({\variable[LanguageValue]{V1}},{\variable[LanguageValue]{V2}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"comparison-equal-scalar"}}}
}{{\left({{\variable[LanguageValue]{V1}}\terminal{isScalar}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{hasSameType}({\variable[LanguageValue]{V1}},{\variable[LanguageValue]{V2}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[comparison-equal-array]{
\kprefix{k}{\reduce{{}\terminal{comparison}({{}\terminal{equal}},{\variable[Loc]{V1}},{\variable[Loc]{V2}})}{{}\terminal{isEqual}({\variable[Loc]{V1}},{\variable[Loc]{V2}})}}
\mathrel{}\kall[red]{heap}{\variable[Map]{M}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"comparison-equa-array"}}}
}{{}\terminal{locsHoldSameCompound}({\variable[Map]{M}},{\variable[Loc]{V1}},{\variable[Loc]{V2}})}{}{\kattribute{intermediate}}{}
\krule[comparison-equal-loc]{
\kprefix{k}{\reduce{{}\terminal{comparison}({{}\terminal{equal}},{\variable[Loc]{V1}},{\variable[Loc]{V1}})}{\constant[\#Bool]{true}}}
}{}{}{}{}
\krule[comparison-identical-scalar]{
\kprefix{k}{\reduce{{}\terminal{comparison}({{}\terminal{identical}},{\variable[Value]{V1}},{\variable[Value]{V2}})}{{\variable[Value]{V1}}\mathrel{=_K}{\variable[Value]{V2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"comparison-equal-scalar"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[comparison-less-scalar]{
\kprefix{k}{\reduce{{}\terminal{comparison}({{}\terminal{less}},{\variable[LanguageValue]{V1}},{\variable[LanguageValue]{V2}})}{{}\terminal{less}({\variable[LanguageValue]{V1}},{\variable[LanguageValue]{V2}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"comparison-less-scalar"}}}
}{{\left({{\variable[LanguageValue]{V1}}\terminal{isScalar}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{hasSameType}({\variable[LanguageValue]{V1}},{\variable[LanguageValue]{V2}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[comparison-less-array]{
\kprefix{k}{\reduce{{}\terminal{comparison}({{}\terminal{less}},{\variable[Loc]{V1}},{\variable[Loc]{V2}})}{{}\terminal{less}({\variable[Loc]{V1}},{\variable[Loc]{V2}})}}
\mathrel{}\kall[red]{heap}{\variable[Map]{M}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"comparison-less-array"}}}
}{{}\terminal{locsHoldSameCompound}({\variable[Map]{M}},{\variable[Loc]{V1}},{\variable[Loc]{V2}})}{}{\kattribute{intermediate}}{}
\krule[comparison-lessequal-scalar]{
\kprefix{k}{\reduce{{}\terminal{comparison}({{}\terminal{lessEqual}},{\variable[LanguageValue]{V1}},{\variable[LanguageValue]{V2}})}{{}\terminal{lessEqual}({\variable[LanguageValue]{V1}},{\variable[LanguageValue]{V2}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"comparison-lessequal-scalar"}}}
}{{\left({{\variable[LanguageValue]{V1}}\terminal{isScalar}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{hasSameType}({\variable[LanguageValue]{V1}},{\variable[LanguageValue]{V2}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[comparison-lessEqual-array]{
\kprefix{k}{\reduce{{}\terminal{comparison}({{}\terminal{lessEqual}},{\variable[Loc]{V1}},{\variable[Loc]{V2}})}{{}\terminal{lessEqual}({\variable[Loc]{V1}},{\variable[Loc]{V2}})}}
\mathrel{}\kall[red]{heap}{\variable[Map]{M}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"comparison-lessEqual-array"}}}
}{{}\terminal{locsHoldSameCompound}({\variable[Map]{M}},{\variable[Loc]{V1}},{\variable[Loc]{V2}})}{}{\kattribute{intermediate}}{}
\krule[comparison-greater-scalar]{
\kprefix{k}{\reduce{{}\terminal{comparison}({{}\terminal{greater}},{\variable[LanguageValue]{V1}},{\variable[LanguageValue]{V2}})}{{}\terminal{greater}({\variable[LanguageValue]{V1}},{\variable[LanguageValue]{V2}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"comparison-greater-scalar"}}}
}{{\left({{\variable[LanguageValue]{V1}}\terminal{isScalar}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{hasSameType}({\variable[LanguageValue]{V1}},{\variable[LanguageValue]{V2}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[comparison-greater-array]{
\kprefix{k}{\reduce{{}\terminal{comparison}({{}\terminal{greater}},{\variable[Loc]{V1}},{\variable[Loc]{V2}})}{{}\terminal{greater}({\variable[Loc]{V1}},{\variable[Loc]{V2}})}}
\mathrel{}\kall[red]{heap}{\variable[Map]{M}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"comparison-greater-array"}}}
}{{}\terminal{locsHoldSameCompound}({\variable[Map]{M}},{\variable[Loc]{V1}},{\variable[Loc]{V2}})}{}{\kattribute{intermediate}}{}
\krule[comparison-greaterEqual-scalar]{
\kprefix{k}{\reduce{{}\terminal{comparison}({{}\terminal{greaterEqual}},{\variable[LanguageValue]{V1}},{\variable[LanguageValue]{V2}})}{{}\terminal{greaterEqual}({\variable[LanguageValue]{V1}},{\variable[LanguageValue]{V2}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"comparison-greaterEqual-scalar"}}}
}{{\left({{\variable[LanguageValue]{V1}}\terminal{isScalar}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{}\terminal{hasSameType}({\variable[LanguageValue]{V1}},{\variable[LanguageValue]{V2}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[comparison-greaterEqual-array]{
\kprefix{k}{\reduce{{}\terminal{comparison}({{}\terminal{greaterEqual}},{\variable[Loc]{V1}},{\variable[Loc]{V2}})}{{}\terminal{greaterEqual}({\variable[Loc]{V1}},{\variable[Loc]{V2}})}}
\mathrel{}\kall[red]{heap}{\variable[Map]{M}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"comparison-greaterEqual-array"}}}
}{{}\terminal{locsHoldSameCompound}({\variable[Map]{M}},{\variable[Loc]{V1}},{\variable[Loc]{V2}})}{}{\kattribute{intermediate}}{}
\begin{kblock}[text]
 \subsection{Equality} 
		$a == $b Equal TRUE if $a is equal to $b after type juggling. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{isEqual}({{\nonTerminal{\sort{Value}}}},{{\nonTerminal{\sort{Value}}}})}{}
\end{syntaxBlock}
\krule[isEqual-int]{
\kprefix{k}{\reduce{{}\terminal{isEqual}({\variable[Int]{I1}},{\variable[Int]{I2}})}{{\variable[Int]{I1}}\mathrel{{=}{=}_{\scriptstyle\it Int}}{\variable[Int]{I2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-int"}}}
}{}{}{\kattribute{internal}}{}
\krule[isEqual-float]{
\kprefix{k}{\reduce{{}\terminal{isEqual}({\variable[Float]{F1}},{\variable[Float]{F2}})}{{\variable[Float]{F1}}\mathrel{==_{\scriptstyle\it Float}}{\variable[Float]{F2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-float"}}}
}{}{}{\kattribute{internal}}{}
\krule[isEqual-bool]{
\kprefix{k}{\reduce{{}\terminal{isEqual}({\variable[Bool]{B1}},{\variable[Bool]{B2}})}{{\variable[Bool]{B1}}\terminal{==Bool}{\variable[Bool]{B2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-bool"}}}
}{}{}{\kattribute{internal}}{}
\krule[isEqual-string]{
\kprefix{k}{\reduce{{}\terminal{isEqual}({\variable[String]{S1}},{\variable[String]{S2}})}{{\variable[String]{S1}}\terminal{==String}{\variable[String]{S2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-string"}}}
}{}{}{\kattribute{internal}}{}
\krule[isEqual-null-left]{
\kprefix{k}{\reduce{{}\terminal{isEqual}({{}\terminal{NULL}},{\variable[LanguageValue]{V}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-null-left"}}}
}{}{}{\kattribute{internal}}{}
\krule[isEqual-null-right]{
\kprefix{k}{\reduce{{}\terminal{isEqual}({\variable[LanguageValue]{V}},{{}\terminal{NULL}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-null-right"}}}
}{}{}{\kattribute{internal}}{}
\krule[isEqual-same-loc]{
\kprefix{k}{\reduce{{}\terminal{isEqual}({\variable[Loc]{L}},{\variable[Loc]{L}})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-same-loc"}}}
}{}{}{\kattribute{internal}}{}
\krule[isEqual-array]{
\kprefix{k}{\reduce{{}\terminal{isEqual}({\variable[Loc]{L1}},{\variable[Loc]{L2}})}{{}\terminal{*Cond}({{}\terminal{\#isEqualScalar}({'FunctionCall(\constant[\#String]{"isEqualArray"}\kcomma'ListWrap('Param(\variable[Loc]{L1})\kcomma'Param(\variable[Loc]{L2})))},{\constant[\#Int]{0}})},{\constant[\#Bool]{true}},{\constant[\#Bool]{false}})}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({\variable[Array]{V1}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({\variable[Array]{V2}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-array"}}}
}{}{}{\kattribute{internal}}{}
\krule[isEqual-object-different-class]{
\kprefix{k}{{}\terminal{isEqual}({\reduce{\variable[Loc]{L1}}{\variable[K]{L3}}},{\reduce{\variable[Loc]{L2}}{\variable[K]{L4}}})}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L3}},{\variable[K]{Class}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L4}},{\variable[K]{Class}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-object-different-class"}}}
}{}{}{\kattribute{internal}}{}
\krule[isEqual-object-same-class]{
\kprefix{k}{\reduce{{}\terminal{isEqual}({\variable[Loc]{L1}},{\variable[Loc]{L2}})}{\constant[\#Bool]{false}}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L3}},{\variable[K]{Class1}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L4}},{\variable[K]{Class2}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isEqual-object-same-class"}}}
}{{\variable[K]{Class1}}\mathrel{\neq_K}{\variable[K]{Class2}}}{}{\kattribute{internal}}{}
\krule[isEqual-object-same-loc]{
\kprefix{k}{\reduce{{}\terminal{isEqual}({\variable[Loc]{L1}},{\variable[Loc]{L1}})}{\constant[\#Bool]{true}}}
}{}{}{}{}
\begin{kblock}[text]
 \subsection{Strict Equality} 
		$a === $b Equal TRUE if $a is equal to $b after type juggling. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{isIdentical}({{\nonTerminal{\sort{Value}}}},{{\nonTerminal{\sort{Value}}}})}{}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{isIdentical}({\variable[Value]{L}},{\variable[Value]{R}})}{{\variable[Value]{L}}\mathrel{=_K}{\variable[Value]{R}}}}{}{}{}{}
\begin{kblock}[text]
 \subsection{Less Than} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{less}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[less-int]{
\kprefix{k}{\reduce{{}\terminal{less}({\variable[Int]{I1}},{\variable[Int]{I2}})}{{\variable[Int]{I1}}\mathrel{<_{\scriptstyle\it Int}}{\variable[Int]{I2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"less-int"}}}
}{}{}{\kattribute{internal}}{}
\krule[less-float]{
\kprefix{k}{\reduce{{}\terminal{less}({\variable[Float]{F1}},{\variable[Float]{F2}})}{{\variable[Float]{F1}}\mathrel{<_{\scriptstyle\it Float}}{\variable[Float]{F2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"less-float"}}}
}{}{}{\kattribute{internal}}{}
\krule[less-bool-1]{
\kprefix{k}{\reduce{{}\terminal{less}({\constant[\#Bool]{true}},{\constant[\#Bool]{true}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"less-bool-1"}}}
}{}{}{\kattribute{internal}}{}
\krule[less-bool-2]{
\kprefix{k}{\reduce{{}\terminal{less}({\constant[\#Bool]{true}},{\constant[\#Bool]{false}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"less-bool-2"}}}
}{}{}{\kattribute{internal}}{}
\krule[less-bool-3]{
\kprefix{k}{\reduce{{}\terminal{less}({\constant[\#Bool]{false}},{\constant[\#Bool]{true}})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"less-bool-3"}}}
}{}{}{\kattribute{internal}}{}
\krule[less-bool-4]{
\kprefix{k}{\reduce{{}\terminal{less}({\constant[\#Bool]{false}},{\constant[\#Bool]{false}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"less-bool-4"}}}
}{}{}{\kattribute{internal}}{}
\krule[less-string]{
\kprefix{k}{\reduce{{}\terminal{less}({\variable[String]{S1}},{\variable[String]{S2}})}{{\variable[String]{S1}}\terminal{<String}{\variable[String]{S2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"less-string"}}}
}{}{}{\kattribute{internal}}{}
\krule[less-array]{
\kprefix{k}{\reduce{{}\terminal{less}({\variable[Loc]{L1}},{\variable[Loc]{L2}})}{{}\terminal{*Cond}({{}\terminal{\#isEqualScalar}({'FunctionCall(\constant[\#String]{"isEqualArray"}\kcomma'ListWrap('Param(\variable[Loc]{L1})\kcomma'Param(\variable[Loc]{L2})))},{\constant[\#Int]{-1}})},{\constant[\#Bool]{true}},{\constant[\#Bool]{false}})}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({\variable[Array]{V1}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({\variable[Array]{V2}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"less-array"}}}
}{}{}{\kattribute{internal}}{}
\krule[less-object-same-class]{
\kprefix{k}{{}\terminal{less}({\reduce{\variable[Loc]{L1}}{\variable[K]{L3}}},{\reduce{\variable[Loc]{L2}}{\variable[K]{L4}}})}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L3}},{\variable[K]{Class}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L4}},{\variable[K]{Class}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"less-object-same-class"}}}
}{}{}{\kattribute{internal}}{}
\krule[less-object-diff-class]{
\kprefix{k}{\reduce{{}\terminal{less}({\variable[Loc]{L1}},{\variable[Loc]{L2}})}{\constant[\#Bool]{false}}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L3}},{\variable[K]{Class1}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L4}},{\variable[K]{Class2}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"less-object-diff-class"}}}
}{{\variable[K]{Class1}}\mathrel{\neq_K}{\variable[K]{Class2}}}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Greater Than} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{greater}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[greater-int]{
\kprefix{k}{\reduce{{}\terminal{greater}({\variable[Int]{I1}},{\variable[Int]{I2}})}{{\variable[Int]{I1}}\mathrel{>_{\scriptstyle\it Int}}{\variable[Int]{I2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greater-int"}}}
}{}{}{\kattribute{internal}}{}
\krule[greater-float]{
\kprefix{k}{\reduce{{}\terminal{greater}({\variable[Float]{F1}},{\variable[Float]{F2}})}{{\variable[Float]{F1}}\mathrel{>_{\scriptstyle\it Float}}{\variable[Float]{F2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greater-float"}}}
}{}{}{\kattribute{internal}}{}
\krule[greater-bool-1]{
\kprefix{k}{\reduce{{}\terminal{greater}({\constant[\#Bool]{true}},{\constant[\#Bool]{true}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greater-bool-1"}}}
}{}{}{\kattribute{internal}}{}
\krule[greater-bool-2]{
\kprefix{k}{\reduce{{}\terminal{greater}({\constant[\#Bool]{true}},{\constant[\#Bool]{false}})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greater-bool-2"}}}
}{}{}{\kattribute{internal}}{}
\krule[greater-bool-3]{
\kprefix{k}{\reduce{{}\terminal{greater}({\constant[\#Bool]{false}},{\constant[\#Bool]{true}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greater-bool-3"}}}
}{}{}{\kattribute{internal}}{}
\krule[greater-bool-4]{
\kprefix{k}{\reduce{{}\terminal{greater}({\constant[\#Bool]{false}},{\constant[\#Bool]{false}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greater-bool-4"}}}
}{}{}{\kattribute{internal}}{}
\krule[greater-string]{
\kprefix{k}{\reduce{{}\terminal{greater}({\variable[String]{S1}},{\variable[String]{S2}})}{{\variable[String]{S1}}\terminal{>String}{\variable[String]{S2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greater-string"}}}
}{}{}{\kattribute{internal}}{}
\krule[greater-array]{
\kprefix{k}{\reduce{{}\terminal{greater}({\variable[Loc]{L1}},{\variable[Loc]{L2}})}{{}\terminal{*Cond}({{}\terminal{\#isEqualScalar}({'FunctionCall(\constant[\#String]{"isEqualArray"}\kcomma'ListWrap('Param(\variable[Loc]{L1})\kcomma'Param(\variable[Loc]{L2})))},{\constant[\#Int]{1}})},{\constant[\#Bool]{true}},{\constant[\#Bool]{false}})}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({\variable[Array]{V1}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({\variable[Array]{V2}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greater-array"}}}
}{}{}{\kattribute{internal}}{}
\krule[greater-obj-same-class]{
\kprefix{k}{{}\terminal{greater}({\reduce{\variable[Loc]{L1}}{\variable[K]{L3}}},{\reduce{\variable[Loc]{L2}}{\variable[K]{L4}}})}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L3}},{\variable[K]{Class}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L4}},{\variable[K]{Class}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greater-obj-same-class"}}}
}{}{}{\kattribute{internal}}{}
\krule[greater-obj-diff-class]{
\kprefix{k}{\reduce{{}\terminal{greater}({\variable[Loc]{L1}},{\variable[Loc]{L2}})}{\constant[\#Bool]{false}}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L3}},{\variable[K]{Class1}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L4}},{\variable[K]{Class2}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greater-obj-diff-class"}}}
}{{\variable[K]{Class1}}\mathrel{\neq_K}{\variable[K]{Class2}}}{}{}{}
\begin{kblock}[text]
 \subsection{Less than or equal} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{lessEqual}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[lessEqual-int]{
\kprefix{k}{\reduce{{}\terminal{lessEqual}({\variable[Int]{I1}},{\variable[Int]{I2}})}{{\variable[Int]{I1}}\mathrel{\leq_{\scriptstyle\it Int}}{\variable[Int]{I2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lessEqual-int"}}}
}{}{}{\kattribute{internal}}{}
\krule[lessEqual-float]{
\kprefix{k}{\reduce{{}\terminal{lessEqual}({\variable[Float]{F1}},{\variable[Float]{F2}})}{{\variable[Float]{F1}}\mathrel{\leq_{\scriptstyle\it Float}}{\variable[Float]{F2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lessEqual-float"}}}
}{}{}{\kattribute{internal}}{}
\krule[lessEqual-bool-1]{
\kprefix{k}{\reduce{{}\terminal{lessEqual}({\constant[\#Bool]{true}},{\constant[\#Bool]{true}})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lessEqual-bool-1"}}}
}{}{}{\kattribute{internal}}{}
\krule[lessEqual-bool-2]{
\kprefix{k}{\reduce{{}\terminal{lessEqual}({\constant[\#Bool]{true}},{\constant[\#Bool]{false}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lessEqual-bool-2"}}}
}{}{}{\kattribute{internal}}{}
\krule[lessEqual-bool-3]{
\kprefix{k}{\reduce{{}\terminal{lessEqual}({\constant[\#Bool]{false}},{\constant[\#Bool]{true}})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lessEqual-bool-3"}}}
}{}{}{\kattribute{internal}}{}
\krule[lessEqual-bool-4]{
\kprefix{k}{\reduce{{}\terminal{lessEqual}({\constant[\#Bool]{false}},{\constant[\#Bool]{false}})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lessEqual-bool-4"}}}
}{}{}{\kattribute{internal}}{}
\krule[lessEqual-string]{
\kprefix{k}{\reduce{{}\terminal{lessEqual}({\variable[String]{S1}},{\variable[String]{S2}})}{{\variable[String]{S1}}\terminal{<=String}{\variable[String]{S2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lessEqual-string"}}}
}{}{}{\kattribute{internal}}{}
\krule[lessEqual.-array]{
\kprefix{k}{\reduce{{}\terminal{lessEqual}({\variable[Loc]{L1}},{\variable[Loc]{L2}})}{{}\terminal{*or}({'Less(\variable[Loc]{L1}\kcomma\variable[Loc]{L2})},{'IsEqual(\variable[Loc]{L1}\kcomma\variable[Loc]{L2})})}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({\variable[Array]{V1}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({\variable[Array]{V2}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lessEqual.-array"}}}
}{}{}{\kattribute{internal}}{}
\krule[lessEqual-obj-same-class]{
\kprefix{k}{{}\terminal{lessEqual}({\reduce{\variable[Loc]{L1}}{\variable[K]{L3}}},{\reduce{\variable[Loc]{L2}}{\variable[K]{L4}}})}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L3}},{\variable[K]{Class}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L4}},{\variable[K]{Class}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lessEqual-obj-same-class"}}}
}{}{}{\kattribute{internal}}{}
\krule[lessEqual-obj-diff-class]{
\kprefix{k}{\reduce{{}\terminal{lessEqual}({\variable[Loc]{L1}},{\variable[Loc]{L2}})}{\constant[\#Bool]{false}}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L3}},{\variable[K]{Class1}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L4}},{\variable[K]{Class2}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lessEqual-obj-diff-class"}}}
}{{\variable[K]{Class1}}\mathrel{\neq_K}{\variable[K]{Class2}}}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Greater then or equal} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{greaterEqual}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[greaterEqual-int]{
\kprefix{k}{\reduce{{}\terminal{greaterEqual}({\variable[Int]{I1}},{\variable[Int]{I2}})}{{\variable[Int]{I1}}\mathrel{\geq_{\scriptstyle\it Int}}{\variable[Int]{I2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greaterEqual-int"}}}
}{}{}{\kattribute{internal}}{}
\krule[greaterEqual-float]{
\kprefix{k}{\reduce{{}\terminal{greaterEqual}({\variable[Float]{F1}},{\variable[Float]{F2}})}{{\variable[Float]{F1}}\mathrel{\geq_{\scriptstyle\it Float}}{\variable[Float]{F2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greaterEqual-float"}}}
}{}{}{\kattribute{internal}}{}
\krule[greaterEqual-bool-1]{
\kprefix{k}{\reduce{{}\terminal{greaterEqual}({\constant[\#Bool]{true}},{\constant[\#Bool]{true}})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greaterEqual-bool-1"}}}
}{}{}{\kattribute{internal}}{}
\krule[greaterEqual-bool-2]{
\kprefix{k}{\reduce{{}\terminal{greaterEqual}({\constant[\#Bool]{true}},{\constant[\#Bool]{false}})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greaterEqual-bool-2"}}}
}{}{}{\kattribute{internal}}{}
\krule[greaterEqual-bool-3]{
\kprefix{k}{\reduce{{}\terminal{greaterEqual}({\constant[\#Bool]{false}},{\constant[\#Bool]{true}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greaterEqual-bool-3"}}}
}{}{}{\kattribute{internal}}{}
\krule[greaterEqual-bool-4]{
\kprefix{k}{\reduce{{}\terminal{greaterEqual}({\constant[\#Bool]{false}},{\constant[\#Bool]{false}})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greaterEqual-bool-4"}}}
}{}{}{\kattribute{internal}}{}
\krule[greaterEqual-string]{
\kprefix{k}{\reduce{{}\terminal{greaterEqual}({\variable[String]{S1}},{\variable[String]{S2}})}{{\variable[String]{S1}}\terminal{>=String}{\variable[String]{S2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greaterEqual-string"}}}
}{}{}{\kattribute{internal}}{}
\krule[greaterEqual-array]{
\kprefix{k}{\reduce{{}\terminal{greaterEqual}({\variable[Loc]{L1}},{\variable[Loc]{L2}})}{{}\terminal{*or}({{}\terminal{greater}({\variable[Loc]{L1}},{\variable[Loc]{L2}})},{{}\terminal{isEqual}({\variable[Loc]{L1}},{\variable[Loc]{L2}})})}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({\variable[Array]{V1}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({\variable[Array]{V2}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greaterEqual-array"}}}
}{}{}{\kattribute{internal}}{}
\krule[greaterEqual-obj-same-class]{
\kprefix{k}{{}\terminal{greaterEqual}({\reduce{\variable[Loc]{L1}}{\variable[K]{L3}}},{\reduce{\variable[Loc]{L2}}{\variable[K]{L4}}})}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L3}},{\variable[K]{Class}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L4}},{\variable[K]{Class}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greaterEqual-obj-same-class"}}}
}{}{}{\kattribute{internal}}{}
\krule[greaterEqual-obj-diff-class]{
\kprefix{k}{\reduce{{}\terminal{greaterEqual}({\variable[Loc]{L1}},{\variable[Loc]{L2}})}{\constant[\#Bool]{false}}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L3}},{\variable[K]{Class1}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L2}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[K]{L4}},{\variable[K]{Class2}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"greaterEqual-obj-diff-class"}}}
}{{\variable[K]{Class1}}\mathrel{\neq_K}{\variable[K]{Class2}}}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Strict Equality} 
		$a === $b	Identical	TRUE if $a is equal to $b, and they are of the same type. \end{kblock}
\kcontext{
'IsIdentical(\khole{}\kcomma\AnyVar[K])}{}{}{}
\kcontext{
'IsIdentical(\AnyVar[K]\kcomma\khole{})}{}{}{}
\begin{kblock}[text]
 \subsection{Strict Inequality} 
		$a !== $b	Not identical	TRUE if $a is not equal to $b, 
		or they are not of the same type.\end{kblock}
\krule[isNotIdentical]{
\kprefix{k}{\reduce{'IsNotIdentical(\variable[K]{A}\kcomma\variable[K]{B})}{'Not('IsIdentical(\variable[K]{A}\kcomma\variable[K]{B}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isNotIdentical"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Inequality} 
		$a != $b or $a <> $b 	Not equal	TRUE if $a is not equal to $b after type juggling.\end{kblock}
\krule[isNotEqual]{
\kprefix{k}{\reduce{'IsNotEqual(\variable[K]{A}\kcomma\variable[K]{B})}{'Not('IsEqual(\variable[K]{A}\kcomma\variable[K]{B}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"isNotEqual"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \section{Logic operators} \end{kblock}
\begin{kblock}[text]
 \subsection{And} \end{kblock}
\kcontext{
'And(\khole{}\kcomma\AnyVar[K])}{}{}{}
\krule[and-LHS2LangValue]{
\kprefix{k}{'And(\reduce{\variable[Ref]{R}}{{}\terminal{convertToLanguageValue}({\variable[Ref]{R}})}\kcomma\variable[K]{B})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"and-LHS2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[and-LHS2Bool]{
\kprefix{k}{'And(\reduce{\variable[Value]{V}}{'BoolCast(\variable[Value]{V})}\kcomma\AnyVar[K])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"and-LHS2Bool"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isBoolType}({\variable[Value]{V}})}\right)}}{}{}{}
\krule[and-true]{
\kprefix{k}{\reduce{'And(\constant[\#Bool]{true}\kcomma\variable[K]{B})}{\variable[K]{B}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"and-true"}}}
}{}{}{\kattribute{step}}{}
\krule[and-false]{
\kprefix{k}{\reduce{'And(\constant[\#Bool]{false}\kcomma\AnyVar[K])}{\constant[\#Bool]{false}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"and-false"}}}
}{}{}{\kattribute{step}}{}
\krule[land]{
\kprefix{k}{\reduce{'LAnd(\variable[K]{A}\kcomma\variable[K]{B})}{'And(\variable[K]{A}\kcomma\variable[K]{B})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"land"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Or} \end{kblock}
\kcontext{
'Or(\khole{}\kcomma\AnyVar[K])}{}{}{}
\krule[or-LHS2LangValue]{
\kprefix{k}{'Or(\reduce{\variable[Ref]{R}}{{}\terminal{convertToLanguageValue}({\variable[Ref]{R}})}\kcomma\variable[K]{B})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"or-LHS2LangValue"}}}
}{}{}{\kattribute{step}}{}
\krule[or-LHS2Bool]{
\kprefix{k}{'Or(\reduce{\variable[Value]{V}}{'BoolCast(\variable[Value]{V})}\kcomma\AnyVar[K])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"or-LHS2Bool"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isBoolType}({\variable[Value]{V}})}\right)}}{}{\kattribute{step}}{}
\krule[or-true]{
\kprefix{k}{\reduce{'Or(\constant[\#Bool]{true}\kcomma\AnyVar[K])}{\constant[\#Bool]{true}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"or-true"}}}
}{}{}{\kattribute{step}}{}
\krule[or-false]{
\kprefix{k}{\reduce{'Or(\constant[\#Bool]{false}\kcomma\variable[K]{B})}{\variable[K]{B}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"or-false"}}}
}{}{}{\kattribute{step}}{}
\krule[lor]{
\kprefix{k}{\reduce{'LOr(\variable[K]{A}\kcomma\variable[K]{B})}{'Or(\variable[K]{A}\kcomma\variable[K]{B})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"lor"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \subsection{Xor} \end{kblock}
\krule[xor]{
\kprefix{k}{\reduce{'LXor(\variable[K]{A}\kcomma\variable[K]{B})}{'Or('And(\variable[K]{A}\kcomma'Not(\variable[K]{B}))\kcomma'And('Not(\variable[K]{A})\kcomma\variable[K]{B}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"xor"}}}
}{}{}{\kattribute{structural}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'XorAssign}}{}
\end{syntaxBlock}
\krule[xor-assign]{
\kprefix{k}{\reduce{'XorAssign(\variable[K]{X}\kcomma\variable[K]{Y})}{'Assign(\variable[K]{X}\kcomma'LXor(\variable[K]{X}\kcomma\variable[K]{Y}))}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Not} \end{kblock}
\krule[not-arg2LangValue]{
\kprefix{k}{'Not(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"not-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[not-arg2Bool]{
\kprefix{k}{'Not(\reduce{\variable[LanguageValue]{V}}{{}\terminal{*toBoolean}({\variable[LanguageValue]{V}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"not-arg2LangValue"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isBoolType}({\variable[LanguageValue]{V}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[not]{
\kprefix{k}{\reduce{'Not(\variable[Bool]{B})}{\neg_{\scriptstyle\it Bool}{\variable[Bool]{B}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"not"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \section{Increment operators} \end{kblock}
\kcontext{
'PostDec(\khole{})}{}{}{}
\krule[postDecArg2Loc]{
\kprefix{k}{'PostDec(\reduce{\variable[Ref]{R}}{{}\terminal{convertToLoc}({\variable[Ref]{R}},{{}\terminal{r}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"postDecArg2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[postDec]{
\kprefix{k}{\reduce{'PostDec(\variable[Loc]{L})}{\variable[Int]{V}}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\reduce{\variable[Int]{V}}{{\variable[Int]{V}}\mathrel{-_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"postDec"}}}
}{}{}{\kattribute{step}}{}
\kcontext{
'PostInc(\khole{})}{}{}{}
\krule[postIncArg2Loc]{
\kprefix{k}{'PostInc(\reduce{\variable[Ref]{R}}{{}\terminal{convertToLoc}({\variable[Ref]{R}},{{}\terminal{r}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"postIncArg2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[postInc]{
\kprefix{k}{\reduce{'PostInc(\variable[Loc]{L})}{\variable[Int]{V}}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\reduce{\variable[Int]{V}}{{\variable[Int]{V}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"postInc"}}}
}{}{}{\kattribute{step}}{}
\krule[postInc-null]{
\kprefix{k}{\reduce{'PostInc(\variable[Loc]{L})}{{}\terminal{NULL}}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\reduce{{}\terminal{NULL}}{\constant[\#Int]{1}}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"postInc-null"}}}
}{}{}{\kattribute{step}}{}
\kcontext{
'PreDec(\khole{})}{}{}{}
\krule[preDec-arg2Loc]{
\kprefix{k}{'PreDec(\reduce{\variable[Ref]{R}}{{}\terminal{convertToLoc}({\variable[Ref]{R}},{{}\terminal{r}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"preDec-arg2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[preDec]{
\kprefix{k}{\reduce{'PreDec(\variable[Loc]{L})}{{\variable[Int]{V}}\mathrel{-_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\reduce{\variable[Int]{V}}{{\variable[Int]{V}}\mathrel{-_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"preDec"}}}
}{}{}{\kattribute{step}}{}
\kcontext{
'PreInc(\khole{})}{}{}{}
\krule[preInc-arg2Loc]{
\kprefix{k}{'PreInc(\reduce{\variable[Ref]{R}}{{}\terminal{convertToLoc}({\variable[Ref]{R}},{{}\terminal{r}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"preInc-arg2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[preInc]{
\kprefix{k}{\reduce{'PreInc(\variable[Loc]{L})}{{\variable[Int]{V}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\reduce{\variable[Int]{V}}{{\variable[Int]{V}}\mathrel{+_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"preInc"}}}
}{}{}{\kattribute{step}}{}
\end{module}
\begin{module}{\moduleName{CONTROL-STRUCTURES}}
\begin{kblock}[text]
 \section{Control flow structures} 
		We define here the control flow constructs of the language. We give a semantics
		for if and while, and for the remaining constructs we use a desugaring approach. \end{kblock}
\begin{kblock}[text]
 \subsection{If} \end{kblock}
\begin{kblock}[text]
 The if-then statement is desugared into an if-then-else statement whose else 
	branch is empty. \end{kblock}
\krule[if-no-else]{
\kprefix{k}{\reduce{'If(\variable[K]{G}\kcomma\variable[K]{B})}{'If(\variable[K]{G}\kcomma\variable[K]{B}\kcomma'ListWrap()\kcomma'ListWrap())}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"if-no-else"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 The alternative syntax is also desugared into a standard if \end{kblock}
\krule[if-alt]{
\kprefix{k}{\reduce{'AltIf(\variable[K]{G}\kcomma\variable[K]{T}\kcomma\variable[K]{X}\kcomma\variable[K]{F})}{'If(\variable[K]{G}\kcomma\variable[K]{T}\kcomma\variable[K]{X}\kcomma\variable[K]{F})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"if-alt"}}}
}{}{}{\kattribute{structural}}{}
\krule[if-alt-no-else]{
\kprefix{k}{\reduce{'AltIf(\variable[K]{G}\kcomma\variable[K]{B})}{'If(\variable[K]{G}\kcomma\variable[K]{B})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"if-alt-no-else"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 First of all the guard is evaluated \end{kblock}
\kcontext{
'If(\khole{}\kcomma\AnyVar[KList]\kcomma\AnyVar[KList]\kcomma\AnyVar[KList])}{}{}{}
\begin{kblock}[text]
 In case the guard has evaluated to a reference of location, the corresponding 
	value is read from memory. \end{kblock}
\krule[if-guard2LangValue]{
\kprefix{k}{'If(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}\kcomma\AnyVar[KList]\kcomma\AnyVar[KList]\kcomma\AnyVar[KList])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"if-guard2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\begin{kblock}[text]
 And finally the value is converted to a boolean value, so that the straightforward 
	semantics given below applies. \end{kblock}
\krule[if-guard2Bool]{
\kprefix{k}{'If(\reduce{\variable[LanguageValue]{V}}{'BoolCast(\variable[LanguageValue]{V})}\kcomma\AnyVar[KList]\kcomma\AnyVar[KList]\kcomma\AnyVar[KList])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"if-guard2Bool"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isBoolType}({\variable[LanguageValue]{V}})}\right)}}{}{\kattribute{intermediate}}{}
\krule[if-true-1]{
\kprefix{k}{\reduce{'If(\constant[\#Bool]{true}\kcomma\variable[K]{S}\kcomma\variable[K]{X}\kcomma\variable[K]{Y})}{\variable[K]{S}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"if-true-1"}}}
}{}{}{\kattribute{step}}{}
\krule[if-true-2]{
\kprefix{k}{\reduce{'If(\constant[\#Bool]{true}\kcomma\variable[K]{S}\kcomma\variable[K]{X})}{\variable[K]{S}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"if-true-2"}}}
}{}{}{\kattribute{step}}{}
\krule[if-false]{
\kprefix{k}{\reduce{'If(\constant[\#Bool]{false}\kcomma\AnyVar[KList]\kcomma'ListWrap()\kcomma\variable[K]{S})}{\variable[K]{S}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"if-false"}}}
}{}{}{\kattribute{step}}{}
\krule[if-false-elseIf-1]{
\kprefix{k}{\reduce{'If(\constant[\#Bool]{false}\kcomma\AnyVar[KList]\kcomma'ListWrap('ElseIf(\variable[K]{Guard}\kcomma\variable[K]{Stmt})\kcomma\variable[KList]{ElseIfs})\kcomma\variable[K]{S})}{'If(\variable[K]{Guard}\kcomma\variable[K]{Stmt}\kcomma'ListWrap(\variable[KList]{ElseIfs})\kcomma\variable[K]{S})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"if-false-elseIf-1"}}}
}{}{}{\kattribute{step}}{}
\krule[if-false-elseIf-2]{
\kprefix{k}{\reduce{'If(\constant[\#Bool]{false}\kcomma\variable[K]{Z}\kcomma'ListWrap('ElseIf(\variable[K]{Guard}\kcomma\variable[K]{Stmt})\kcomma\variable[KList]{ElseIfs}))}{'If(\constant[\#Bool]{false}\kcomma\variable[K]{Z}\kcomma'ListWrap('ElseIf(\variable[K]{Guard}\kcomma\variable[K]{Stmt})\kcomma\variable[KList]{ElseIfs})\kcomma'ListWrap())}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"if-false-elseIf-2"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \subsection{Conditional Expression} 
		The conditional expression is desugared into an if statement. \end{kblock}
\krule[ternary]{
\kprefix{k}{\reduce{'Ternary(\variable[K]{Guard}\kcomma\variable[K]{T}\kcomma\variable[K]{F})}{'If(\variable[K]{Guard}\kcomma\variable[K]{T}\kcomma'ListWrap()\kcomma\variable[K]{F})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"ternary"}}}
}{}{}{\kattribute{structural}}{}
\krule[break-none]{
\kprefix{k}{'Break(\reduce{'None(\AnyVar[KList])}{'Some(\constant[\#Int]{1})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"break-none"}}}
}{}{}{\kattribute{structural}}{}
\kcontext{
'Break('Some(\khole{}))}{}{}{}
\krule[break-arg2LangValue]{
\kprefix{k}{'Break('Some(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}))}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"break-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[break-some]{
\kprefix{k}{\reduce{'Break('Some(\variable[Int]{Steps}))}{'Break(\variable[Int]{Steps})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"break-some"}}}
}{}{}{\kattribute{structural}}{}
\krule[break-n]{
\kprefix{k}{'Break(\reduce{\variable[K]{NSteps}}{{\variable[K]{NSteps}}\mathrel{-_{\scriptstyle\it Int}}{\constant[\#Int]{1}}})}
\mathrel{}\kprefix{loopStack}{\reduce{\variable[K]{K}}{\dotCt{List}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"break-n"}}}
}{{\variable[K]{NSteps}}\mathrel{>_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}{}{\kattribute{intermediate}}{}
\krule[break-1]{
\kall{k}{\reduce{'Break(\constant[\#Int]{1})\kra\AnyVar[K]}{\variable[K]{K}}}
\mathrel{}\kprefix{loopStack}{\reduce{{}\terminal{\#loopFrame}({\variable[K]{K}},{\AnyVar[K]})}{\dotCt{List}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"break-1"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \subsection{While} \end{kblock}
\begin{kblock}[text]
 The alternate syntax is desugared into standard while \end{kblock}
\krule[alt-while]{
\kprefix{k}{\reduce{'AltWhile(\variable[K]{G}\kcomma\variable[K]{B})}{'While(\variable[K]{G}\kcomma\variable[K]{B})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"alt-while"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 In order to allow the use of break, we need to push an item in the loop stack 
	at the beginning of the loop, and pop it when it's done. We do this with the 
	following rule. Note that the actual semantics of while is give in the next rule, 
	which is an internal operation.
	TODO: more elegant way? \end{kblock}
\krule[while]{
\kprefix{k}{\reduce{'While(\variable[K]{Cond}\kcomma\variable[K]{Body})\kra\variable[K]{K}}{{}\terminal{\#pushLoopContext}({{}\terminal{\#loopFrame}({\variable[K]{K}},{\constant[\#Bool]{false}})})\kra{}\terminal{\#while}({\variable[K]{Cond}},{\variable[K]{Body}})\kra{}\terminal{\#popLoopContext}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"while"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 Internal operation modelling the semantics of while. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#while}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[while-spec]{
\kprefix{k}{\reduce{{}\terminal{\#while}({\variable[K]{Condition}},{\variable[K]{Body}})}{'If(\variable[K]{Condition}\kcomma'ListWrap(\variable[K]{Body}\kcomma{}\terminal{\#while}({\variable[K]{Condition}},{\variable[K]{Body}}))\kcomma'ListWrap()\kcomma'ListWrap())}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"while-spec"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{For} 
		For is desugared into while. \end{kblock}
\begin{kblock}[text]
 Alternate syntax desugared into standard for \end{kblock}
\krule[alt-for]{
\kprefix{k}{\reduce{'AltFor}{'For}(\variable[K]{Init}\kcomma\variable[K]{Guard}\kcomma\variable[K]{Increment}\kcomma\variable[K]{Body})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"alt-for"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 same as while \end{kblock}
\krule[for]{
\kprefix{k}{\reduce{'For(\variable[K]{Init}\kcomma'ListWrap(\variable[K]{Guard})\kcomma\variable[K]{Increment}\kcomma\variable[K]{Body})\kra\variable[K]{K}}{{}\terminal{\#pushLoopContext}({{}\terminal{\#loopFrame}({\variable[K]{K}},{\constant[\#Bool]{false}})})\kra{}\terminal{\#for}({\variable[K]{Init}},{'ListWrap(\variable[K]{Guard})},{\variable[K]{Increment}},{'ListWrap(\variable[K]{Body})})\kra{}\terminal{\#popLoopContext}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"for"}}}
}{}{}{\kattribute{structural}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#for}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[for-spec]{
\reduce{{}\terminal{\#for}({\variable[K]{Init}},{'ListWrap(\variable[K]{Guard})},{\variable[K]{Increment}},{\variable[K]{Body}})}{'ListWrap({}\terminal{makeForInit}({\variable[K]{Init}})\kcomma{}\terminal{\#while}({\variable[K]{Guard}},{'ListWrap(\variable[K]{Body})\kra{}\terminal{makeForInit}({\variable[K]{Increment}})}))}}{}{}{\kattribute{structural}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{makeForInit}({{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule{
\reduce{{}\terminal{makeForInit}({'ListWrap()})}{\dotCt{K}}}{}{}{}{}
\krule{
\reduce{{}\terminal{makeForInit}({'ListWrap(\variable[K]{I}\kcomma\variable[KList]{Is})})}{'Expr(\variable[K]{I})\kra{}\terminal{makeForInit}({'ListWrap(\variable[KList]{Is})})}}{}{}{}{}
\begin{kblock}[text]
 \subsection{Switch} \end{kblock}
\krule[alt-switch]{
\kprefix{k}{\reduce{'AltSwitch(\variable[K]{In}\kcomma\variable[K]{Clauses})}{'Switch(\variable[K]{In}\kcomma\variable[K]{Clauses})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"alt-switch"}}}
}{}{}{\kattribute{structural}}{}
\kcontext{
'Switch(\khole{}\kcomma\AnyVar[KList])}{}{}{}
\krule[switch-guard2LangValue]{
\kprefix{k}{'Switch(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}\kcomma\AnyVar[KList])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"switch-guard2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[switch]{
\kall{k}{\reduce{'Switch(\variable[KResult]{In}\kcomma\variable[K]{Clauses})\kra\variable[K]{K}}{{}\terminal{\#pushLoopContext}({{}\terminal{\#loopFrame}({\variable[K]{K}},{\constant[\#Bool]{false}})})\kra{}\terminal{\#switch}({\variable[KResult]{In}},{\variable[K]{Clauses}})\kra{}\terminal{\#popLoopContext}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"switch"}}}
}{}{}{\kattribute{step}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#switch}({{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\kcontext{
{}\terminal{\#switch}({\variable[Value]{V}},{'ListWrap('Case(\khole{}\kcomma\AnyVar[KList]\kcomma\AnyVar[KList])\kcomma\variable[KList]{Cases})})}{}{}{}
\krule[switch-spec-default]{
\kprefix{k}{\reduce{{}\terminal{\#switch}({\variable[Value]{VIn}},{'ListWrap('DefaultCase(\constant[\#String]{":"}\kcomma\variable[K]{Stmt})\kcomma\variable[KList]{Cases})})}{\variable[K]{Stmt}\kra{}\terminal{\#runRemainingSwitchClauses}({'ListWrap(\variable[KList]{Cases})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"switch-spec-default"}}}
}{}{}{\kattribute{internal}}{}
\krule[switch-spec-no-default]{
\kprefix{k}{\reduce{{}\terminal{\#switch}({\variable[Value]{VIn}},{'ListWrap('Case(\variable[Value]{VCase}\kcomma\AnyVar[KList]\kcomma\variable[K]{Stmt})\kcomma\variable[KList]{Cases})})}{'If('IsEqual(\variable[Value]{VIn}\kcomma\variable[Value]{VCase})\kcomma\variable[K]{Stmt}\kra{}\terminal{\#runRemainingSwitchClauses}({'ListWrap(\variable[KList]{Cases})})\kcomma'ListWrap()\kcomma{}\terminal{\#switch}({\variable[Value]{VIn}},{'ListWrap(\variable[KList]{Cases})}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"switch-spec-no-default"}}}
}{}{}{\kattribute{internal}}{}
\krule[switch-spec-nil]{
\kprefix{k}{\reduce{{}\terminal{\#switch}({\AnyVar[K]},{'ListWrap()})}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"switch-spec-nil"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#runRemainingSwitchClauses}({{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[switch-spec-run-remaining-clauses]{
\kprefix{k}{\reduce{{}\terminal{\#runRemainingSwitchClauses}({'ListWrap(\variable[KLabel]{Case}(\AnyVar[KList]\kcomma\AnyVar[KList]\kcomma\variable[K]{Stmt})\kcomma\variable[KList]{Cases})})}{\variable[K]{Stmt}\kra{}\terminal{\#runRemainingSwitchClauses}({'ListWrap(\variable[KList]{Cases})})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"switch-spec-run-remaining-clauses"}}}
}{}{}{\kattribute{internal}}{}
\krule[switch-spec-run-remaining-clauses-nil]{
\kprefix{k}{\reduce{{}\terminal{\#runRemainingSwitchClauses}({'ListWrap()})}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"switch-spec-run-remaining-clauses-nil"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Do-while} 
		Do-while is simply desugared into a while. \end{kblock}
\krule[doWhile]{
\kprefix{k}{\reduce{'DoWhile(\variable[K]{Body}\kcomma\variable[K]{Cond})}{'ListWrap(\variable[K]{Body}\kcomma'While(\variable[K]{Cond}\kcomma\variable[K]{Body}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"doWhile"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Foreach} \end{kblock}
\kcontext{
'ForEach(\khole{}\kcomma\AnyVar[K]\kcomma\AnyVar[K])}{}{}{}
\krule[foreach-arg2Loc]{
\kprefix{k}{'ForEach(\reduce{\variable[ConvertibleToLoc]{R}}{{}\terminal{convertToLoc}({\variable[ConvertibleToLoc]{R}},{{}\terminal{r}})}\kcomma\AnyVar[K]\kcomma\AnyVar[K])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"foreach-arg2Loc"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[foreach]{
\kprefix{k}{\reduce{'ForEach(\variable[Loc]{L}\kcomma\variable[K]{Pattern}\kcomma\variable[K]{Stmt})}{{}\terminal{foreach}({{}\terminal{allocValue}({{}\terminal{convertToLanguageValue}({\variable[Loc]{L}})})},{\variable[K]{Pattern}},{\variable[K]{Stmt}})}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\variable[K]{N}},{\AnyVar[K]})}
\mathrel{}\kall{currentForeachItem}{\reduce{\AnyVar[K]}{\variable[Loc]{L}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"foreach"}}}
}{{{}\terminal{\#isObjectType}({\variable[Value]{V}})}\wedge_{\scriptstyle\it Bool}{\left({{\variable[K]{N}}\mathrel{\leq_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)}}{}{\kattribute{step}}{}
\krule[foreach]{
\kprefix{k}{\reduce{'ForEach(\variable[Loc]{L}\kcomma\variable[K]{Pattern}\kcomma\variable[K]{Stmt})}{{}\terminal{foreach}({\variable[Loc]{L}},{\variable[K]{Pattern}},{\variable[K]{Stmt}})}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\variable[K]{N}},{\AnyVar[K]})}
\mathrel{}\kall{currentForeachItem}{\reduce{\AnyVar[K]}{\variable[Loc]{L}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"foreach"}}}
}{{\left({\neg_{\scriptstyle\it Bool}{\left({{}\terminal{\#isObjectType}({\variable[Value]{V}})}\right)}}\right)}\vee_{\scriptstyle\it Bool}{\left({{\variable[K]{N}}\mathrel{>_{\scriptstyle\it Int}}{\constant[\#Int]{1}}}\right)}}{}{\kattribute{step}}{}
\krule[foreach-scalar-1]{
\kprefix{k}{\reduce{'ForEach(\variable[Loc]{L}\kcomma\AnyVar[KList])}{{}\terminal{WARNING}({\constant[\#String]{"Warning: Invalid argument supplied for foreach() in \%s on line \%d\textbackslash n"}})}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"foreach-scalar-1"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[Value]{V}}\terminal{isCompoundValue}}\right)}}{}{\kattribute{step}, \kattribute{error}}{}
\krule[foreach-scalar-2]{
\kprefix{k}{\reduce{'ForEach(\variable[ScalarValue]{V}\kcomma'Pattern(\AnyVar[KList])\kcomma\variable[K]{Stmt})}{{}\terminal{WARNING}({\constant[\#String]{"Warning: Invalid argument supplied for foreach() in \%s on line \%d\textbackslash n"}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"foreach-scalar-2"}}}
}{}{}{\kattribute{step}, \kattribute{error}}{}
\krule[foreach-locNull]{
\kprefix{k}{\reduce{'ForEach(\variable[K]{Arg}\kcomma'Pattern(\AnyVar[KList])\kcomma\variable[K]{Stmt})}{{}\terminal{WARNING}({\constant[\#String]{"Warning: Invalid argument supplied for foreach() in \%s on line \%d\textbackslash n"}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"foreach-locNull"}}}
}{\left({{\variable[K]{Arg}}\mathrel{=_K}{{}\terminal{locNull}}}\right)}{}{\kattribute{step}, \kattribute{error}}{}
\krule[foreach-invalid-pattern]{
\kprefix{k}{\reduce{'ForEach(\AnyVar[KList]\kcomma'Pattern('Some('Key(\variable[K]{K}))\kcomma\AnyVar[KList])\kcomma\AnyVar[KList])}{{}\terminal{ERROR}({\constant[\#String]{"Key element cannot be a reference in \%s on line \%d\textbackslash n"}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"foreach-invalid-pattern"}}}
}{{{}\terminal{getKLabel}{\left({\variable[K]{K}}\right)}}\mathrel{=_{\it KLabel}}{'Ref}}{}{\kattribute{step}, \kattribute{error}}{}
\begin{kblock}[text]
 \subsection{Internal operations for foreach} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{foreach}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}})}{\kattribute{strict}(1)}
\end{syntaxBlock}
\krule[foreach-spec]{
\kall{k}{\reduce{{}\terminal{foreach}({\variable[Loc]{L}},{\variable[K]{Pattern}},{\variable[K]{Stmt}})\kra\variable[K]{K}}{{}\terminal{\#pushLoopContext}({{}\terminal{\#loopFrame}({\variable[K]{K}},{\constant[\#Bool]{false}})})\kra'ListWrap('Expr({}\terminal{\#reset}({\variable[Loc]{L}}))\kcomma{}\terminal{\#while}({'IsNotIdentical('False()\kcomma{}\terminal{\#current}({\variable[Loc]{L}}))},{{}\terminal{*Cond}({{}\terminal{\#isCrntVisib}({\variable[Loc]{L}})},{'ListWrap({}\terminal{initIterationVars}({\variable[Loc]{L}},{\variable[K]{Pattern}})\kcomma\variable[K]{Stmt}\kcomma'If({}\terminal{\#locHoldsCompoundValue}({\variable[Loc]{L}})\kcomma'ListWrap()\kcomma'ListWrap()\kcomma\left({{}\terminal{WARNING}({\constant[\#String]{"Invalid argument supplied for foreach() in \%s on line \%d\textbackslash n"}})\kra'Break(\constant[\#Int]{1})}\right)))},{'ListWrap()})\kra{}\terminal{*Cond}({{}\terminal{\#crntElemWasUnset}},{{}\terminal{\#resetUnsetFlag}},{'Expr({}\terminal{\#next}({\variable[Loc]{L}}))})}))\kra{}\terminal{\#popLoopContext}}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{currentForeachItem}{\reduce{\AnyVar[K]}{\variable[Loc]{L}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"foreach-spec"}}}
}{\left({{\variable[Value]{V}}\terminal{isCompoundValue}}\right)}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{initIterationVars}({{\nonTerminal{\sort{Loc}}}},{{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[init-foreach-iteration-vars-value]{
\kprefix{k}{\reduce{{}\terminal{initIterationVars}({\variable[K]{L}},{'Pattern('None(\AnyVar[KList])\kcomma\variable[K]{X})})}{'Expr('Assign(\variable[K]{X}\kcomma{}\terminal{\#current}({\variable[K]{L}})))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-foreach-iteration-vars-value"}}}
}{{{}\terminal{getKLabel}{\left({\variable[K]{X}}\right)}}\mathrel{\neq_{\it KLabel}}{'Ref}}{}{\kattribute{internal}}{}
\krule[init-foreach-iteration-vars-value-ref]{
\kprefix{k}{\reduce{{}\terminal{initIterationVars}({\variable[K]{L}},{'Pattern('None(\AnyVar[KList])\kcomma'Ref(\variable[K]{X}))})}{'Expr('ReferenceAssign(\variable[K]{X}\kcomma{}\terminal{\#current}({\variable[K]{L}})))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-foreach-iteration-vars-value-ref"}}}
}{}{}{\kattribute{internal}}{}
\krule[init-foreach-iteration-vars-keyvalue]{
\kprefix{k}{\reduce{{}\terminal{initIterationVars}({\variable[K]{L}},{'Pattern('Some('Key(\variable[K]{K}))\kcomma\variable[K]{V})})}{'Expr('Assign(\variable[K]{V}\kcomma{}\terminal{\#current}({\variable[K]{L}})))\kra'Expr('Assign(\variable[K]{K}\kcomma{}\terminal{\#key}({\variable[K]{L}})))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-foreach-iteration-vars-keyvalue"}}}
}{{\left({{{}\terminal{getKLabel}{\left({\variable[K]{V}}\right)}}\mathrel{\neq_{\it KLabel}}{'Ref}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{{}\terminal{getKLabel}{\left({\variable[K]{K}}\right)}}\mathrel{\neq_{\it KLabel}}{'Ref}}\right)}}{}{\kattribute{internal}}{}
\krule[init-foreach-iteration-vars-keyvalue-ref]{
\kprefix{k}{\reduce{{}\terminal{initIterationVars}({\variable[K]{L}},{'Pattern('Some('Key(\variable[K]{K}))\kcomma'Ref(\variable[K]{V}))})}{'Expr('Assign(\variable[K]{K}\kcomma{}\terminal{\#key}({\variable[K]{L}})))\kra'Expr('ReferenceAssign(\variable[K]{V}\kcomma'ArrayAccess(\variable[K]{L}\kcomma\variable[K]{K})))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-foreach-iteration-vars-keyvalue-ref"}}}
}{{{}\terminal{getKLabel}{\left({\variable[K]{K}}\right)}}\mathrel{\neq_{\it KLabel}}{'Ref}}{}{\kattribute{internal}}{}
\krule[init-foreach-iteration-vars-keyvalue-ref]{
\kprefix{k}{\reduce{{}\terminal{initIterationVars}({\variable[K]{L}},{'Pattern('Some('Key('Ref(\variable[K]{K})))\kcomma\AnyVar[KList])})}{{}\terminal{ERROR}({\constant[\#String]{"Key element cannot be a reference in \%s on line \$d\textbackslash n"}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"init-foreach-iteration-vars-keyvalue-ref-error"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \section{Control flow auxiliary operations} \end{kblock}
\begin{kblock}[text]
 \subsection{Checking if the value being iterated is an object or array} 
		Such control is made at the beginning of the 'foreach' loop, producing an error 
		if trying to iterate over a scalar value. 
		However, the value being iterated might be changed at runtime, during the execution
		of the 'foreach' body. 
		For this reason we basically need to check wether the iterated value is a compound 
		value at every iteration. The boolean function below makes this check. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#locHoldsCompoundValue}({{\nonTerminal{\sort{Loc}}}})}{}
\end{syntaxBlock}
\krule[loc-holds-compound-value-true]{
\kprefix{k}{\reduce{{}\terminal{\#locHoldsCompoundValue}({\variable[K]{L}})}{\constant[\#Bool]{true}}}
\mathrel{}\kmiddle[red]{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"loc-holds-compound-value-true"}}}
}{\left({{{}\terminal{\#isArrayType}({\variable[Value]{V}})}\vee_{\scriptstyle\it Bool}{{}\terminal{\#isObjectType}({\variable[Value]{V}})}}\right)}{}{\kattribute{internal}}{}
\krule[loc-holds-compound-value-false]{
\kprefix{k}{\reduce{{}\terminal{\#locHoldsCompoundValue}({\variable[K]{L}})}{\constant[\#Bool]{false}}}
\mathrel{}\kmiddle[red]{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({\variable[Value]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"loc-holds-compound-value-false"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{{}\terminal{\#isArrayType}({\variable[Value]{V}})}\vee_{\scriptstyle\it Bool}{{}\terminal{\#isObjectType}({\variable[Value]{V}})}}\right)}}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Auxiliary operations for loop stack manipulation} 
		The following macros simply push or pop a frame in the loop stack. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#pushLoopContext}({{\nonTerminal{\sort{K}}}})}{}
\end{syntaxBlock}
\krule[push-loop-cntx]{
\kprefix{k}{\reduce{{}\terminal{\#pushLoopContext}({\variable[LoopFrame]{K}})}{\dotCt{K}}}
\mathrel{}\kprefix{loopStack}{\reduce{\dotCt{List}}{\variable[LoopFrame]{K}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"push-loop-cntx"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#popLoopContext}}{}
\end{syntaxBlock}
\krule[pop-loop-cntx]{
\kprefix{k}{\reduce{{}\terminal{\#popLoopContext}}{\variable[K]{K}}}
\mathrel{}\kprefix{loopStack}{\reduce{{}\terminal{\#loopFrame}({\variable[K]{K}},{\variable[Bool]{B}})}{\dotCt{List}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"pop-loop-cntx"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Checking if the current element has been unset in the body} 
		When the current element is unset in the foreach body, the current pointer 
		needs not to be advanced at the end of the iteration. 
		In order to do that we keep a boolean flag in each loop frame. The flag is false
		when the loop starts but during execution might be set to true by other operations
		(e.g. unset) when such a situation is detected.
		In foreach, when such control returns true, we avoid advancing the current 
		pointer for the current iteration. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#crntElemWasUnset}}{}
\end{syntaxBlock}
\krule[crnt-elem-unset-true]{
\kprefix{k}{\reduce{{}\terminal{\#crntElemWasUnset}}{\constant[\#Bool]{true}}}
\mathrel{}\ksuffix{loopStack}{{}\terminal{\#loopFrame}({\AnyVar[K]},{\constant[\#Bool]{true}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"crnt-elem-unset-true"}}}
}{}{}{\kattribute{internal}}{}
\krule[crnt-elem-unset-false]{
\kprefix{k}{\reduce{{}\terminal{\#crntElemWasUnset}}{\constant[\#Bool]{false}}}
\mathrel{}\ksuffix{loopStack}{{}\terminal{\#loopFrame}({\AnyVar[K]},{\constant[\#Bool]{false}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"crnt-elem-unset-false"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 Here we simply reset the flag mentioned above, once the iteration is done\end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#resetUnsetFlag}}{}
\end{syntaxBlock}
\krule[reset-unset-flag]{
\kprefix{k}{\reduce{{}\terminal{\#resetUnsetFlag}}{\dotCt{K}}}
\mathrel{}\ksuffix{loopStack}{{}\terminal{\#loopFrame}({\AnyVar[K]},{\reduce{\AnyVar[K]}{\constant[\#Bool]{false}}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"reset-unset-flag"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Checking if the current element is visible} 
		We desugar foreach into a while loop using 'current' and 'next' language operations, 
		which by default iterate over ALL properties of the object, visible or not, while
		'foreach' only shows the visible properties. 
		We achieve this behaviour by iterating over all the properties but showing only 
		the visible ones, by using the guard defined below. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#isCrntVisib}({{\nonTerminal{\sort{Loc}}}})}{}
\end{syntaxBlock}
\krule[is-crnt-visib-array]{
\kprefix{k}{\reduce{{}\terminal{\#isCrntVisib}({\variable[Loc]{L}})}{\constant[\#Bool]{true}}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({\variable[Array]{V}},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"is-crnt-visib-array"}}}
}{}{}{\kattribute{internal}}{}
\krule[is-crnt-visib-obj-public]{
\kprefix{k}{\reduce{{}\terminal{\#isCrntVisib}({\variable[Loc]{L}})}{\constant[\#Bool]{true}}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[Loc]{L1}},{\AnyVar[K]},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{Array}({[{\AnyVar[K]},{{}\terminal{none}},{\AnyVar[K]}]},{\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"is-crnt-visib-obj-public"}}}
}{}{}{\kattribute{internal}}{}
\krule[is-crnt-visib-obj-protected]{
\kprefix{k}{\reduce{{}\terminal{\#isCrntVisib}({\variable[Loc]{L}})}{{}\terminal{\#isVisible}({\variable[K]{ObjClass}},{\variable[K]{Context}},{{}\terminal{pro}})}}
\mathrel{}\kall{class}{\variable[K]{Context}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[Loc]{L1}},{\variable[K]{ObjClass}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{Array}({[{\AnyVar[K]},{{}\terminal{pro}},{\AnyVar[K]}]},{\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"is-crnt-visib-obj-protected"}}}
}{}{}{\kattribute{internal}}{}
\krule[is-crnt-visib-obj-private-true]{
\kprefix{k}{\reduce{{}\terminal{\#isCrntVisib}({\variable[Loc]{L}})}{\constant[\#Bool]{true}}}
\mathrel{}\kall{class}{\variable[K]{Context}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[Loc]{L1}},{\AnyVar[K]},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{Array}({[{\AnyVar[K]},{{}\terminal{pri}({\variable[K]{Context}})},{\AnyVar[K]}]},{\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"is-crnt-visib-obj-private-true"}}}
}{}{}{\kattribute{internal}}{}
\krule[is-crnt-visib-obj-private-false]{
\kprefix{k}{\reduce{{}\terminal{\#isCrntVisib}({\variable[Loc]{L}})}{\constant[\#Bool]{false}}}
\mathrel{}\kall{class}{\variable[K]{Context}}
\mathrel{}\kmiddle[red]{heap}{\variable[Loc]{L}\mapsto{}\terminal{zval}({{}\terminal{OID}({\variable[Loc]{L1}},{\variable[K]{ObjClass}},{\AnyVar[K]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})\mathrel{}\variable[Loc]{L1}\mapsto{}\terminal{zval}({{}\terminal{Array}({[{\AnyVar[K]},{{}\terminal{pri}({\variable[Id]{Owner}})},{\AnyVar[K]}]},{\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"is-crnt-visib-obj-private-false"}}}
}{\left({{\variable[K]{Context}}\mathrel{\neq_K}{\variable[Id]{Owner}}}\right)}{}{\kattribute{internal}}{}
\end{module}
\begin{module}{\moduleName{SCOPE-RESOLUTION}}
\begin{kblock}[text]
 \section{Self and parent} \end{kblock}
\krule[class-name-normal]{
\reduce{'ClassName(\variable[String]{S})}{\variable[String]{S}}}{{\left({{\variable[String]{S}}\terminal{=/=String}{\constant[\#String]{"self"}}}\right)}\wedge_{\scriptstyle\it Bool}{\left({{\variable[String]{S}}\terminal{=/=String}{\constant[\#String]{"parent"}}}\right)}}{}{\kattribute{step}}{}
\krule[class-name-self]{
\kprefix{k}{\reduce{'ClassName(\constant[\#String]{"self"})}{{}\terminal{Id2String}({\variable[K]{CurrentClass}})}}
\mathrel{}\kall{class}{\variable[K]{CurrentClass}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"class-name-self"}}}
}{}{}{\kattribute{step}}{}
\krule[class-name-parent]{
\kprefix{k}{\reduce{'ClassName(\constant[\#String]{"parent"})}{{}\terminal{Id2String}({\variable[K]{ParentClass}})}}
\mathrel{}\kall{class}{\variable[K]{CurrentClass}}
\mathrel{}\kmiddle{classes}{\variable[K]{CurrentClass}\mapsto{}\terminal{class}({\variable[K]{ParentClass}},{\AnyVar[List]},{\AnyVar[Map]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"class-name-parent"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \section{Static method call} \end{kblock}
\kcontext{
'StaticFunctionCall(\khole{}\kcomma\AnyVar[K]\kcomma\AnyVar[K])}{}{}{\kattribute{structural}}
\kcontext{
'StaticFunctionCall(\AnyVar[K]\kcomma\khole{}\kcomma\AnyVar[K])}{}{}{\kattribute{structural}}
\kcontext{
'StaticFunctionCall(\AnyVar[K]\kcomma\AnyVar[K]\kcomma'ListWrap(\AnyVar[KList]\kcomma\khole{}\kcomma\AnyVar[KList]))}{}{}{\kattribute{structural}}
\krule[static-fun-fname2LangValue]{
\kprefix{k}{'StaticFunctionCall(\AnyVar[K]\kcomma\reduce{\variable[Ref]{R}}{{}\terminal{convertToLanguageValue}({\variable[Ref]{R}})}\kcomma\AnyVar[K])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"static-fun-fname2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[static-fun]{
\kprefix{k}{\reduce{'StaticFunctionCall(\variable[String]{ClassName}\kcomma\variable[String]{MethName}\kcomma'ListWrap(\variable[KList]{Args}))}{{}\terminal{\#methRunIfVisible}({{}\terminal{\#methodLookup}({{}\terminal{String2Id}({\variable[String]{ClassName}})},{\variable[String]{MethName}})},{'ListWrap(\variable[KList]{Args})},{{}\terminal{none}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"static-fun"}}}
}{isKResult(\variable[KList]{Args})}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \section{Access to class static properties} \end{kblock}
\krule[class-constant-arg2Id]{
\kprefix{k}{'ClassConstant(\reduce{\variable[String]{S}}{{}\terminal{String2Id}({\variable[String]{S}})}\kcomma\AnyVar[K])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"class-constant-arg2Id"}}}
}{}{}{\kattribute{internal}}{}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{STUCK}}{}
\end{syntaxBlock}
\krule[class-constant-parent]{
\kprefix{k}{'ClassConstant(\reduce{\variable[Id]{ClassName}}{\variable[K]{Parent}}\kcomma'Variable('Simple(\variable[String]{X})))}
\mathrel{}\kmiddle{classes}{\variable[Id]{ClassName}\mapsto{}\terminal{class}({\variable[K]{Parent}},{\AnyVar[List]},{\AnyVar[Map]},{\variable[K]{L}})}
\mathrel{}\kmiddle[red]{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\variable[List]{M}})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"class-constant-parent"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[List]{M}}\terminal{hasProperty}{\variable[String]{X}}}\right)}}{}{\kattribute{intermediate}}{}
\krule[class-constant]{
\kprefix{k}{\reduce{'ClassConstant(\variable[Id]{ClassName}\kcomma'Variable('Simple(\variable[String]{X})))}{{}\terminal{*Cond}({{}\terminal{\#isVisible}({\variable[K]{Context}},{\variable[Id]{ClassName}},{\variable[K]{V}})},{\variable[K]{L1}},{{}\terminal{STUCK}})}}
\mathrel{}\kmiddle{classes}{\variable[Id]{ClassName}\mapsto{}\terminal{class}({\AnyVar[K]},{\AnyVar[List]},{\AnyVar[Map]},{\variable[K]{L}})}
\mathrel{}\kmiddle[red]{heap}{\variable[K]{L}\mapsto{}\terminal{zval}({{}\terminal{Array}({\AnyVar[K]},{\AnyVar[List]\mathrel{}[{\variable[String]{X}},{\variable[K]{V}},{\variable[K]{L1}}]\mathrel{}\AnyVar[List]})},{\AnyVar[K]},{\AnyVar[K]},{\AnyVar[K]})}
\mathrel{}\kall{class}{\variable[K]{Context}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"class-constant"}}}
}{}{}{\kattribute{step}}{}
\end{module}
\begin{module}{\moduleName{STRINGS}}
\begin{kblock}[text]
 \section{Strings} \end{kblock}
\kcontext{
'ConstantEncapsedString(\khole{})}{}{}{}
\krule[constant-encapsed-string]{
\kprefix{k}{\reduce{'ConstantEncapsedString(\variable[String]{S})}{\variable[String]{S}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"constant-encapsed-string"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{String Access} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'StringAccess}}{}
\end{syntaxBlock}
\krule{
\reduce{'StringAccess}{'ArrayAccess}(\AnyVar[KList]\kcomma\AnyVar[KList])}{}{}{}{}
\begin{kblock}[text]
 \subsection{Single Quoted Strings} \end{kblock}
\kcontext{
'SingleQuoted('ListWrap(\AnyVar[KList]\kcomma\khole{}\kcomma\AnyVar[KList]))}{}{}{}
\krule[single-quoted]{
\kprefix{k}{\reduce{'SingleQuoted('ListWrap(\variable[String]{S}))}{\variable[String]{S}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"single-quoted"}}}
}{}{}{\kattribute{structural}}{}
\krule[single-quoted-empty]{
\kprefix{k}{\reduce{'SingleQuoted('ListWrap())}{\constant[\#String]{""}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"single-quoted-empty"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Double Quoted Strings} \end{kblock}
\kcontext{
'DoubleQuoted(\khole{})}{}{}{}
\krule[double-quoted]{
\kprefix{k}{\reduce{'DoubleQuoted(\variable[String]{S})}{\variable[String]{S}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"double-quoted"}}}
}{}{}{\kattribute{structural}}{}
\kcontext{
'DQContent('Some(\khole{}))}{}{}{}
\krule[dq-content]{
\kprefix{k}{\reduce{'DQContent('Some(\variable[String]{S}))}{\variable[String]{S}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dq-content"}}}
}{}{}{\kattribute{structural}}{}
\krule[dq-content-empty]{
\kprefix{k}{\reduce{'DQContent('None(\AnyVar[KList]))}{\constant[\#String]{""}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dq-content-empty"}}}
}{}{}{\kattribute{structural}}{}
\kcontext{
'DQContent(\khole{}\kcomma\AnyVar[K]\kcomma\AnyVar[K])}{}{}{}
\kcontext{
'DQContent(\AnyVar[K]\kcomma\khole{}\kcomma\AnyVar[K])}{}{}{}
\kcontext{
'DQContent(\AnyVar[K]\kcomma\AnyVar[K]\kcomma\khole{})}{}{}{}
\krule[dq-content-arg2LangValue-1]{
\kprefix{k}{'DQContent(\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}\kcomma\AnyVar[K]\kcomma\AnyVar[K])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dq-content-arg2LangValue-1"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[dq-content-arg2LangValue-2]{
\kprefix{k}{'DQContent(\AnyVar[K]\kcomma\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})}\kcomma\AnyVar[K])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dq-content-arg2LangValue-2"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[dq-content-arg2LangValue-3]{
\kprefix{k}{'DQContent(\AnyVar[K]\kcomma\AnyVar[K]\kcomma\reduce{\variable[ConvertibleToLanguageValue]{R}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{R}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dq-content-arg2LangValue-3"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[dq-content-arg-none-1]{
\kprefix{k}{'DQContent(\reduce{'None(\AnyVar[KList])}{\constant[\#String]{""}}\kcomma\AnyVar[K]\kcomma\AnyVar[K])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dq-content-arg-none-1"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[dq-content-arg-none-2]{
\kprefix{k}{'DQContent(\AnyVar[K]\kcomma\reduce{'None(\AnyVar[KList])}{\constant[\#String]{""}}\kcomma\AnyVar[K])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dq-content-arg-none-2"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[dq-content-arg-none-3]{
\kprefix{k}{'DQContent(\AnyVar[K]\kcomma\AnyVar[K]\kcomma\reduce{'None(\AnyVar[KList])}{\constant[\#String]{""}})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dq-content-arg-none-3"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[dq-content-concat]{
\kprefix{k}{\reduce{'DQContent(\variable[LanguageValue]{S1}\kcomma\variable[LanguageValue]{S2}\kcomma\variable[LanguageValue]{S3})}{'Concat('Concat({}\terminal{*toString}({\variable[LanguageValue]{S1}})\kcomma{}\terminal{*toString}({\variable[LanguageValue]{S2}}))\kcomma{}\terminal{*toString}({\variable[LanguageValue]{S3}}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"dq-content-concat"}}}
}{}{}{\kattribute{intermediate}}{}
\begin{kblock}[text]
 \subsection{Braced variables} \end{kblock}
\kcontext{
'Variable('Braced(\khole{}))}{}{}{}
\krule[braced]{
\kprefix{k}{\reduce{'Braced(\variable[K]{Stuff})}{\variable[K]{Stuff}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"braced"}}}
}{}{}{\kattribute{structural}}{}
\krule[var-braced-arg2LangValue]{
\kprefix{k}{'Variable('Braced(\reduce{\variable[Ref]{R}}{{}\terminal{convertToLanguageValue}({\variable[Ref]{R}})}))}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"var-braced-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[var-braced]{
\kprefix{k}{\reduce{'Variable('Braced(\variable[String]{S}))}{'Variable('Simple(\variable[String]{S}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"var-braced"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \subsection{String Concatenation Operation} \end{kblock}
\kcontext{
'Concat(\khole{}\kcomma\AnyVar[K])}{}{}{}
\kcontext{
'Concat(\AnyVar[BasicRef]\kcomma\khole{})}{}{}{}
\kcontext{
'Concat(\AnyVar[LanguageValue]\kcomma\khole{})}{}{}{}
\krule[concat-LHS2LangValue-1]{
\kprefix{k}{'Concat(\reduce{\variable[LRef]{R}}{{}\terminal{convertToLanguageValue}({\variable[LRef]{R}})}\kcomma\AnyVar[KList])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"concat-LHS2LangValue-1"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[concat-LHS2LangValue-2]{
\kprefix{k}{'Concat(\reduce{\variable[Loc]{R}}{{}\terminal{convertToLanguageValue}({\variable[Loc]{R}})}\kcomma\AnyVar[KList])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"concat-LHS2LangValue-2"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[concat-RHS2LangValue-1]{
\kprefix{k}{'Concat(\AnyVar[LanguageValue]\kcomma\reduce{\variable[ConvertibleToLanguageValue]{V1}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{V1}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"concat-RHS2LangValue-1"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[concat-RHS2LangValue-2]{
\kprefix{k}{'Concat(\AnyVar[BasicRef]\kcomma\reduce{\variable[ConvertibleToLanguageValue]{V1}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{V1}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"concat-RHS2LangValue-2"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[concat-LHS2LangValue]{
\kprefix{k}{'Concat(\reduce{\variable[BasicRef]{V}}{{}\terminal{convertToLanguageValue}({\variable[BasicRef]{V}})}\kcomma\AnyVar[LanguageValue])}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"concat-LHS2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule[concat-string]{
\kprefix{k}{\reduce{'Concat(\variable[String]{Str1}\kcomma\variable[String]{Str2})}{{\variable[String]{Str1}}+_{\scriptstyle\it String}{\variable[String]{Str2}}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"concat-string"}}}
}{}{}{\kattribute{step}}{}
\krule[concat-toString]{
\kprefix{k}{\reduce{'Concat(\variable[LanguageValue]{V1}\kcomma\variable[LanguageValue]{V2})}{'Concat({}\terminal{*toString}({\variable[LanguageValue]{V1}})\kcomma{}\terminal{*toString}({\variable[LanguageValue]{V2}}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"concat-toString"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{{}\terminal{\#isStringType}({\variable[LanguageValue]{V1}})}\wedge_{\scriptstyle\it Bool}{{}\terminal{\#isStringType}({\variable[LanguageValue]{V2}})}}\right)}}{}{\kattribute{intermediate}}{}
\begin{kblock}[text]
 \subsection{Concatenation assignment shortcut} \end{kblock}
\krule[concat-assign]{
\kprefix{k}{\reduce{'ConcatAssign(\variable[K]{X}\kcomma\variable[K]{Y})}{'Assign(\variable[K]{X}\kcomma'Concat(\variable[K]{X}\kcomma\variable[K]{Y}))}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"concat-assign"}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Escape Characters} \end{kblock}
\krule[escape-34]{
\kprefix{k}{\reduce{'Escape(\constant[\#Int]{34})}{\constant[\#String]{"\textbackslash ""}}}
}{}{}{}{}
\krule[escape-36]{
\kprefix{k}{\reduce{'Escape(\constant[\#Int]{36})}{\constant[\#String]{"\$"}}}
}{}{}{}{}
\krule[escape-39]{
\kprefix{k}{\reduce{'Escape(\constant[\#Int]{39})}{\constant[\#String]{"'"}}}
}{}{}{}{}
\krule[escape-92]{
\kprefix{k}{\reduce{'Escape(\constant[\#Int]{92})}{\constant[\#String]{"\textbackslash \textbackslash "}}}
}{}{}{}{}
\krule[escape-110]{
\kprefix{k}{\reduce{'Escape(\constant[\#Int]{110})}{\constant[\#String]{"\textbackslash n"}}}
}{}{}{}{}
\krule[escape-116]{
\kprefix{k}{\reduce{'Escape(\constant[\#Int]{116})}{\constant[\#String]{"\textbackslash t"}}}
}{}{}{}{}
\krule[escape-114]{
\kprefix{k}{\reduce{'Escape(\constant[\#Int]{114})}{\constant[\#String]{"\textbackslash r"}}}
}{}{}{}{}
\end{module}
\begin{module}{\moduleName{INCLUDE}}
\begin{kblock}[text]
 \section{File inclusion} 
		Doesnt work. \end{kblock}
\krule[eval]{
\kprefix{k}{\reduce{'InternalFunction('Eval(\AnyVar[KList]))}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"KPHP ERROR: 'Eval not supported"}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"eval"}}}
}{}{}{\kattribute{step}, \kattribute{error}}{}
\krule[include]{
\kprefix{k}{\reduce{'InternalFunction('Include(\AnyVar[KList]))}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"KPHP ERROR: 'Include not supported"}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"include"}}}
}{}{}{\kattribute{step}, \kattribute{error}}{}
\krule[require-once]{
\kprefix{k}{\reduce{'InternalFunction('RequireOnce(\AnyVar[KList]))}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"KPHP ERROR: 'RequireOnce not supported"}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"require-once"}}}
}{}{}{\kattribute{step}, \kattribute{error}}{}
\krule[require]{
\kprefix{k}{\reduce{'InternalFunction('Require(\AnyVar[KList]))}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"KPHP ERROR: 'Require not supported"}})}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"require"}}}
}{}{}{\kattribute{step}, \kattribute{error}}{}
\end{module}
\begin{module}{\moduleName{NOT-SUPPORTED}}
\begin{kblock}[text]
 \section{Language constructs which we do not support} 
		Declare here the KLabels of the stuff we do not support, and move them in the 
		appropriate file when implementing the corresponding feature. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{KLabel}}}\syntax{\terminal{'ASPCloseTag}}{}\syntaxCont{{}\terminal{'ASPOpenTag}}{}\syntaxCont{{}\terminal{'Abstract}}{}\syntaxCont{{}\terminal{'AbstractClass}}{}\syntaxCont{{}\terminal{'AbstractMethodBody}}{}\syntaxCont{{}\terminal{'AltElseIf}}{}\syntaxCont{{}\terminal{'AltForEach}}{}\syntaxCont{{}\terminal{'AndAssign}}{}\syntaxCont{{}\terminal{'ArrayCast}}{}\syntaxCont{{}\terminal{'BinAnd}}{}\syntaxCont{{}\terminal{'Body}}{}\syntaxCont{{}\terminal{'Braced}}{}\syntaxCont{{}\terminal{'BracedArrayAccess}}{}\syntaxCont{{}\terminal{'ClassConstantDecl}}{}\syntaxCont{{}\terminal{'ClassConstantDeclList}}{}\syntaxCont{{}\terminal{'Clone}}{}\syntaxCont{{}\terminal{'Continue}}{}\syntaxCont{{}\terminal{'Declare}}{}\syntaxCont{{}\terminal{'DefaultCase}}{}\syntaxCont{{}\terminal{'Directive}}{}\syntaxCont{{}\terminal{'DivAssign}}{}\syntaxCont{{}\terminal{'EchoOpenTag}}{}\syntaxCont{{}\terminal{'ElseIf}}{}\syntaxCont{{}\terminal{'EmbeddedArrayVariable}}{}\syntaxCont{{}\terminal{'EmbeddedString}}{}\syntaxCont{{}\terminal{'ErrorFree}}{}\syntaxCont{{}\terminal{'Eval}}{}\syntaxCont{{}\terminal{'Final}}{}\syntaxCont{{}\terminal{'FinalClass}}{}\syntaxCont{{}\terminal{'HereDoc}}{}\syntaxCont{{}\terminal{'HereDocContent}}{}\syntaxCont{{}\terminal{'HereDocStart}}{}\syntaxCont{{}\terminal{'Hexa}}{}\syntaxCont{{}\terminal{'HexaChar}}{}\syntaxCont{{}\terminal{'Implements}}{}\syntaxCont{{}\terminal{'IncludeOnce}}{}\syntaxCont{{}\terminal{'InlineHTML}}{}\syntaxCont{{}\terminal{'InterfaceDecl}}{}\syntaxCont{{}\terminal{'InterfaceExtends}}{}\syntaxCont{{}\terminal{'InterfaceFunction}}{}\syntaxCont{{}\terminal{'InterfaceFunctionRef}}{}\syntaxCont{{}\terminal{'MagicConstant}}{}\syntaxCont{{}\terminal{'MinAssign}}{}\syntaxCont{{}\terminal{'ModAssign}}{}\syntaxCont{{}\terminal{'MulAssign}}{}\syntaxCont{{}\terminal{'Neg}}{}\syntaxCont{{}\terminal{'NullCast}}{}\syntaxCont{{}\terminal{'Octa}}{}\syntaxCont{{}\terminal{'OctaChar}}{}\syntaxCont{{}\terminal{'OldFunctionDecl}}{}\syntaxCont{{}\terminal{'OldFunctionDeclRef}}{}\syntaxCont{{}\terminal{'OrAssign}}{}\syntaxCont{{}\terminal{'ParamConstant}}{}\syntaxCont{{}\terminal{'PlusAssign}}{}\syntaxCont{{}\terminal{'Ref}}{}\syntaxCont{{}\terminal{'RefValue}}{}\syntaxCont{{}\terminal{'SLAssign}}{}\syntaxCont{{}\terminal{'SRAssign}}{}\syntaxCont{{}\terminal{'ShellCommand}}{}\syntaxCont{{}\terminal{'StaticVariable}}{}\syntaxCont{{}\terminal{'VariableBraced}}{}\syntaxCont{{}\terminal{'Print}}{}\syntaxCont{{}\terminal{'Name}}{}
\end{syntaxBlock}
\krule{
\reduce{'InterfaceDecl(\AnyVar[KList])}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"'InterfaceDecl"}})}}{}{}{}{}
\krule{
\reduce{{}\terminal{\#noparse}}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"runtime parsing not supported (eval, include, etc.)"}})}}{}{}{}{}
\krule{
\reduce{'MinAssign(\AnyVar[KList])}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"'MinAssign"}})}}{}{}{}{}
\krule{
\reduce{'ModAssign(\AnyVar[KList])}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"'ModAssign"}})}}{}{}{}{}
\krule{
\reduce{'RefValue(\AnyVar[KList])}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"'RefValue"}})}}{}{}{}{}
\krule{
\reduce{'ErrorFree(\AnyVar[KList])}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"'ErrorFree"}})}}{}{}{}{}
\krule{
\reduce{'HexaChar(\AnyVar[KList])}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"'HexaChar"}})}}{}{}{}{}
\krule{
\reduce{'MagicConstant(\AnyVar[KList])}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"'MagicConstant"}})}}{}{}{}{}
\krule{
\reduce{'ErrorFree(\AnyVar[KList])}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"'ErrorFree"}})}}{}{}{}{}
\krule{
\reduce{'InternalFunction('IncludeOnce(\AnyVar[KList]))}{{}\terminal{NOT-SUPPORTED}({\constant[\#String]{"IncludeOnce"}})}}{}{}{}{}
\end{module}
\begin{module}{\moduleName{CONSTANTS}}
\begin{kblock}[text]
 \section{Constants} 
		Constants are added via the 'define(CONST_NAME, ScalarValue)' internal function.
   		They are available averywhere (like superglobals) and cannot be reassigned. \end{kblock}
\begin{kblock}[text]
 If the constant extists, its value is returned \end{kblock}
\krule[constant-declared]{
\kprefix{k}{\reduce{'ConstantVariable(\variable[String]{ConstName})}{\variable[K]{Value}}}
\mathrel{}\kmiddle{constants}{\variable[String]{ConstName}\mapsto\variable[K]{Value}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"constant-declared"}}}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 Otherwise, the name of the constant itself is returned \end{kblock}
\krule[constant-undeclared]{
\kprefix{k}{\reduce{'ConstantVariable(\variable[String]{ConstName})}{\variable[String]{ConstName}}}
\mathrel{}\kall{constants}{\variable[Map]{Constants}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"constant-undeclared"}}}
}{\neg_{\scriptstyle\it Bool}{\left({{\variable[String]{ConstName}}\terminal{in}{{}\terminal{keys}{\left({\variable[Map]{Constants}}\right)}}}\right)}}{}{\kattribute{step}}{}
\end{module}
\begin{module}{\moduleName{EXCEPTIONS}}
\begin{kblock}[text]
 \section{Exceptions} 
		We model PHP exception mechanisms following the standard K approach introduced in 
		KOOL. Note that we only model the try-catch construct, but we don't model the 
		finally clause. This is because it is not supported by our parser at the moment. \end{kblock}
\begin{kblock}[text]
 \subsection{Exception stack frames} 
		Stack frames contains, in this order: the name of the class, the variable, the 
		catch body and finally the continuation. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{({{\nonTerminal{\sort{Id}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{K}}}},{{\nonTerminal{\sort{Bag}}}})}{}
\end{syntaxBlock}
\begin{kblock}[text]
 \subsection{Try-catch} \end{kblock}
\krule[try-catch]{
\kall{k}{\reduce{'Try('Body(\variable[K]{TryBody})\kcomma'ListWrap('Catch(\variable[String]{XClass}\kcomma\variable[K]{VarName}\kcomma'Body(\variable[K]{CatchBody}))))}{\variable[K]{TryBody}\kra{}\terminal{\#popx}}\kra\variable[K]{K}}
\mathrel{}\kall[cyan]{control}{\variable[Bag]{C}\mathrel{}\kprefix{exceptionStack}{\reduce{\dotCt{List}}{({{}\terminal{String2Id}({\variable[String]{XClass}})},{\variable[K]{VarName}},{\variable[K]{CatchBody}},{\variable[K]{K}},{\variable[Bag]{C}})}}
}
}{}{}{\kattribute{step}}{}
\begin{kblock}[text]
 \subsection{Popping the stack frame} 
		If the try body is executed and no exception is thrown, the exception stack frame 
		created before needs to be dissolved. \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{\#popx}}{}
\end{syntaxBlock}
\krule[pop-exception-frame]{
\kprefix{k}{\reduce{{}\terminal{\#popx}}{\dotCt{K}}}
\mathrel{}\kprefix{exceptionStack}{\reduce{\AnyVar[List]}{\dotCt{List}}}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"pop-exception-frame"}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Throw} \end{kblock}
\kcontext{
'Throw(\khole{})}{}{}{\kattribute{structural}}
\krule[throw-arg2LangValue]{
\kprefix{k}{'Throw(\reduce{\variable[ConvertibleToLanguageValue]{L}}{{}\terminal{convertToLanguageValue}({\variable[ConvertibleToLanguageValue]{L}})})}
\mathrel{}\kall{trace}{\reduce{\variable[List]{Trace}}{\variable[List]{Trace}\mathrel{}\constant[\#String]{"throw-arg2LangValue"}}}
}{}{}{\kattribute{intermediate}}{}
\krule{
\kall{k}{\reduce{'Throw(\variable[Object]{V})\kra\AnyVar[K]}{'Expr('Assign(\variable[K]{VarName}\kcomma\variable[Object]{V}))\kra\variable[K]{CatchBody}\kra\variable[K]{K}}}
\mathrel{}\kall[cyan]{control}{\kprefix{exceptionStack}{\reduce{({\variable[Id]{XClass}},{\variable[K]{VarName}},{\variable[K]{CatchBody}},{\variable[K]{K}},{\variable[Bag]{C}})}{\dotCt{List}}}
\mathrel{}\reduce{\AnyVar[Bag]}{\variable[Bag]{C}}}
}{}{}{\kattribute{step}}{}
\end{module}
\begin{module}{\moduleName{POST-EXECUTION}}
\begin{kblock}[text]
 \section{Post execution} 
		In this module we define stuff that will be executed after the program has run. 
		For now, we just include some form of garbage collection (i.e. cleanup of the zvals
		with a ref count equals to zero). \end{kblock}
\begin{kblock}[text]
 \subsection{Detecting termination} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{terminated}}{}
\end{syntaxBlock}
\krule[termination]{
\kall{k}{\reduce{\dotCt{K}}{{}\terminal{terminated}}}
\mathrel{}\kall{isTerminated}{\reduce{\constant[\#Bool]{false}}{\constant[\#Bool]{true}}}
}{}{}{\kattribute{structural}}{}
\begin{kblock}[text]
 \subsection{Post execution operations} \end{kblock}
\krule[post-exec-ops]{
\kprefix{k}{\reduce{{}\terminal{terminated}}{{}\terminal{cleanTrace}\kra{}\terminal{gc}}}
}{}{}{\kattribute{internal}}{}
\begin{kblock}[text]
 \subsection{Clean trace} \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{cleanTrace}}{}
\end{syntaxBlock}
\krule[clean-trace-enabled-true]{
\kprefix{k}{\reduce{{}\terminal{cleanTrace}}{\dotCt{K}}}
\mathrel{}\kall{trace}{\reduce{\AnyVar[List]}{\dotCt{List}}}
\mathrel{}\kall{cleanTraceOnTermination}{\constant[\#Bool]{true}}
}{}{}{}{}
\krule[clean-trace-enabled-false]{
\kprefix{k}{\reduce{{}\terminal{cleanTrace}}{\dotCt{K}}}
\mathrel{}\kall{cleanTraceOnTermination}{\constant[\#Bool]{false}}
}{}{}{}{}
\begin{kblock}[text]
 \subsection{Garbage collection} 
		Simple mark and sweep \end{kblock}

\begin{syntaxBlock}{\nonTerminal{\sort{K}}}\syntax{{}\terminal{gc}}{}\syntaxCont{{}\terminal{mark}({{\nonTerminal{\sort{Map}}}})}{}\syntaxCont{{}\terminal{sweep}}{}
\end{syntaxBlock}
\krule[gc-enabled]{
\kprefix{k}{\reduce{{}\terminal{gc}}{{}\terminal{mark}({\variable[Map]{Mem}})\kra{}\terminal{sweep}}}
\mathrel{}\kall[red]{heap}{\variable[Map]{Mem}}
\mathrel{}\kall{locationsToCollect}{\reduce{\AnyVar[List]}{\dotCt{List}}}
\mathrel{}\kall{gcEnabled}{\constant[\#Bool]{true}}
}{}{}{}{}
\krule[gc-disabled]{
\kprefix{k}{\reduce{{}\terminal{gc}}{\dotCt{K}}}
\mathrel{}\kall{gcEnabled}{\constant[\#Bool]{false}}
}{}{}{}{}
\krule[mark-collect]{
\kprefix{k}{{}\terminal{mark}({\reduce{\variable[Loc]{L}\mapsto{}\terminal{zval}({\AnyVar[K]},{\AnyVar[K]},{\constant[\#Int]{0}},{\AnyVar[K]})}{\dotCt{Map}}\mathrel{}\variable[Map]{Mem}})}
\mathrel{}\kall{locationsToCollect}{\reduce{\variable[List]{Locs2Collect}}{\variable[List]{Locs2Collect}\mathrel{}\variable[Loc]{L}}}
}{}{}{}{}
\krule[mark-leave]{
\kprefix{k}{{}\terminal{mark}({\reduce{\variable[Loc]{L}\mapsto{}\terminal{zval}({\AnyVar[K]},{\AnyVar[K]},{\variable[K]{RefCount}},{\AnyVar[K]})}{\dotCt{Map}}\mathrel{}\variable[Map]{Mem}})}
}{\left({{\variable[K]{RefCount}}\mathrel{>_{\scriptstyle\it Int}}{\constant[\#Int]{0}}}\right)}{}{}{}
\krule[mark-done]{
\kprefix{k}{\reduce{{}\terminal{mark}({\dotCt{Map}})}{\dotCt{K}}}
}{}{}{}{}
\krule[sweep-some]{
\kprefix{k}{{}\terminal{sweep}}
\mathrel{}\kall{locationsToCollect}{\reduce{\variable[K]{L}}{\dotCt{List}}\mathrel{}\variable[List]{Locs2Collect}}
\mathrel{}\kmiddle[red]{heap}{\reduce{\left({\variable[K]{L}\mapsto\AnyVar[K]}\right)}{\dotCt{Map}}}
}{}{}{}{}
\krule[sweep-none]{
\kprefix{k}{\reduce{{}\terminal{sweep}}{\dotCt{K}}}
\mathrel{}\kall{locationsToCollect}{\dotCt{List}}
}{}{}{}{}
\end{module}
\begin{module}{\moduleName{PHP}}
\end{module}
\end{kdefinition}
\end{document}
